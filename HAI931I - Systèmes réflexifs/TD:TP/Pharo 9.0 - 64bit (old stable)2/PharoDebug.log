THERE_BE_DRAGONS_HERE
Instance of Object class did not understand #initialize:
26 September 2022 7:12:12.856175 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
StackToRegisterMappingCogit * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
v9.0.18 - Commit: 7249c170 - Date: 2022-09-02 14:31:12 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

Pile class(Object)>>doesNotUnderstand: #initialize:
	Receiver: Pile
	Arguments and temporary variables: 
		aMessage: 	initialize: nil
		exception: 	Instance of Object class did not understand #initialize:
		resumeValue: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#grow->Pile>>#grow #initialize:->Pile>>#initiali...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#Pile
		classPool: 	a Dictionary(#tailleDefaut->nil )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#HAI914I


Pile class>>new:
	Receiver: Pile
	Arguments and temporary variables: 
		taille: 	4
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#grow->Pile>>#grow #initialize:->Pile>>#initiali...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#Pile
		classPool: 	a Dictionary(#tailleDefaut->nil )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#HAI914I


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ p := Pile new: 4
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ p := Pile new: 4
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'p:= Pile new: 4.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 16) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'p:= Pile new: 4.' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'p:= Pile new: 4.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 16) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'p:= Pile new: 4.' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodeInspectItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodeInspectItCommand
	Arguments and temporary variables: 
		aString: 	'p:= Pile new: 4.'
		aBlock: 	[ :result | 
		self inspectObject: result ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Inspect it'
		basicDescription: 	'Evaluate selection and inspect the result.'
		transform: 	[ :aContext | aContext ]


SpCodeInspectItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodeInspectItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
		self inspectObject: result ]
		selection: 	'p:= Pile new: 4.'
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Inspect it'
		basicDescription: 	'Evaluate selection and inspect the result.'
		transform: 	[ :aContext | aContext ]


SpCodeInspectItCommand>>execute
	Receiver: a SpCodeInspectItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Inspect it'
		basicDescription: 	'Evaluate selection and inspect the result.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Inspect it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodeInspectItCommand
		iconProvider: 	a ThemeIcons(idea11)
		iconName: 	#smallInspectIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Inspect it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Inspect it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ aCommand execute ] in SpMenuPresenterBuilder>>fillItem:with:
	Receiver: a SpMenuPresenterBuilder
	Arguments and temporary variables: 
		aMenuItem: 	a SpMenuItemPresenter
		aCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		menuPresenter: 	a SpMenuPresenter
		stack: 	a Stack(a SpMenuPresenter)


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ aCommand execute ]
	Arguments and temporary variables: 
		anArg: 	a SpMorphicMenuItemAdapter
	Receiver's instance variables: 
		outerContext: 	SpMenuPresenterBuilder>>fillItem:with:
		startpc: 	a CompiledBlock: [ aCommand execute ]
		numArgs: 	0
		receiver: 	a SpMenuPresenterBuilder


SpMenuItemPresenter>>performMenuActionWith:
	Receiver: a SpMenuItemPresenter
	Arguments and temporary variables: 
		aMenuItem: 	a SpMorphicMenuItemAdapter
		en: 	true
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicMenuItemAdapter)
		announcer: 	an Announcer
		owner: 	a SpMenuGroupPresenter
		adapter: 	a SpMorphicMenuItemAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		name: 	an ObservableValueHolder[ 'Inspect it' ]
		icon: 	an ObservableValueHolder[ Form(16x16x32) ]
		description: 	an ObservableValueHolder[ 'Evaluate selection and inspect the resu...etc...
		action: 	[ aCommand execute ]
		shortcut: 	a KMKeyCombinationChoice
		subMenu: 	nil
		state: 	nil
		autoRefresh: 	false


SpMorphicMenuItemAdapter>>performMenuActionWith:
	Receiver: a SpMorphicMenuItemAdapter
	Arguments and temporary variables: 
		arguments: 	a SpMorphicMenuItemAdapter
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	nil
		model: 	a SpMenuItemPresenter
		widget: 	a SpToggleMenuItemMorph(499177728)'Inspect it'
		selector: 	nil
		owner: 	a SpMenuItemPresenter


[ | selArgCount |  "show cursor in case item opens a new MVC window"
		(selArgCount := selector numArgs) = 0
			ifTrue:
				[target perform: selector]
			ifFalse:
				[selArgCount = arguments size
					ifTrue: [target perform: selector withArguments: arguments]
					ifFalse: [target perform: selector withArguments: (arguments copyWith: evt)]].
		self showShortcut.
		self changed] in SpToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
	Receiver: a SpToggleMenuItemMorph(499177728)'Inspect it'
	Arguments and temporary variables: 
		evt: 	[(663@377) mouseUp 3193838 nil]
		w: 	a WorldMorph(603310592) [world]
		selArgCount: 	1
	Receiver's instance variables: 
		bounds: 	(601.0@372.0) corner: (723.0@390.0)
		owner: 	a MenuMorph(665071104)
		submorphs: 	#()
		fullBounds: 	(601.0@372.0) corner: (723.0@390.0)
		color: 	Color white
		extension: 	a MorphExtension (984295680) [balloonText]  [other:  (kmDispatcher -...etc...
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Inspect it'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a SpMorphicMenuItemAdapter
		selector: 	#performMenuActionWith:
		arguments: 	an Array(a SpMorphicMenuItemAdapter)
		icon: 	Form(16x16x32)
		keyText: 	'⌘I'
		getStateSelector: 	nil
		enablementSelector: 	#enabled


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ | selArgCount |  "show cursor in case item opens a new MVC window"
		(selArgCount := sel...etc...
	Arguments and temporary variables: 
		aBlock: 	[oldcursor show]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
		startpc: 	a CompiledBlock: [ | selArgCount |  "show cursor in case item opens a ...etc...
		numArgs: 	0
		receiver: 	a SpToggleMenuItemMorph(499177728)'Inspect it'


CursorWithMask(Cursor)>>showWhile:
	Receiver: ((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0
		2r100000000000000000000...etc...
	Arguments and temporary variables: 
		aBlock: 	[ | selArgCount |  "show cursor in case item opens a new MVC window"
		...etc...
		oldcursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0
		2...etc...
	Receiver's instance variables: 
		bits: 	a Bitmap of length 16
		width: 	16
		height: 	16
		depth: 	1
		offset: 	(-1@ -1)
		maskForm: 	Form(16x16x1)


SpToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
	Receiver: a SpToggleMenuItemMorph(499177728)'Inspect it'
	Arguments and temporary variables: 
		evt: 	[(663@377) mouseUp 3193838 nil]
		w: 	a WorldMorph(603310592) [world]
	Receiver's instance variables: 
		bounds: 	(601.0@372.0) corner: (723.0@390.0)
		owner: 	a MenuMorph(665071104)
		submorphs: 	#()
		fullBounds: 	(601.0@372.0) corner: (723.0@390.0)
		color: 	Color white
		extension: 	a MorphExtension (984295680) [balloonText]  [other:  (kmDispatcher -...etc...
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Inspect it'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a SpMorphicMenuItemAdapter
		selector: 	#performMenuActionWith:
		arguments: 	an Array(a SpMorphicMenuItemAdapter)
		icon: 	Form(16x16x32)
		keyText: 	'⌘I'
		getStateSelector: 	nil
		enablementSelector: 	#enabled


SpToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
	Receiver: a SpToggleMenuItemMorph(499177728)'Inspect it'
	Arguments and temporary variables: 
		evt: 	[(663@377) mouseUp 3193838 nil]
	Receiver's instance variables: 
		bounds: 	(601.0@372.0) corner: (723.0@390.0)
		owner: 	a MenuMorph(665071104)
		submorphs: 	#()
		fullBounds: 	(601.0@372.0) corner: (723.0@390.0)
		color: 	Color white
		extension: 	a MorphExtension (984295680) [balloonText]  [other:  (kmDispatcher -...etc...
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Inspect it'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a SpMorphicMenuItemAdapter
		selector: 	#performMenuActionWith:
		arguments: 	an Array(a SpMorphicMenuItemAdapter)
		icon: 	Form(16x16x32)
		keyText: 	'⌘I'
		getStateSelector: 	nil
		enablementSelector: 	#enabled


SpToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
	Receiver: a SpToggleMenuItemMorph(499177728)'Inspect it'
	Arguments and temporary variables: 
		anEvent: 	[(663@377) mouseUp 3193838 nil]
	Receiver's instance variables: 
		bounds: 	(601.0@372.0) corner: (723.0@390.0)
		owner: 	a MenuMorph(665071104)
		submorphs: 	#()
		fullBounds: 	(601.0@372.0) corner: (723.0@390.0)
		color: 	Color white
		extension: 	a MorphExtension (984295680) [balloonText]  [other:  (kmDispatcher -...etc...
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Inspect it'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a SpMorphicMenuItemAdapter
		selector: 	#performMenuActionWith:
		arguments: 	an Array(a SpMorphicMenuItemAdapter)
		icon: 	Form(16x16x32)
		keyText: 	'⌘I'
		getStateSelector: 	nil
		enablementSelector: 	#enabled


MouseButtonEvent>>sentTo:
	Receiver: [(663@377) mouseUp 3193838 nil]
	Arguments and temporary variables: 
		anObject: 	a SpToggleMenuItemMorph(499177728)'Inspect it'
	Receiver's instance variables: 
		timeStamp: 	3193838
		source: 	a HandMorph(986102528)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(663@377)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


SpToggleMenuItemMorph(Morph)>>handleEvent:
	Receiver: a SpToggleMenuItemMorph(499177728)'Inspect it'
	Arguments and temporary variables: 
		anEvent: 	[(663@377) mouseUp 3193838 nil]
	Receiver's instance variables: 
		bounds: 	(601.0@372.0) corner: (723.0@390.0)
		owner: 	a MenuMorph(665071104)
		submorphs: 	#()
		fullBounds: 	(601.0@372.0) corner: (723.0@390.0)
		color: 	Color white
		extension: 	a MorphExtension (984295680) [balloonText]  [other:  (kmDispatcher -...etc...
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Inspect it'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a SpMorphicMenuItemAdapter
		selector: 	#performMenuActionWith:
		arguments: 	an Array(a SpMorphicMenuItemAdapter)
		icon: 	Form(16x16x32)
		keyText: 	'⌘I'
		getStateSelector: 	nil
		enablementSelector: 	#enabled


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(663@377) mouseUp 3193838 nil]
		aMorph: 	a SpToggleMenuItemMorph(499177728)'Inspect it'
		localEvt: 	nil
		index: 	1
		child: 	nil
		morphs: 	#()
		inside: 	true
	Receiver's instance variables: 
		morph: 	a SpToggleMenuItemMorph(499177728)'Inspect it'


MorphicEventDispatcher>>handleMouseUp:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(663@377) mouseUp 3193838 nil]
	Receiver's instance variables: 
		morph: 	a SpToggleMenuItemMorph(499177728)'Inspect it'



--- The full stack ---
Pile class(Object)>>doesNotUnderstand: #initialize:
Pile class>>new:
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeInspectItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeInspectItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeInspectItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ aCommand execute ] in SpMenuPresenterBuilder>>fillItem:with:
FullBlockClosure(BlockClosure)>>cull:
SpMenuItemPresenter>>performMenuActionWith:
SpMorphicMenuItemAdapter>>performMenuActionWith:
[ | selArgCount |  "show cursor in case item opens a new MVC window"
		(selArgCount := selector numArgs) = 0
			ifTrue:
				[target perform: selector]
			ifFalse:
				[selArgCount = arguments size
					ifTrue: [target perform: selector withArguments: arguments]
					ifFalse: [target perform: selector withArguments: (arguments copyWith: evt)]].
		self showShortcut.
		self changed] in SpToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
SpToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
SpToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
SpToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
SpToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
SpToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MenuMorph(Morph)>>processEvent:using:
MenuMorph(Morph)>>processEvent:
MenuMorph>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
MenuMorph>>invokeAt:in:allowKeyboard:
MenuMorph>>invokeAt:in:
MenuMorph>>invokeModal
RubEditingArea(RubAbstractTextArea)>>yellowButtonActivity:
RubEditingArea(RubAbstractTextArea)>>mouseDown:
RubEditingArea(Morph)>>handleMouseDown:
MouseButtonEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
RubEditingArea(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
TransformWithLayoutMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
RubTextScrollPane(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
SpRubScrolledTextMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
Morph>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
Morph>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
Morph>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
TransformWithLayoutMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MillerScrollPane(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
Morph>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
Morph>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
Morph>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
Morph>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
Morph>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
SpWindow(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
-- and more not shown ---------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of Object class did not understand #initialize:
26 September 2022 7:12:12.894609 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
StackToRegisterMappingCogit * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
v9.0.18 - Commit: 7249c170 - Date: 2022-09-02 14:31:12 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

Pile class(Object)>>doesNotUnderstand: #initialize:
	Receiver: Pile
	Arguments and temporary variables: 
		aMessage: 	initialize: nil
		exception: 	Instance of Object class did not understand #initialize:
		resumeValue: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#grow->Pile>>#grow #initialize:->Pile>>#initiali...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#Pile
		classPool: 	a Dictionary(#tailleDefaut->nil )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#HAI914I


Pile class>>new:
	Receiver: Pile
	Arguments and temporary variables: 
		taille: 	4
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#grow->Pile>>#grow #initialize:->Pile>>#initiali...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#Pile
		classPool: 	a Dictionary(#tailleDefaut->nil )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#HAI914I


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ p := Pile new: 4
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ p := Pile new: 4
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'p:= Pile new: 4.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 16) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'p:= Pile new: 4.' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'p:= Pile new: 4.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 16) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'p:= Pile new: 4.' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodeInspectItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodeInspectItCommand
	Arguments and temporary variables: 
		aString: 	'p:= Pile new: 4.'
		aBlock: 	[ :result | 
		self inspectObject: result ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Inspect it'
		basicDescription: 	'Evaluate selection and inspect the result.'
		transform: 	[ :aContext | aContext ]


SpCodeInspectItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodeInspectItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
		self inspectObject: result ]
		selection: 	'p:= Pile new: 4.'
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Inspect it'
		basicDescription: 	'Evaluate selection and inspect the result.'
		transform: 	[ :aContext | aContext ]


SpCodeInspectItCommand>>execute
	Receiver: a SpCodeInspectItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Inspect it'
		basicDescription: 	'Evaluate selection and inspect the result.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Inspect it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodeInspectItCommand
		iconProvider: 	a ThemeIcons(idea11)
		iconName: 	#smallInspectIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Inspect it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Inspect it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ aCommand execute ] in SpMenuPresenterBuilder>>fillItem:with:
	Receiver: a SpMenuPresenterBuilder
	Arguments and temporary variables: 
		aMenuItem: 	a SpMenuItemPresenter
		aCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		menuPresenter: 	a SpMenuPresenter
		stack: 	a Stack(a SpMenuPresenter)


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ aCommand execute ]
	Arguments and temporary variables: 
		anArg: 	a SpMorphicMenuItemAdapter
	Receiver's instance variables: 
		outerContext: 	SpMenuPresenterBuilder>>fillItem:with:
		startpc: 	a CompiledBlock: [ aCommand execute ]
		numArgs: 	0
		receiver: 	a SpMenuPresenterBuilder


SpMenuItemPresenter>>performMenuActionWith:
	Receiver: a SpMenuItemPresenter
	Arguments and temporary variables: 
		aMenuItem: 	a SpMorphicMenuItemAdapter
		en: 	true
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicMenuItemAdapter)
		announcer: 	an Announcer
		owner: 	a SpMenuGroupPresenter
		adapter: 	a SpMorphicMenuItemAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		name: 	an ObservableValueHolder[ 'Inspect it' ]
		icon: 	an ObservableValueHolder[ Form(16x16x32) ]
		description: 	an ObservableValueHolder[ 'Evaluate selection and inspect the resu...etc...
		action: 	[ aCommand execute ]
		shortcut: 	a KMKeyCombinationChoice
		subMenu: 	nil
		state: 	nil
		autoRefresh: 	false


SpMorphicMenuItemAdapter>>performMenuActionWith:
	Receiver: a SpMorphicMenuItemAdapter
	Arguments and temporary variables: 
		arguments: 	a SpMorphicMenuItemAdapter
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	nil
		model: 	a SpMenuItemPresenter
		widget: 	a SpToggleMenuItemMorph(499177728)'Inspect it'
		selector: 	nil
		owner: 	a SpMenuItemPresenter


[ | selArgCount |  "show cursor in case item opens a new MVC window"
		(selArgCount := selector numArgs) = 0
			ifTrue:
				[target perform: selector]
			ifFalse:
				[selArgCount = arguments size
					ifTrue: [target perform: selector withArguments: arguments]
					ifFalse: [target perform: selector withArguments: (arguments copyWith: evt)]].
		self showShortcut.
		self changed] in SpToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
	Receiver: a SpToggleMenuItemMorph(499177728)'Inspect it'
	Arguments and temporary variables: 
		evt: 	[(663@377) mouseUp 3193838 nil]
		w: 	a WorldMorph(603310592) [world]
		selArgCount: 	1
	Receiver's instance variables: 
		bounds: 	(601.0@372.0) corner: (723.0@390.0)
		owner: 	a MenuMorph(665071104)
		submorphs: 	#()
		fullBounds: 	(601.0@372.0) corner: (723.0@390.0)
		color: 	Color white
		extension: 	a MorphExtension (984295680) [balloonText]  [other:  (kmDispatcher -...etc...
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Inspect it'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a SpMorphicMenuItemAdapter
		selector: 	#performMenuActionWith:
		arguments: 	an Array(a SpMorphicMenuItemAdapter)
		icon: 	Form(16x16x32)
		keyText: 	'⌘I'
		getStateSelector: 	nil
		enablementSelector: 	#enabled


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ | selArgCount |  "show cursor in case item opens a new MVC window"
		(selArgCount := sel...etc...
	Arguments and temporary variables: 
		aBlock: 	[oldcursor show]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
		startpc: 	a CompiledBlock: [ | selArgCount |  "show cursor in case item opens a ...etc...
		numArgs: 	0
		receiver: 	a SpToggleMenuItemMorph(499177728)'Inspect it'


CursorWithMask(Cursor)>>showWhile:
	Receiver: ((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0
		2r100000000000000000000...etc...
	Arguments and temporary variables: 
		aBlock: 	[ | selArgCount |  "show cursor in case item opens a new MVC window"
		...etc...
		oldcursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0
		2...etc...
	Receiver's instance variables: 
		bits: 	a Bitmap of length 16
		width: 	16
		height: 	16
		depth: 	1
		offset: 	(-1@ -1)
		maskForm: 	Form(16x16x1)


SpToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
	Receiver: a SpToggleMenuItemMorph(499177728)'Inspect it'
	Arguments and temporary variables: 
		evt: 	[(663@377) mouseUp 3193838 nil]
		w: 	a WorldMorph(603310592) [world]
	Receiver's instance variables: 
		bounds: 	(601.0@372.0) corner: (723.0@390.0)
		owner: 	a MenuMorph(665071104)
		submorphs: 	#()
		fullBounds: 	(601.0@372.0) corner: (723.0@390.0)
		color: 	Color white
		extension: 	a MorphExtension (984295680) [balloonText]  [other:  (kmDispatcher -...etc...
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Inspect it'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a SpMorphicMenuItemAdapter
		selector: 	#performMenuActionWith:
		arguments: 	an Array(a SpMorphicMenuItemAdapter)
		icon: 	Form(16x16x32)
		keyText: 	'⌘I'
		getStateSelector: 	nil
		enablementSelector: 	#enabled


SpToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
	Receiver: a SpToggleMenuItemMorph(499177728)'Inspect it'
	Arguments and temporary variables: 
		evt: 	[(663@377) mouseUp 3193838 nil]
	Receiver's instance variables: 
		bounds: 	(601.0@372.0) corner: (723.0@390.0)
		owner: 	a MenuMorph(665071104)
		submorphs: 	#()
		fullBounds: 	(601.0@372.0) corner: (723.0@390.0)
		color: 	Color white
		extension: 	a MorphExtension (984295680) [balloonText]  [other:  (kmDispatcher -...etc...
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Inspect it'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a SpMorphicMenuItemAdapter
		selector: 	#performMenuActionWith:
		arguments: 	an Array(a SpMorphicMenuItemAdapter)
		icon: 	Form(16x16x32)
		keyText: 	'⌘I'
		getStateSelector: 	nil
		enablementSelector: 	#enabled


SpToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
	Receiver: a SpToggleMenuItemMorph(499177728)'Inspect it'
	Arguments and temporary variables: 
		anEvent: 	[(663@377) mouseUp 3193838 nil]
	Receiver's instance variables: 
		bounds: 	(601.0@372.0) corner: (723.0@390.0)
		owner: 	a MenuMorph(665071104)
		submorphs: 	#()
		fullBounds: 	(601.0@372.0) corner: (723.0@390.0)
		color: 	Color white
		extension: 	a MorphExtension (984295680) [balloonText]  [other:  (kmDispatcher -...etc...
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Inspect it'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a SpMorphicMenuItemAdapter
		selector: 	#performMenuActionWith:
		arguments: 	an Array(a SpMorphicMenuItemAdapter)
		icon: 	Form(16x16x32)
		keyText: 	'⌘I'
		getStateSelector: 	nil
		enablementSelector: 	#enabled


MouseButtonEvent>>sentTo:
	Receiver: [(663@377) mouseUp 3193838 nil]
	Arguments and temporary variables: 
		anObject: 	a SpToggleMenuItemMorph(499177728)'Inspect it'
	Receiver's instance variables: 
		timeStamp: 	3193838
		source: 	a HandMorph(986102528)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(663@377)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


SpToggleMenuItemMorph(Morph)>>handleEvent:
	Receiver: a SpToggleMenuItemMorph(499177728)'Inspect it'
	Arguments and temporary variables: 
		anEvent: 	[(663@377) mouseUp 3193838 nil]
	Receiver's instance variables: 
		bounds: 	(601.0@372.0) corner: (723.0@390.0)
		owner: 	a MenuMorph(665071104)
		submorphs: 	#()
		fullBounds: 	(601.0@372.0) corner: (723.0@390.0)
		color: 	Color white
		extension: 	a MorphExtension (984295680) [balloonText]  [other:  (kmDispatcher -...etc...
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Inspect it'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a SpMorphicMenuItemAdapter
		selector: 	#performMenuActionWith:
		arguments: 	an Array(a SpMorphicMenuItemAdapter)
		icon: 	Form(16x16x32)
		keyText: 	'⌘I'
		getStateSelector: 	nil
		enablementSelector: 	#enabled


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(663@377) mouseUp 3193838 nil]
		aMorph: 	a SpToggleMenuItemMorph(499177728)'Inspect it'
		localEvt: 	nil
		index: 	1
		child: 	nil
		morphs: 	#()
		inside: 	true
	Receiver's instance variables: 
		morph: 	a SpToggleMenuItemMorph(499177728)'Inspect it'


MorphicEventDispatcher>>handleMouseUp:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(663@377) mouseUp 3193838 nil]
	Receiver's instance variables: 
		morph: 	a SpToggleMenuItemMorph(499177728)'Inspect it'



--- The full stack ---
Pile class(Object)>>doesNotUnderstand: #initialize:
Pile class>>new:
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeInspectItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeInspectItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeInspectItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ aCommand execute ] in SpMenuPresenterBuilder>>fillItem:with:
FullBlockClosure(BlockClosure)>>cull:
SpMenuItemPresenter>>performMenuActionWith:
SpMorphicMenuItemAdapter>>performMenuActionWith:
[ | selArgCount |  "show cursor in case item opens a new MVC window"
		(selArgCount := selector numArgs) = 0
			ifTrue:
				[target perform: selector]
			ifFalse:
				[selArgCount = arguments size
					ifTrue: [target perform: selector withArguments: arguments]
					ifFalse: [target perform: selector withArguments: (arguments copyWith: evt)]].
		self showShortcut.
		self changed] in SpToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
SpToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
SpToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
SpToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
SpToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
SpToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MenuMorph(Morph)>>processEvent:using:
MenuMorph(Morph)>>processEvent:
MenuMorph>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
MenuMorph>>invokeAt:in:allowKeyboard:
MenuMorph>>invokeAt:in:
MenuMorph>>invokeModal
RubEditingArea(RubAbstractTextArea)>>yellowButtonActivity:
RubEditingArea(RubAbstractTextArea)>>mouseDown:
RubEditingArea(Morph)>>handleMouseDown:
MouseButtonEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
RubEditingArea(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
TransformWithLayoutMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
RubTextScrollPane(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
SpRubScrolledTextMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
Morph>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
Morph>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
Morph>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
TransformWithLayoutMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MillerScrollPane(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
Morph>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
Morph>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
Morph>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
Morph>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
Morph>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
SpWindow(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
-- and more not shown ---------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of Object class did not understand #initialize:
26 September 2022 7:12:45.526029 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
StackToRegisterMappingCogit * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
v9.0.18 - Commit: 7249c170 - Date: 2022-09-02 14:31:12 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

Pile class(Object)>>doesNotUnderstand: #initialize:
	Receiver: Pile
	Arguments and temporary variables: 
		aMessage: 	initialize: nil
		exception: 	Instance of Object class did not understand #initialize:
		resumeValue: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#grow->Pile>>#grow #initialize:->Pile>>#initiali...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#Pile
		classPool: 	a Dictionary(#tailleDefaut->nil )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#HAI914I


Pile class>>new:
	Receiver: Pile
	Arguments and temporary variables: 
		taille: 	4
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#grow->Pile>>#grow #initialize:->Pile>>#initiali...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#Pile
		classPool: 	a Dictionary(#tailleDefaut->nil )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#HAI914I


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ p := Pile new: 4
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ p := Pile new: 4
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'p:= Pile new: 4.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#p->nil )
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 16) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'p:= Pile new: 4.' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#p->nil )
		aString: 	'p:= Pile new: 4.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 16) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'p:= Pile new: 4.' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aString: 	'p:= Pile new: 4.'
		aBlock: 	[ :result | ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | ]
		selection: 	'p:= Pile new: 4.'
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand>>execute
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodeDoItCommand
		iconProvider: 	a ThemeIcons(idea11)
		iconName: 	#smallDoIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ aCommand execute ] in SpMenuPresenterBuilder>>fillItem:with:
	Receiver: a SpMenuPresenterBuilder
	Arguments and temporary variables: 
		aMenuItem: 	a SpMenuItemPresenter
		aCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		menuPresenter: 	a SpMenuPresenter
		stack: 	a Stack(a SpMenuPresenter)


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ aCommand execute ]
	Arguments and temporary variables: 
		anArg: 	a SpMorphicMenuItemAdapter
	Receiver's instance variables: 
		outerContext: 	SpMenuPresenterBuilder>>fillItem:with:
		startpc: 	a CompiledBlock: [ aCommand execute ]
		numArgs: 	0
		receiver: 	a SpMenuPresenterBuilder


SpMenuItemPresenter>>performMenuActionWith:
	Receiver: a SpMenuItemPresenter
	Arguments and temporary variables: 
		aMenuItem: 	a SpMorphicMenuItemAdapter
		en: 	true
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicMenuItemAdapter)
		announcer: 	an Announcer
		owner: 	a SpMenuGroupPresenter
		adapter: 	a SpMorphicMenuItemAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		name: 	an ObservableValueHolder[ 'Do it' ]
		icon: 	an ObservableValueHolder[ Form(13x13x32) ]
		description: 	an ObservableValueHolder[ 'Evaluate selection.' ]
		action: 	[ aCommand execute ]
		shortcut: 	a KMKeyCombinationChoice
		subMenu: 	nil
		state: 	nil
		autoRefresh: 	false


SpMorphicMenuItemAdapter>>performMenuActionWith:
	Receiver: a SpMorphicMenuItemAdapter
	Arguments and temporary variables: 
		arguments: 	a SpMorphicMenuItemAdapter
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	nil
		model: 	a SpMenuItemPresenter
		widget: 	a SpToggleMenuItemMorph(1007108864)'Do it'
		selector: 	nil
		owner: 	a SpMenuItemPresenter


[ | selArgCount |  "show cursor in case item opens a new MVC window"
		(selArgCount := selector numArgs) = 0
			ifTrue:
				[target perform: selector]
			ifFalse:
				[selArgCount = arguments size
					ifTrue: [target perform: selector withArguments: arguments]
					ifFalse: [target perform: selector withArguments: (arguments copyWith: evt)]].
		self showShortcut.
		self changed] in SpToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
	Receiver: a SpToggleMenuItemMorph(1007108864)'Do it'
	Arguments and temporary variables: 
		evt: 	[(625@344) mouseUp 3226529 nil]
		w: 	a WorldMorph(603310592) [world]
		selArgCount: 	1
	Receiver's instance variables: 
		bounds: 	(601.0@336.0) corner: (723.0@353.0)
		owner: 	a MenuMorph(242376960)
		submorphs: 	#()
		fullBounds: 	(601.0@336.0) corner: (723.0@353.0)
		color: 	Color white
		extension: 	a MorphExtension (911430656) [balloonText]  [other:  (kmDispatcher -...etc...
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Do it'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a SpMorphicMenuItemAdapter
		selector: 	#performMenuActionWith:
		arguments: 	an Array(a SpMorphicMenuItemAdapter)
		icon: 	Form(13x13x32)
		keyText: 	'⌘D'
		getStateSelector: 	nil
		enablementSelector: 	#enabled


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ | selArgCount |  "show cursor in case item opens a new MVC window"
		(selArgCount := sel...etc...
	Arguments and temporary variables: 
		aBlock: 	[oldcursor show]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
		startpc: 	a CompiledBlock: [ | selArgCount |  "show cursor in case item opens a ...etc...
		numArgs: 	0
		receiver: 	a SpToggleMenuItemMorph(1007108864)'Do it'


CursorWithMask(Cursor)>>showWhile:
	Receiver: ((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0
		2r100000000000000000000...etc...
	Arguments and temporary variables: 
		aBlock: 	[ | selArgCount |  "show cursor in case item opens a new MVC window"
		...etc...
		oldcursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0
		2...etc...
	Receiver's instance variables: 
		bits: 	a Bitmap of length 16
		width: 	16
		height: 	16
		depth: 	1
		offset: 	(-1@ -1)
		maskForm: 	Form(16x16x1)


SpToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
	Receiver: a SpToggleMenuItemMorph(1007108864)'Do it'
	Arguments and temporary variables: 
		evt: 	[(625@344) mouseUp 3226529 nil]
		w: 	a WorldMorph(603310592) [world]
	Receiver's instance variables: 
		bounds: 	(601.0@336.0) corner: (723.0@353.0)
		owner: 	a MenuMorph(242376960)
		submorphs: 	#()
		fullBounds: 	(601.0@336.0) corner: (723.0@353.0)
		color: 	Color white
		extension: 	a MorphExtension (911430656) [balloonText]  [other:  (kmDispatcher -...etc...
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Do it'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a SpMorphicMenuItemAdapter
		selector: 	#performMenuActionWith:
		arguments: 	an Array(a SpMorphicMenuItemAdapter)
		icon: 	Form(13x13x32)
		keyText: 	'⌘D'
		getStateSelector: 	nil
		enablementSelector: 	#enabled


SpToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
	Receiver: a SpToggleMenuItemMorph(1007108864)'Do it'
	Arguments and temporary variables: 
		evt: 	[(625@344) mouseUp 3226529 nil]
	Receiver's instance variables: 
		bounds: 	(601.0@336.0) corner: (723.0@353.0)
		owner: 	a MenuMorph(242376960)
		submorphs: 	#()
		fullBounds: 	(601.0@336.0) corner: (723.0@353.0)
		color: 	Color white
		extension: 	a MorphExtension (911430656) [balloonText]  [other:  (kmDispatcher -...etc...
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Do it'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a SpMorphicMenuItemAdapter
		selector: 	#performMenuActionWith:
		arguments: 	an Array(a SpMorphicMenuItemAdapter)
		icon: 	Form(13x13x32)
		keyText: 	'⌘D'
		getStateSelector: 	nil
		enablementSelector: 	#enabled


SpToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
	Receiver: a SpToggleMenuItemMorph(1007108864)'Do it'
	Arguments and temporary variables: 
		anEvent: 	[(625@344) mouseUp 3226529 nil]
	Receiver's instance variables: 
		bounds: 	(601.0@336.0) corner: (723.0@353.0)
		owner: 	a MenuMorph(242376960)
		submorphs: 	#()
		fullBounds: 	(601.0@336.0) corner: (723.0@353.0)
		color: 	Color white
		extension: 	a MorphExtension (911430656) [balloonText]  [other:  (kmDispatcher -...etc...
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Do it'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a SpMorphicMenuItemAdapter
		selector: 	#performMenuActionWith:
		arguments: 	an Array(a SpMorphicMenuItemAdapter)
		icon: 	Form(13x13x32)
		keyText: 	'⌘D'
		getStateSelector: 	nil
		enablementSelector: 	#enabled


MouseButtonEvent>>sentTo:
	Receiver: [(625@344) mouseUp 3226529 nil]
	Arguments and temporary variables: 
		anObject: 	a SpToggleMenuItemMorph(1007108864)'Do it'
	Receiver's instance variables: 
		timeStamp: 	3226529
		source: 	a HandMorph(986102528)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(625@344)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


SpToggleMenuItemMorph(Morph)>>handleEvent:
	Receiver: a SpToggleMenuItemMorph(1007108864)'Do it'
	Arguments and temporary variables: 
		anEvent: 	[(625@344) mouseUp 3226529 nil]
	Receiver's instance variables: 
		bounds: 	(601.0@336.0) corner: (723.0@353.0)
		owner: 	a MenuMorph(242376960)
		submorphs: 	#()
		fullBounds: 	(601.0@336.0) corner: (723.0@353.0)
		color: 	Color white
		extension: 	a MorphExtension (911430656) [balloonText]  [other:  (kmDispatcher -...etc...
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Do it'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a SpMorphicMenuItemAdapter
		selector: 	#performMenuActionWith:
		arguments: 	an Array(a SpMorphicMenuItemAdapter)
		icon: 	Form(13x13x32)
		keyText: 	'⌘D'
		getStateSelector: 	nil
		enablementSelector: 	#enabled


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(625@344) mouseUp 3226529 nil]
		aMorph: 	a SpToggleMenuItemMorph(1007108864)'Do it'
		localEvt: 	nil
		index: 	1
		child: 	nil
		morphs: 	#()
		inside: 	true
	Receiver's instance variables: 
		morph: 	a SpToggleMenuItemMorph(1007108864)'Do it'


MorphicEventDispatcher>>handleMouseUp:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(625@344) mouseUp 3226529 nil]
	Receiver's instance variables: 
		morph: 	a SpToggleMenuItemMorph(1007108864)'Do it'



--- The full stack ---
Pile class(Object)>>doesNotUnderstand: #initialize:
Pile class>>new:
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ aCommand execute ] in SpMenuPresenterBuilder>>fillItem:with:
FullBlockClosure(BlockClosure)>>cull:
SpMenuItemPresenter>>performMenuActionWith:
SpMorphicMenuItemAdapter>>performMenuActionWith:
[ | selArgCount |  "show cursor in case item opens a new MVC window"
		(selArgCount := selector numArgs) = 0
			ifTrue:
				[target perform: selector]
			ifFalse:
				[selArgCount = arguments size
					ifTrue: [target perform: selector withArguments: arguments]
					ifFalse: [target perform: selector withArguments: (arguments copyWith: evt)]].
		self showShortcut.
		self changed] in SpToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
SpToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
SpToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
SpToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
SpToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
SpToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MenuMorph(Morph)>>processEvent:using:
MenuMorph(Morph)>>processEvent:
MenuMorph>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
MenuMorph>>invokeAt:in:allowKeyboard:
MenuMorph>>invokeAt:in:
MenuMorph>>invokeModal
RubEditingArea(RubAbstractTextArea)>>yellowButtonActivity:
RubEditingArea(RubAbstractTextArea)>>mouseDown:
RubEditingArea(Morph)>>handleMouseDown:
MouseButtonEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
RubEditingArea(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
TransformWithLayoutMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
RubTextScrollPane(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
SpRubScrolledTextMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
Morph>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
Morph>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
Morph>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
TransformWithLayoutMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MillerScrollPane(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
Morph>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
Morph>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
Morph>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
Morph>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
Morph>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
SpWindow(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
-- and more not shown ---------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of Object class did not understand #initialize:
26 September 2022 7:12:45.552082 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
StackToRegisterMappingCogit * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
v9.0.18 - Commit: 7249c170 - Date: 2022-09-02 14:31:12 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

Pile class(Object)>>doesNotUnderstand: #initialize:
	Receiver: Pile
	Arguments and temporary variables: 
		aMessage: 	initialize: nil
		exception: 	Instance of Object class did not understand #initialize:
		resumeValue: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#grow->Pile>>#grow #initialize:->Pile>>#initiali...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#Pile
		classPool: 	a Dictionary(#tailleDefaut->nil )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#HAI914I


Pile class>>new:
	Receiver: Pile
	Arguments and temporary variables: 
		taille: 	4
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#grow->Pile>>#grow #initialize:->Pile>>#initiali...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#Pile
		classPool: 	a Dictionary(#tailleDefaut->nil )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#HAI914I


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ p := Pile new: 4
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ p := Pile new: 4
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'p:= Pile new: 4.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#p->nil )
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 16) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'p:= Pile new: 4.' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#p->nil )
		aString: 	'p:= Pile new: 4.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 16) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'p:= Pile new: 4.' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aString: 	'p:= Pile new: 4.'
		aBlock: 	[ :result | ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | ]
		selection: 	'p:= Pile new: 4.'
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand>>execute
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodeDoItCommand
		iconProvider: 	a ThemeIcons(idea11)
		iconName: 	#smallDoIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ aCommand execute ] in SpMenuPresenterBuilder>>fillItem:with:
	Receiver: a SpMenuPresenterBuilder
	Arguments and temporary variables: 
		aMenuItem: 	a SpMenuItemPresenter
		aCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		menuPresenter: 	a SpMenuPresenter
		stack: 	a Stack(a SpMenuPresenter)


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ aCommand execute ]
	Arguments and temporary variables: 
		anArg: 	a SpMorphicMenuItemAdapter
	Receiver's instance variables: 
		outerContext: 	SpMenuPresenterBuilder>>fillItem:with:
		startpc: 	a CompiledBlock: [ aCommand execute ]
		numArgs: 	0
		receiver: 	a SpMenuPresenterBuilder


SpMenuItemPresenter>>performMenuActionWith:
	Receiver: a SpMenuItemPresenter
	Arguments and temporary variables: 
		aMenuItem: 	a SpMorphicMenuItemAdapter
		en: 	true
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicMenuItemAdapter)
		announcer: 	an Announcer
		owner: 	a SpMenuGroupPresenter
		adapter: 	a SpMorphicMenuItemAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		name: 	an ObservableValueHolder[ 'Do it' ]
		icon: 	an ObservableValueHolder[ Form(13x13x32) ]
		description: 	an ObservableValueHolder[ 'Evaluate selection.' ]
		action: 	[ aCommand execute ]
		shortcut: 	a KMKeyCombinationChoice
		subMenu: 	nil
		state: 	nil
		autoRefresh: 	false


SpMorphicMenuItemAdapter>>performMenuActionWith:
	Receiver: a SpMorphicMenuItemAdapter
	Arguments and temporary variables: 
		arguments: 	a SpMorphicMenuItemAdapter
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	nil
		model: 	a SpMenuItemPresenter
		widget: 	a SpToggleMenuItemMorph(1007108864)'Do it'
		selector: 	nil
		owner: 	a SpMenuItemPresenter


[ | selArgCount |  "show cursor in case item opens a new MVC window"
		(selArgCount := selector numArgs) = 0
			ifTrue:
				[target perform: selector]
			ifFalse:
				[selArgCount = arguments size
					ifTrue: [target perform: selector withArguments: arguments]
					ifFalse: [target perform: selector withArguments: (arguments copyWith: evt)]].
		self showShortcut.
		self changed] in SpToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
	Receiver: a SpToggleMenuItemMorph(1007108864)'Do it'
	Arguments and temporary variables: 
		evt: 	[(625@344) mouseUp 3226529 nil]
		w: 	a WorldMorph(603310592) [world]
		selArgCount: 	1
	Receiver's instance variables: 
		bounds: 	(601.0@336.0) corner: (723.0@353.0)
		owner: 	a MenuMorph(242376960)
		submorphs: 	#()
		fullBounds: 	(601.0@336.0) corner: (723.0@353.0)
		color: 	Color white
		extension: 	a MorphExtension (911430656) [balloonText]  [other:  (kmDispatcher -...etc...
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Do it'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a SpMorphicMenuItemAdapter
		selector: 	#performMenuActionWith:
		arguments: 	an Array(a SpMorphicMenuItemAdapter)
		icon: 	Form(13x13x32)
		keyText: 	'⌘D'
		getStateSelector: 	nil
		enablementSelector: 	#enabled


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ | selArgCount |  "show cursor in case item opens a new MVC window"
		(selArgCount := sel...etc...
	Arguments and temporary variables: 
		aBlock: 	[oldcursor show]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
		startpc: 	a CompiledBlock: [ | selArgCount |  "show cursor in case item opens a ...etc...
		numArgs: 	0
		receiver: 	a SpToggleMenuItemMorph(1007108864)'Do it'


CursorWithMask(Cursor)>>showWhile:
	Receiver: ((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0
		2r100000000000000000000...etc...
	Arguments and temporary variables: 
		aBlock: 	[ | selArgCount |  "show cursor in case item opens a new MVC window"
		...etc...
		oldcursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0
		2...etc...
	Receiver's instance variables: 
		bits: 	a Bitmap of length 16
		width: 	16
		height: 	16
		depth: 	1
		offset: 	(-1@ -1)
		maskForm: 	Form(16x16x1)


SpToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
	Receiver: a SpToggleMenuItemMorph(1007108864)'Do it'
	Arguments and temporary variables: 
		evt: 	[(625@344) mouseUp 3226529 nil]
		w: 	a WorldMorph(603310592) [world]
	Receiver's instance variables: 
		bounds: 	(601.0@336.0) corner: (723.0@353.0)
		owner: 	a MenuMorph(242376960)
		submorphs: 	#()
		fullBounds: 	(601.0@336.0) corner: (723.0@353.0)
		color: 	Color white
		extension: 	a MorphExtension (911430656) [balloonText]  [other:  (kmDispatcher -...etc...
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Do it'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a SpMorphicMenuItemAdapter
		selector: 	#performMenuActionWith:
		arguments: 	an Array(a SpMorphicMenuItemAdapter)
		icon: 	Form(13x13x32)
		keyText: 	'⌘D'
		getStateSelector: 	nil
		enablementSelector: 	#enabled


SpToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
	Receiver: a SpToggleMenuItemMorph(1007108864)'Do it'
	Arguments and temporary variables: 
		evt: 	[(625@344) mouseUp 3226529 nil]
	Receiver's instance variables: 
		bounds: 	(601.0@336.0) corner: (723.0@353.0)
		owner: 	a MenuMorph(242376960)
		submorphs: 	#()
		fullBounds: 	(601.0@336.0) corner: (723.0@353.0)
		color: 	Color white
		extension: 	a MorphExtension (911430656) [balloonText]  [other:  (kmDispatcher -...etc...
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Do it'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a SpMorphicMenuItemAdapter
		selector: 	#performMenuActionWith:
		arguments: 	an Array(a SpMorphicMenuItemAdapter)
		icon: 	Form(13x13x32)
		keyText: 	'⌘D'
		getStateSelector: 	nil
		enablementSelector: 	#enabled


SpToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
	Receiver: a SpToggleMenuItemMorph(1007108864)'Do it'
	Arguments and temporary variables: 
		anEvent: 	[(625@344) mouseUp 3226529 nil]
	Receiver's instance variables: 
		bounds: 	(601.0@336.0) corner: (723.0@353.0)
		owner: 	a MenuMorph(242376960)
		submorphs: 	#()
		fullBounds: 	(601.0@336.0) corner: (723.0@353.0)
		color: 	Color white
		extension: 	a MorphExtension (911430656) [balloonText]  [other:  (kmDispatcher -...etc...
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Do it'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a SpMorphicMenuItemAdapter
		selector: 	#performMenuActionWith:
		arguments: 	an Array(a SpMorphicMenuItemAdapter)
		icon: 	Form(13x13x32)
		keyText: 	'⌘D'
		getStateSelector: 	nil
		enablementSelector: 	#enabled


MouseButtonEvent>>sentTo:
	Receiver: [(625@344) mouseUp 3226529 nil]
	Arguments and temporary variables: 
		anObject: 	a SpToggleMenuItemMorph(1007108864)'Do it'
	Receiver's instance variables: 
		timeStamp: 	3226529
		source: 	a HandMorph(986102528)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(625@344)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


SpToggleMenuItemMorph(Morph)>>handleEvent:
	Receiver: a SpToggleMenuItemMorph(1007108864)'Do it'
	Arguments and temporary variables: 
		anEvent: 	[(625@344) mouseUp 3226529 nil]
	Receiver's instance variables: 
		bounds: 	(601.0@336.0) corner: (723.0@353.0)
		owner: 	a MenuMorph(242376960)
		submorphs: 	#()
		fullBounds: 	(601.0@336.0) corner: (723.0@353.0)
		color: 	Color white
		extension: 	a MorphExtension (911430656) [balloonText]  [other:  (kmDispatcher -...etc...
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Do it'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a SpMorphicMenuItemAdapter
		selector: 	#performMenuActionWith:
		arguments: 	an Array(a SpMorphicMenuItemAdapter)
		icon: 	Form(13x13x32)
		keyText: 	'⌘D'
		getStateSelector: 	nil
		enablementSelector: 	#enabled


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(625@344) mouseUp 3226529 nil]
		aMorph: 	a SpToggleMenuItemMorph(1007108864)'Do it'
		localEvt: 	nil
		index: 	1
		child: 	nil
		morphs: 	#()
		inside: 	true
	Receiver's instance variables: 
		morph: 	a SpToggleMenuItemMorph(1007108864)'Do it'


MorphicEventDispatcher>>handleMouseUp:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(625@344) mouseUp 3226529 nil]
	Receiver's instance variables: 
		morph: 	a SpToggleMenuItemMorph(1007108864)'Do it'



--- The full stack ---
Pile class(Object)>>doesNotUnderstand: #initialize:
Pile class>>new:
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ aCommand execute ] in SpMenuPresenterBuilder>>fillItem:with:
FullBlockClosure(BlockClosure)>>cull:
SpMenuItemPresenter>>performMenuActionWith:
SpMorphicMenuItemAdapter>>performMenuActionWith:
[ | selArgCount |  "show cursor in case item opens a new MVC window"
		(selArgCount := selector numArgs) = 0
			ifTrue:
				[target perform: selector]
			ifFalse:
				[selArgCount = arguments size
					ifTrue: [target perform: selector withArguments: arguments]
					ifFalse: [target perform: selector withArguments: (arguments copyWith: evt)]].
		self showShortcut.
		self changed] in SpToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
SpToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
SpToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
SpToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
SpToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
SpToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MenuMorph(Morph)>>processEvent:using:
MenuMorph(Morph)>>processEvent:
MenuMorph>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
MenuMorph>>invokeAt:in:allowKeyboard:
MenuMorph>>invokeAt:in:
MenuMorph>>invokeModal
RubEditingArea(RubAbstractTextArea)>>yellowButtonActivity:
RubEditingArea(RubAbstractTextArea)>>mouseDown:
RubEditingArea(Morph)>>handleMouseDown:
MouseButtonEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
RubEditingArea(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
TransformWithLayoutMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
RubTextScrollPane(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
SpRubScrolledTextMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
Morph>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
Morph>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
Morph>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
TransformWithLayoutMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MillerScrollPane(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
Morph>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
Morph>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
Morph>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
Morph>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
Morph>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
SpWindow(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
-- and more not shown ---------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
AssertionFailure: Project location must exist!
26 September 2022 7:24:55.865136 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
StackToRegisterMappingCogit * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
v9.0.18 - Commit: 7249c170 - Date: 2022-09-02 14:31:12 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

IceTipLocalRepositoryPanel(Object)>>assert:description:
	Receiver: an IceTipLocalRepositoryPanel
	Arguments and temporary variables: 
		aBlock: 	false
		aStringOrBlock: 	'Project location must exist!'
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	an IceTipRegisterRepositoryDialog
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		projectLocation: 	an IceTipDirectoryPresenter
		remoteLabel: 	nil
		remoteInputText: 	nil
		repository: 	nil


IceTipLocalRepositoryPanel>>validate
	Receiver: an IceTipLocalRepositoryPanel
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	an IceTipRegisterRepositoryDialog
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		projectLocation: 	an IceTipDirectoryPresenter
		remoteLabel: 	nil
		remoteInputText: 	nil
		repository: 	nil


IceTipRegisterRepositoryDialog>>doAccept
	Receiver: an IceTipRegisterRepositoryDialog
	Arguments and temporary variables: 
		newRepository: 	nil
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		owner: 	a SpDialogWindowPresenter
		adapter: 	a SpMorphicPanedAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a SpNullApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpPanedLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		typeList: 	a SpTablePresenter
		type: 	an IceTipLocalRepositoryPanel
		contentPanel: 	an IceTipLocalRepositoryPanel
		types: 	an OrderedCollection(an IceTipNewRepositoryPanel an IceTipLocalRepositor...etc...
		repository: 	nil
		acceptBlock: 	nil


[ self doAccept ] in IceTipRegisterRepositoryDialog(IceTipOptionDialog)>>initializeDialogWindow:
	Receiver: an IceTipRegisterRepositoryDialog
	Arguments and temporary variables: 
		aWindowPresenter: 	a SpDialogWindowPresenter
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		owner: 	a SpDialogWindowPresenter
		adapter: 	a SpMorphicPanedAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a SpNullApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpPanedLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		typeList: 	a SpTablePresenter
		type: 	an IceTipLocalRepositoryPanel
		contentPanel: 	an IceTipLocalRepositoryPanel
		types: 	an OrderedCollection(an IceTipNewRepositoryPanel an IceTipLocalRepositor...etc...
		repository: 	nil
		acceptBlock: 	nil


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ self doAccept ]
	Arguments and temporary variables: 
		anArg: 	a SpDialogWindowPresenter
	Receiver's instance variables: 
		outerContext: 	IceTipRegisterRepositoryDialog(IceTipOptionDialog)>>initializeDia...etc...
		startpc: 	a CompiledBlock: [ self doAccept ]
		numArgs: 	0
		receiver: 	an IceTipRegisterRepositoryDialog


SpDialogWindowPresenter>>triggerOkAction
	Receiver: a SpDialogWindowPresenter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicDialogWindowAdapter a SpDialogWindow(3...etc...
		announcer: 	an Announcer
		owner: 	nil
		adapter: 	a SpMorphicDialogWindowAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a SpNullApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ Form(16x16x32) ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ true ]
		titleHolder: 	an ObservableValueHolder[ 'Import from existing clone' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ nil ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		presenter: 	an ObservableValueHolder[ an IceTipRegisterRepositoryDialog ]
		initialPosition: 	an ObservableValueHolder[ nil ]
		initialExtent: 	an ObservableValueHolder[ (600@300) ]
		isResizeable: 	an ObservableValueHolder[ true ]
		menu: 	an ObservableValueHolder[ nil ]
		centered: 	an ObservableValueHolder[ false ]
		isClosed: 	an ObservableValueHolder[ false ]
		toolbar: 	an ObservableValueHolder[ nil ]
		statusbar: 	an ObservableValueHolder[ nil ]
		window: 	an ObservableValueHolder[ a SpDialogWindow(308885760) named: Import fro...etc...
		decorations: 	an ObservableValueHolder[ true ]
		buttons: 	an OrderedCollection(a SpButtonPresenter a SpButtonPresenter)
		okAction: 	[ self doAccept ]
		cancelAction: 	[ 
		cancelled := true.
		self close ]
		cancelled: 	true
		defaultButton: 	nil


[ :presenter | 
			presenter triggerOkAction.
			presenter close ] in SpAbstractPresenter>>initializeDialogWindow:
	Receiver: an IceTipRegisterRepositoryDialog
	Arguments and temporary variables: 
		aDialogWindowPresenter: 	a SpDialogWindowPresenter
		presenter: 	a SpDialogWindowPresenter
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		owner: 	a SpDialogWindowPresenter
		adapter: 	a SpMorphicPanedAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a SpNullApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpPanedLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		typeList: 	a SpTablePresenter
		type: 	an IceTipLocalRepositoryPanel
		contentPanel: 	an IceTipLocalRepositoryPanel
		types: 	an OrderedCollection(an IceTipNewRepositoryPanel an IceTipLocalRepositor...etc...
		repository: 	nil
		acceptBlock: 	nil


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ :presenter | 
			presenter triggerOkAction.
			presenter close ]
	Arguments and temporary variables: 
		anArg: 	a SpDialogWindowPresenter
	Receiver's instance variables: 
		outerContext: 	IceTipRegisterRepositoryDialog(SpAbstractPresenter)>>initializeDi...etc...
		startpc: 	a CompiledBlock: [ :presenter | 
			presenter triggerOkAction.
			pres...etc...
		numArgs: 	1
		receiver: 	an IceTipRegisterRepositoryDialog


[ aBlock cull: self ] in SpDialogWindowPresenter>>addButton:do:
	Receiver: a SpDialogWindowPresenter
	Arguments and temporary variables: 
		aString: 	'Ok'
		aBlock: 	[ :presenter | 
			presenter triggerOkAction.
			presenter close ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicDialogWindowAdapter a SpDialogWindow(3...etc...
		announcer: 	an Announcer
		owner: 	nil
		adapter: 	a SpMorphicDialogWindowAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a SpNullApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ Form(16x16x32) ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ true ]
		titleHolder: 	an ObservableValueHolder[ 'Import from existing clone' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ nil ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		presenter: 	an ObservableValueHolder[ an IceTipRegisterRepositoryDialog ]
		initialPosition: 	an ObservableValueHolder[ nil ]
		initialExtent: 	an ObservableValueHolder[ (600@300) ]
		isResizeable: 	an ObservableValueHolder[ true ]
		menu: 	an ObservableValueHolder[ nil ]
		centered: 	an ObservableValueHolder[ false ]
		isClosed: 	an ObservableValueHolder[ false ]
		toolbar: 	an ObservableValueHolder[ nil ]
		statusbar: 	an ObservableValueHolder[ nil ]
		window: 	an ObservableValueHolder[ a SpDialogWindow(308885760) named: Import fro...etc...
		decorations: 	an ObservableValueHolder[ true ]
		buttons: 	an OrderedCollection(a SpButtonPresenter a SpButtonPresenter)
		okAction: 	[ self doAccept ]
		cancelAction: 	[ 
		cancelled := true.
		self close ]
		cancelled: 	true
		defaultButton: 	nil


SpButtonPresenter>>performAction
	Receiver: a SpButtonPresenter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicButtonAdapter)
		announcer: 	an Announcer
		owner: 	a SpButtonBarPresenter
		adapter: 	a SpMorphicButtonAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Button' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		icon: 	an ObservableValueHolder[ nil ]
		label: 	an ObservableValueHolder[ 'Ok' ]
		action: 	an ObservableValueHolder[ [ aBlock cull: self ] ]
		actionPerformed: 	an ObservableValueHolder[ nil ]
		askBeforeChanging: 	an ObservableValueHolder[ false ]
		font: 	an ObservableValueHolder[ nil ]
		shortcut: 	an ObservableValueHolder[ nil ]
		state: 	an ObservableValueHolder[ false ]
		contextMenu: 	an ObservableValueHolder[ nil ]


SpMorphicButtonAdapter>>action
	Receiver: a SpMorphicButtonAdapter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a PluggableButtonMorph(335468288))
		announcer: 	nil
		model: 	a SpButtonPresenter
		widget: 	a PluggableButtonMorph(335468288)
		selector: 	nil
		owner: 	a SpButtonPresenter
		subMenuWidget: 	nil
		styleName: 	nil


PluggableButtonMorph>>performAction:
	Receiver: a PluggableButtonMorph(335468288)
	Arguments and temporary variables: 
		event: 	[(816@448) mouseUp 149507 nil]
	Receiver's instance variables: 
		bounds: 	(769.0@436.0) corner: (869.0@466.0)
		owner: 	a PanelMorph(1071747072)
		submorphs: 	an Array(an AlignmentMorph(502232320))
		fullBounds: 	nil
		color: 	(Color r: 0.2903225806451613 g: 0.2883675464320626 b: 0.2883675464320626...etc...
		extension: 	a MorphExtension (169478144) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a SpMorphicButtonAdapter
		label: 	'Ok'
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	#state
		actionSelector: 	#action
		font: 	nil
		getLabelSelector: 	#label
		getMenuSelector: 	#menu:
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		getFontSelector: 	#font
		labelMorph: 	a LabelMorph(236987904)'Ok'
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	false


[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(335468288)
	Arguments and temporary variables: 
		evt: 	[(816@448) mouseUp 149507 nil]
		all: 	an Array(a PluggableButtonMorph(857193472) a PluggableButtonMorph(33546828...etc...
		m: 	a PluggableButtonMorph(335468288)
	Receiver's instance variables: 
		bounds: 	(769.0@436.0) corner: (869.0@466.0)
		owner: 	a PanelMorph(1071747072)
		submorphs: 	an Array(an AlignmentMorph(502232320))
		fullBounds: 	nil
		color: 	(Color r: 0.2903225806451613 g: 0.2883675464320626 b: 0.2883675464320626...etc...
		extension: 	a MorphExtension (169478144) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a SpMorphicButtonAdapter
		label: 	'Ok'
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	#state
		actionSelector: 	#action
		font: 	nil
		getLabelSelector: 	#label
		getMenuSelector: 	#menu:
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		getFontSelector: 	#font
		labelMorph: 	a LabelMorph(236987904)'Ok'
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	false


Array(SequenceableCollection)>>do:
	Receiver: an Array(a PluggableButtonMorph(857193472) a PluggableButtonMorph(335468288))
	Arguments and temporary variables: 
		aBlock: 	[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [...etc...
		index: 	2
	Receiver's instance variables: 
an Array(a PluggableButtonMorph(857193472) a PluggableButtonMorph(335468288))

PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(335468288)
	Arguments and temporary variables: 
		evt: 	[(816@448) mouseUp 149507 nil]
		all: 	an Array(a PluggableButtonMorph(857193472) a PluggableButtonMorph(33546828...etc...
	Receiver's instance variables: 
		bounds: 	(769.0@436.0) corner: (869.0@466.0)
		owner: 	a PanelMorph(1071747072)
		submorphs: 	an Array(an AlignmentMorph(502232320))
		fullBounds: 	nil
		color: 	(Color r: 0.2903225806451613 g: 0.2883675464320626 b: 0.2883675464320626...etc...
		extension: 	a MorphExtension (169478144) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a SpMorphicButtonAdapter
		label: 	'Ok'
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	#state
		actionSelector: 	#action
		font: 	nil
		getLabelSelector: 	#label
		getMenuSelector: 	#menu:
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		getFontSelector: 	#font
		labelMorph: 	a LabelMorph(236987904)'Ok'
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	false


PluggableButtonMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableButtonMorph(335468288)
	Arguments and temporary variables: 
		anEvent: 	[(816@448) mouseUp 149507 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(769.0@436.0) corner: (869.0@466.0)
		owner: 	a PanelMorph(1071747072)
		submorphs: 	an Array(an AlignmentMorph(502232320))
		fullBounds: 	nil
		color: 	(Color r: 0.2903225806451613 g: 0.2883675464320626 b: 0.2883675464320626...etc...
		extension: 	a MorphExtension (169478144) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a SpMorphicButtonAdapter
		label: 	'Ok'
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	#state
		actionSelector: 	#action
		font: 	nil
		getLabelSelector: 	#label
		getMenuSelector: 	#menu:
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		getFontSelector: 	#font
		labelMorph: 	a LabelMorph(236987904)'Ok'
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	false


MouseButtonEvent>>sentTo:
	Receiver: [(816@448) mouseUp 149507 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableButtonMorph(335468288)
	Receiver's instance variables: 
		timeStamp: 	149507
		source: 	a HandMorph(986102528)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(816@448)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableButtonMorph(Morph)>>handleEvent:
	Receiver: a PluggableButtonMorph(335468288)
	Arguments and temporary variables: 
		anEvent: 	[(816@448) mouseUp 149507 nil]
	Receiver's instance variables: 
		bounds: 	(769.0@436.0) corner: (869.0@466.0)
		owner: 	a PanelMorph(1071747072)
		submorphs: 	an Array(an AlignmentMorph(502232320))
		fullBounds: 	nil
		color: 	(Color r: 0.2903225806451613 g: 0.2883675464320626 b: 0.2883675464320626...etc...
		extension: 	a MorphExtension (169478144) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a SpMorphicButtonAdapter
		label: 	'Ok'
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	#state
		actionSelector: 	#action
		font: 	nil
		getLabelSelector: 	#label
		getMenuSelector: 	#menu:
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		getFontSelector: 	#font
		labelMorph: 	a LabelMorph(236987904)'Ok'
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	false


PluggableButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a PluggableButtonMorph(335468288)
	Arguments and temporary variables: 
		anEvent: 	[(816@448) mouseUp 149507 nil]
	Receiver's instance variables: 
		bounds: 	(769.0@436.0) corner: (869.0@466.0)
		owner: 	a PanelMorph(1071747072)
		submorphs: 	an Array(an AlignmentMorph(502232320))
		fullBounds: 	nil
		color: 	(Color r: 0.2903225806451613 g: 0.2883675464320626 b: 0.2883675464320626...etc...
		extension: 	a MorphExtension (169478144) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a SpMorphicButtonAdapter
		label: 	'Ok'
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	#state
		actionSelector: 	#action
		font: 	nil
		getLabelSelector: 	#label
		getMenuSelector: 	#menu:
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		getFontSelector: 	#font
		labelMorph: 	a LabelMorph(236987904)'Ok'
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	false


[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(986102528)
	Arguments and temporary variables: 
		anEvent: 	[(816@448) mouseUp 149507 nil]
		focusHolder: 	a PluggableButtonMorph(335468288)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(603310592) [world]
		transformedEvent: 	[(816@448) mouseUp 149507 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(816@448) corner: (832@464)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	#()
		fullBounds: 	(816@448) corner: (832@464)
		color: 	Color blue
		extension: 	a MorphExtension (1065441536)
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(335468288)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(816@448) mouseUp 149507 nil]
		targetOffset: 	(47.0@12.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		lastKeyScanCode: 	nil
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		result := focusHolder handleFocusEvent: transformedEvent.
	]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
			ActiveWorld := priorWorld.
			ex pass ]
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	a CompiledBlock: [
		result := focusHolder handleFocusEvent: transform...etc...
		numArgs: 	0
		receiver: 	a HandMorph(986102528)


WorldMorph>>becomeActiveDuring:
	Receiver: a WorldMorph(603310592) [world]
	Arguments and temporary variables: 
		aBlock: 	[
		result := focusHolder handleFocusEvent: transformedEvent.
	]
		priorWorld: 	a WorldMorph(603310592) [world]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1512@851)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(1021235712) a TaskbarMorph(882262784) a SpDi...etc...
		fullBounds: 	(0@0) corner: (1512@851)
		color: 	(Color r: 0.29521016617790813 g: 0.29521016617790813 b: 0.29521016617790...etc...
		extension: 	a MorphExtension (219690240) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(986102528)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(816@448) mouseUp 149507 nil]
		focusHolder: 	a PluggableButtonMorph(335468288)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(603310592) [world]
		transformedEvent: 	[(816@448) mouseUp 149507 nil]
	Receiver's instance variables: 
		bounds: 	(816@448) corner: (832@464)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	#()
		fullBounds: 	(816@448) corner: (832@464)
		color: 	Color blue
		extension: 	a MorphExtension (1065441536)
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(335468288)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(816@448) mouseUp 149507 nil]
		targetOffset: 	(47.0@12.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		lastKeyScanCode: 	nil
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(986102528)
	Arguments and temporary variables: 
		anEvent: 	[(816@448) mouseUp 149507 nil]
		focusHolder: 	a PluggableButtonMorph(335468288)
		aBlock: 	[self mouseFocus: nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(816@448) corner: (832@464)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	#()
		fullBounds: 	(816@448) corner: (832@464)
		color: 	Color blue
		extension: 	a MorphExtension (1065441536)
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(335468288)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(816@448) mouseUp 149507 nil]
		targetOffset: 	(47.0@12.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		lastKeyScanCode: 	nil
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(986102528)
	Arguments and temporary variables: 
		anEvent: 	[(816@448) mouseUp 149507 nil]
	Receiver's instance variables: 
		bounds: 	(816@448) corner: (832@464)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	#()
		fullBounds: 	(816@448) corner: (832@464)
		color: 	Color blue
		extension: 	a MorphExtension (1065441536)
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(335468288)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(816@448) mouseUp 149507 nil]
		targetOffset: 	(47.0@12.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		lastKeyScanCode: 	nil
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>handleEvent:
	Receiver: a HandMorph(986102528)
	Arguments and temporary variables: 
		anEvent: 	[(816@448) mouseUp 149507 nil]
		evt: 	[(816@448) mouseUp 149507 nil]
	Receiver's instance variables: 
		bounds: 	(816@448) corner: (832@464)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	#()
		fullBounds: 	(816@448) corner: (832@464)
		color: 	Color blue
		extension: 	a MorphExtension (1065441536)
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(335468288)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(816@448) mouseUp 149507 nil]
		targetOffset: 	(47.0@12.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		lastKeyScanCode: 	nil
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
	Receiver: an OSWindowMorphicEventHandler
	Arguments and temporary variables: 
		anEvent: 	[(816@448) mouseUp 149507 nil]
	Receiver's instance variables: 
		morphicWorld: 	a WorldMorph(603310592) [world]


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(603310592) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(986102528))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	21497
		lastStepMessage: 	nil
		alarms: 	a Heap()
		lastAlarmTime: 	149479
		activeHand: 	a HandMorph(986102528)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1512@851)


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(603310592) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1512@851)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(1021235712) a TaskbarMorph(882262784) a SpDi...etc...
		fullBounds: 	(0@0) corner: (1512@851)
		color: 	(Color r: 0.29521016617790813 g: 0.29521016617790813 b: 0.29521016617790...etc...
		extension: 	a MorphExtension (219690240) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(603310592) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(986102528))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	21497
		lastStepMessage: 	nil
		alarms: 	a Heap()
		lastAlarmTime: 	149479
		activeHand: 	a HandMorph(986102528)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1512@851)


WorldMorph>>doOneCycleNow
	Receiver: a WorldMorph(603310592) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1512@851)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(1021235712) a TaskbarMorph(882262784) a SpDi...etc...
		fullBounds: 	(0@0) corner: (1512@851)
		color: 	(Color r: 0.29521016617790813 g: 0.29521016617790813 b: 0.29521016617790...etc...
		extension: 	a MorphExtension (219690240) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(603310592) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1512@851)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(1021235712) a TaskbarMorph(882262784) a SpDi...etc...
		fullBounds: 	(0@0) corner: (1512@851)
		color: 	(Color r: 0.29521016617790813 g: 0.29521016617790813 b: 0.29521016617790...etc...
		extension: 	a MorphExtension (219690240) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 
		extraWorldsToDraw: 	#()
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65547
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->nil #CursorOwnerWorld->a WorldMorph(60...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		announcer: 	nil
		displayScaleFactor: 	1


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extr...etc...
	Arguments and temporary variables: 
		aBlock: 	[
		self doInterCycleWait
	]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	WorldMorph class>>doOneCycle
		startpc: 	a CompiledBlock: [
		| extraWorldsToDraw |
		extraWorldsToDraw := Extr...etc...
		numArgs: 	0
		receiver: 	WorldMorph


WorldState class>>doDrawCycleWith:
	Receiver: WorldState
	Arguments and temporary variables: 
		aBlock: 	[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex cr...etc...
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#activeHand->WorldState>>#activeHand #activeHand...etc...
		format: 	65547
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldState}
		name: 	#WorldState
		classPool: 	a Dictionary(#CanSurrenderToOS->nil #DebugShowDamage->false #Deferre...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'


WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65547
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->nil #CursorOwnerWorld->a WorldMorph(60...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		announcer: 	nil
		displayScaleFactor: 	1


MorphicRenderLoop>>doOneCycle
	Receiver: a MorphicRenderLoop
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
a MorphicRenderLoop

MorphicRenderLoop>>doOneCycleWhile:
	Receiver: a MorphicRenderLoop
	Arguments and temporary variables: 
		aBlock: 	[ true ]
	Receiver's instance variables: 
a MorphicRenderLoop

[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		activeTranscript: 	Transcript



--- The full stack ---
IceTipLocalRepositoryPanel(Object)>>assert:description:
IceTipLocalRepositoryPanel>>validate
IceTipRegisterRepositoryDialog>>doAccept
[ self doAccept ] in IceTipRegisterRepositoryDialog(IceTipOptionDialog)>>initializeDialogWindow:
FullBlockClosure(BlockClosure)>>cull:
SpDialogWindowPresenter>>triggerOkAction
[ :presenter | 
			presenter triggerOkAction.
			presenter close ] in SpAbstractPresenter>>initializeDialogWindow:
FullBlockClosure(BlockClosure)>>cull:
[ aBlock cull: self ] in SpDialogWindowPresenter>>addButton:do:
SpButtonPresenter>>performAction
SpMorphicButtonAdapter>>action
PluggableButtonMorph>>performAction:
[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in PluggableButtonMorph>>mouseUp:
Array(SequenceableCollection)>>do:
PluggableButtonMorph>>mouseUp:
PluggableButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableButtonMorph(Morph)>>handleEvent:
PluggableButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
AssertionFailure: Project location must exist!
26 September 2022 7:24:55.907583 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
StackToRegisterMappingCogit * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
v9.0.18 - Commit: 7249c170 - Date: 2022-09-02 14:31:12 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

IceTipLocalRepositoryPanel(Object)>>assert:description:
	Receiver: an IceTipLocalRepositoryPanel
	Arguments and temporary variables: 
		aBlock: 	false
		aStringOrBlock: 	'Project location must exist!'
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	an IceTipRegisterRepositoryDialog
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		projectLocation: 	an IceTipDirectoryPresenter
		remoteLabel: 	nil
		remoteInputText: 	nil
		repository: 	nil


IceTipLocalRepositoryPanel>>validate
	Receiver: an IceTipLocalRepositoryPanel
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	an IceTipRegisterRepositoryDialog
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		projectLocation: 	an IceTipDirectoryPresenter
		remoteLabel: 	nil
		remoteInputText: 	nil
		repository: 	nil


IceTipRegisterRepositoryDialog>>doAccept
	Receiver: an IceTipRegisterRepositoryDialog
	Arguments and temporary variables: 
		newRepository: 	nil
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		owner: 	a SpDialogWindowPresenter
		adapter: 	a SpMorphicPanedAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a SpNullApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpPanedLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		typeList: 	a SpTablePresenter
		type: 	an IceTipLocalRepositoryPanel
		contentPanel: 	an IceTipLocalRepositoryPanel
		types: 	an OrderedCollection(an IceTipNewRepositoryPanel an IceTipLocalRepositor...etc...
		repository: 	nil
		acceptBlock: 	nil


[ self doAccept ] in IceTipRegisterRepositoryDialog(IceTipOptionDialog)>>initializeDialogWindow:
	Receiver: an IceTipRegisterRepositoryDialog
	Arguments and temporary variables: 
		aWindowPresenter: 	a SpDialogWindowPresenter
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		owner: 	a SpDialogWindowPresenter
		adapter: 	a SpMorphicPanedAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a SpNullApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpPanedLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		typeList: 	a SpTablePresenter
		type: 	an IceTipLocalRepositoryPanel
		contentPanel: 	an IceTipLocalRepositoryPanel
		types: 	an OrderedCollection(an IceTipNewRepositoryPanel an IceTipLocalRepositor...etc...
		repository: 	nil
		acceptBlock: 	nil


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ self doAccept ]
	Arguments and temporary variables: 
		anArg: 	a SpDialogWindowPresenter
	Receiver's instance variables: 
		outerContext: 	IceTipRegisterRepositoryDialog(IceTipOptionDialog)>>initializeDia...etc...
		startpc: 	a CompiledBlock: [ self doAccept ]
		numArgs: 	0
		receiver: 	an IceTipRegisterRepositoryDialog


SpDialogWindowPresenter>>triggerOkAction
	Receiver: a SpDialogWindowPresenter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicDialogWindowAdapter a SpDialogWindow(3...etc...
		announcer: 	an Announcer
		owner: 	nil
		adapter: 	a SpMorphicDialogWindowAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a SpNullApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ Form(16x16x32) ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ true ]
		titleHolder: 	an ObservableValueHolder[ 'Import from existing clone' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ nil ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		presenter: 	an ObservableValueHolder[ an IceTipRegisterRepositoryDialog ]
		initialPosition: 	an ObservableValueHolder[ nil ]
		initialExtent: 	an ObservableValueHolder[ (600@300) ]
		isResizeable: 	an ObservableValueHolder[ true ]
		menu: 	an ObservableValueHolder[ nil ]
		centered: 	an ObservableValueHolder[ false ]
		isClosed: 	an ObservableValueHolder[ false ]
		toolbar: 	an ObservableValueHolder[ nil ]
		statusbar: 	an ObservableValueHolder[ nil ]
		window: 	an ObservableValueHolder[ a SpDialogWindow(308885760) named: Import fro...etc...
		decorations: 	an ObservableValueHolder[ true ]
		buttons: 	an OrderedCollection(a SpButtonPresenter a SpButtonPresenter)
		okAction: 	[ self doAccept ]
		cancelAction: 	[ 
		cancelled := true.
		self close ]
		cancelled: 	true
		defaultButton: 	nil


[ :presenter | 
			presenter triggerOkAction.
			presenter close ] in SpAbstractPresenter>>initializeDialogWindow:
	Receiver: an IceTipRegisterRepositoryDialog
	Arguments and temporary variables: 
		aDialogWindowPresenter: 	a SpDialogWindowPresenter
		presenter: 	a SpDialogWindowPresenter
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		owner: 	a SpDialogWindowPresenter
		adapter: 	a SpMorphicPanedAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a SpNullApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpPanedLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		typeList: 	a SpTablePresenter
		type: 	an IceTipLocalRepositoryPanel
		contentPanel: 	an IceTipLocalRepositoryPanel
		types: 	an OrderedCollection(an IceTipNewRepositoryPanel an IceTipLocalRepositor...etc...
		repository: 	nil
		acceptBlock: 	nil


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ :presenter | 
			presenter triggerOkAction.
			presenter close ]
	Arguments and temporary variables: 
		anArg: 	a SpDialogWindowPresenter
	Receiver's instance variables: 
		outerContext: 	IceTipRegisterRepositoryDialog(SpAbstractPresenter)>>initializeDi...etc...
		startpc: 	a CompiledBlock: [ :presenter | 
			presenter triggerOkAction.
			pres...etc...
		numArgs: 	1
		receiver: 	an IceTipRegisterRepositoryDialog


[ aBlock cull: self ] in SpDialogWindowPresenter>>addButton:do:
	Receiver: a SpDialogWindowPresenter
	Arguments and temporary variables: 
		aString: 	'Ok'
		aBlock: 	[ :presenter | 
			presenter triggerOkAction.
			presenter close ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicDialogWindowAdapter a SpDialogWindow(3...etc...
		announcer: 	an Announcer
		owner: 	nil
		adapter: 	a SpMorphicDialogWindowAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a SpNullApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ Form(16x16x32) ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ true ]
		titleHolder: 	an ObservableValueHolder[ 'Import from existing clone' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ nil ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		presenter: 	an ObservableValueHolder[ an IceTipRegisterRepositoryDialog ]
		initialPosition: 	an ObservableValueHolder[ nil ]
		initialExtent: 	an ObservableValueHolder[ (600@300) ]
		isResizeable: 	an ObservableValueHolder[ true ]
		menu: 	an ObservableValueHolder[ nil ]
		centered: 	an ObservableValueHolder[ false ]
		isClosed: 	an ObservableValueHolder[ false ]
		toolbar: 	an ObservableValueHolder[ nil ]
		statusbar: 	an ObservableValueHolder[ nil ]
		window: 	an ObservableValueHolder[ a SpDialogWindow(308885760) named: Import fro...etc...
		decorations: 	an ObservableValueHolder[ true ]
		buttons: 	an OrderedCollection(a SpButtonPresenter a SpButtonPresenter)
		okAction: 	[ self doAccept ]
		cancelAction: 	[ 
		cancelled := true.
		self close ]
		cancelled: 	true
		defaultButton: 	nil


SpButtonPresenter>>performAction
	Receiver: a SpButtonPresenter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicButtonAdapter)
		announcer: 	an Announcer
		owner: 	a SpButtonBarPresenter
		adapter: 	a SpMorphicButtonAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Button' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		icon: 	an ObservableValueHolder[ nil ]
		label: 	an ObservableValueHolder[ 'Ok' ]
		action: 	an ObservableValueHolder[ [ aBlock cull: self ] ]
		actionPerformed: 	an ObservableValueHolder[ nil ]
		askBeforeChanging: 	an ObservableValueHolder[ false ]
		font: 	an ObservableValueHolder[ nil ]
		shortcut: 	an ObservableValueHolder[ nil ]
		state: 	an ObservableValueHolder[ false ]
		contextMenu: 	an ObservableValueHolder[ nil ]


SpMorphicButtonAdapter>>action
	Receiver: a SpMorphicButtonAdapter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a PluggableButtonMorph(335468288))
		announcer: 	nil
		model: 	a SpButtonPresenter
		widget: 	a PluggableButtonMorph(335468288)
		selector: 	nil
		owner: 	a SpButtonPresenter
		subMenuWidget: 	nil
		styleName: 	nil


PluggableButtonMorph>>performAction:
	Receiver: a PluggableButtonMorph(335468288)
	Arguments and temporary variables: 
		event: 	[(816@448) mouseUp 149507 nil]
	Receiver's instance variables: 
		bounds: 	(769.0@436.0) corner: (869.0@466.0)
		owner: 	a PanelMorph(1071747072)
		submorphs: 	an Array(an AlignmentMorph(502232320))
		fullBounds: 	nil
		color: 	(Color r: 0.2903225806451613 g: 0.2883675464320626 b: 0.2883675464320626...etc...
		extension: 	a MorphExtension (169478144) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a SpMorphicButtonAdapter
		label: 	'Ok'
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	#state
		actionSelector: 	#action
		font: 	nil
		getLabelSelector: 	#label
		getMenuSelector: 	#menu:
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		getFontSelector: 	#font
		labelMorph: 	a LabelMorph(236987904)'Ok'
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	false


[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(335468288)
	Arguments and temporary variables: 
		evt: 	[(816@448) mouseUp 149507 nil]
		all: 	an Array(a PluggableButtonMorph(857193472) a PluggableButtonMorph(33546828...etc...
		m: 	a PluggableButtonMorph(335468288)
	Receiver's instance variables: 
		bounds: 	(769.0@436.0) corner: (869.0@466.0)
		owner: 	a PanelMorph(1071747072)
		submorphs: 	an Array(an AlignmentMorph(502232320))
		fullBounds: 	nil
		color: 	(Color r: 0.2903225806451613 g: 0.2883675464320626 b: 0.2883675464320626...etc...
		extension: 	a MorphExtension (169478144) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a SpMorphicButtonAdapter
		label: 	'Ok'
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	#state
		actionSelector: 	#action
		font: 	nil
		getLabelSelector: 	#label
		getMenuSelector: 	#menu:
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		getFontSelector: 	#font
		labelMorph: 	a LabelMorph(236987904)'Ok'
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	false


Array(SequenceableCollection)>>do:
	Receiver: an Array(a PluggableButtonMorph(857193472) a PluggableButtonMorph(335468288))
	Arguments and temporary variables: 
		aBlock: 	[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [...etc...
		index: 	2
	Receiver's instance variables: 
an Array(a PluggableButtonMorph(857193472) a PluggableButtonMorph(335468288))

PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(335468288)
	Arguments and temporary variables: 
		evt: 	[(816@448) mouseUp 149507 nil]
		all: 	an Array(a PluggableButtonMorph(857193472) a PluggableButtonMorph(33546828...etc...
	Receiver's instance variables: 
		bounds: 	(769.0@436.0) corner: (869.0@466.0)
		owner: 	a PanelMorph(1071747072)
		submorphs: 	an Array(an AlignmentMorph(502232320))
		fullBounds: 	nil
		color: 	(Color r: 0.2903225806451613 g: 0.2883675464320626 b: 0.2883675464320626...etc...
		extension: 	a MorphExtension (169478144) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a SpMorphicButtonAdapter
		label: 	'Ok'
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	#state
		actionSelector: 	#action
		font: 	nil
		getLabelSelector: 	#label
		getMenuSelector: 	#menu:
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		getFontSelector: 	#font
		labelMorph: 	a LabelMorph(236987904)'Ok'
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	false


PluggableButtonMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableButtonMorph(335468288)
	Arguments and temporary variables: 
		anEvent: 	[(816@448) mouseUp 149507 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(769.0@436.0) corner: (869.0@466.0)
		owner: 	a PanelMorph(1071747072)
		submorphs: 	an Array(an AlignmentMorph(502232320))
		fullBounds: 	nil
		color: 	(Color r: 0.2903225806451613 g: 0.2883675464320626 b: 0.2883675464320626...etc...
		extension: 	a MorphExtension (169478144) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a SpMorphicButtonAdapter
		label: 	'Ok'
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	#state
		actionSelector: 	#action
		font: 	nil
		getLabelSelector: 	#label
		getMenuSelector: 	#menu:
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		getFontSelector: 	#font
		labelMorph: 	a LabelMorph(236987904)'Ok'
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	false


MouseButtonEvent>>sentTo:
	Receiver: [(816@448) mouseUp 149507 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableButtonMorph(335468288)
	Receiver's instance variables: 
		timeStamp: 	149507
		source: 	a HandMorph(986102528)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(816@448)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableButtonMorph(Morph)>>handleEvent:
	Receiver: a PluggableButtonMorph(335468288)
	Arguments and temporary variables: 
		anEvent: 	[(816@448) mouseUp 149507 nil]
	Receiver's instance variables: 
		bounds: 	(769.0@436.0) corner: (869.0@466.0)
		owner: 	a PanelMorph(1071747072)
		submorphs: 	an Array(an AlignmentMorph(502232320))
		fullBounds: 	nil
		color: 	(Color r: 0.2903225806451613 g: 0.2883675464320626 b: 0.2883675464320626...etc...
		extension: 	a MorphExtension (169478144) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a SpMorphicButtonAdapter
		label: 	'Ok'
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	#state
		actionSelector: 	#action
		font: 	nil
		getLabelSelector: 	#label
		getMenuSelector: 	#menu:
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		getFontSelector: 	#font
		labelMorph: 	a LabelMorph(236987904)'Ok'
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	false


PluggableButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a PluggableButtonMorph(335468288)
	Arguments and temporary variables: 
		anEvent: 	[(816@448) mouseUp 149507 nil]
	Receiver's instance variables: 
		bounds: 	(769.0@436.0) corner: (869.0@466.0)
		owner: 	a PanelMorph(1071747072)
		submorphs: 	an Array(an AlignmentMorph(502232320))
		fullBounds: 	nil
		color: 	(Color r: 0.2903225806451613 g: 0.2883675464320626 b: 0.2883675464320626...etc...
		extension: 	a MorphExtension (169478144) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a SpMorphicButtonAdapter
		label: 	'Ok'
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	#state
		actionSelector: 	#action
		font: 	nil
		getLabelSelector: 	#label
		getMenuSelector: 	#menu:
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		getFontSelector: 	#font
		labelMorph: 	a LabelMorph(236987904)'Ok'
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	false


[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(986102528)
	Arguments and temporary variables: 
		anEvent: 	[(816@448) mouseUp 149507 nil]
		focusHolder: 	a PluggableButtonMorph(335468288)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(603310592) [world]
		transformedEvent: 	[(816@448) mouseUp 149507 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(816@448) corner: (832@464)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	#()
		fullBounds: 	(816@448) corner: (832@464)
		color: 	Color blue
		extension: 	a MorphExtension (1065441536)
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(335468288)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(816@448) mouseUp 149507 nil]
		targetOffset: 	(47.0@12.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		lastKeyScanCode: 	nil
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		result := focusHolder handleFocusEvent: transformedEvent.
	]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
			ActiveWorld := priorWorld.
			ex pass ]
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	a CompiledBlock: [
		result := focusHolder handleFocusEvent: transform...etc...
		numArgs: 	0
		receiver: 	a HandMorph(986102528)


WorldMorph>>becomeActiveDuring:
	Receiver: a WorldMorph(603310592) [world]
	Arguments and temporary variables: 
		aBlock: 	[
		result := focusHolder handleFocusEvent: transformedEvent.
	]
		priorWorld: 	a WorldMorph(603310592) [world]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1512@851)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(1021235712) a TaskbarMorph(882262784) a SpDi...etc...
		fullBounds: 	(0@0) corner: (1512@851)
		color: 	(Color r: 0.29521016617790813 g: 0.29521016617790813 b: 0.29521016617790...etc...
		extension: 	a MorphExtension (219690240) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(986102528)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(816@448) mouseUp 149507 nil]
		focusHolder: 	a PluggableButtonMorph(335468288)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(603310592) [world]
		transformedEvent: 	[(816@448) mouseUp 149507 nil]
	Receiver's instance variables: 
		bounds: 	(816@448) corner: (832@464)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	#()
		fullBounds: 	(816@448) corner: (832@464)
		color: 	Color blue
		extension: 	a MorphExtension (1065441536)
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(335468288)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(816@448) mouseUp 149507 nil]
		targetOffset: 	(47.0@12.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		lastKeyScanCode: 	nil
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(986102528)
	Arguments and temporary variables: 
		anEvent: 	[(816@448) mouseUp 149507 nil]
		focusHolder: 	a PluggableButtonMorph(335468288)
		aBlock: 	[self mouseFocus: nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(816@448) corner: (832@464)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	#()
		fullBounds: 	(816@448) corner: (832@464)
		color: 	Color blue
		extension: 	a MorphExtension (1065441536)
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(335468288)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(816@448) mouseUp 149507 nil]
		targetOffset: 	(47.0@12.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		lastKeyScanCode: 	nil
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(986102528)
	Arguments and temporary variables: 
		anEvent: 	[(816@448) mouseUp 149507 nil]
	Receiver's instance variables: 
		bounds: 	(816@448) corner: (832@464)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	#()
		fullBounds: 	(816@448) corner: (832@464)
		color: 	Color blue
		extension: 	a MorphExtension (1065441536)
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(335468288)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(816@448) mouseUp 149507 nil]
		targetOffset: 	(47.0@12.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		lastKeyScanCode: 	nil
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>handleEvent:
	Receiver: a HandMorph(986102528)
	Arguments and temporary variables: 
		anEvent: 	[(816@448) mouseUp 149507 nil]
		evt: 	[(816@448) mouseUp 149507 nil]
	Receiver's instance variables: 
		bounds: 	(816@448) corner: (832@464)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	#()
		fullBounds: 	(816@448) corner: (832@464)
		color: 	Color blue
		extension: 	a MorphExtension (1065441536)
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(335468288)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(816@448) mouseUp 149507 nil]
		targetOffset: 	(47.0@12.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		lastKeyScanCode: 	nil
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
	Receiver: an OSWindowMorphicEventHandler
	Arguments and temporary variables: 
		anEvent: 	[(816@448) mouseUp 149507 nil]
	Receiver's instance variables: 
		morphicWorld: 	a WorldMorph(603310592) [world]


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(603310592) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(986102528))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	21497
		lastStepMessage: 	nil
		alarms: 	a Heap()
		lastAlarmTime: 	149479
		activeHand: 	a HandMorph(986102528)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1512@851)


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(603310592) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1512@851)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(1021235712) a TaskbarMorph(882262784) a SpDi...etc...
		fullBounds: 	(0@0) corner: (1512@851)
		color: 	(Color r: 0.29521016617790813 g: 0.29521016617790813 b: 0.29521016617790...etc...
		extension: 	a MorphExtension (219690240) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(603310592) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(986102528))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	21497
		lastStepMessage: 	nil
		alarms: 	a Heap()
		lastAlarmTime: 	149479
		activeHand: 	a HandMorph(986102528)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1512@851)


WorldMorph>>doOneCycleNow
	Receiver: a WorldMorph(603310592) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1512@851)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(1021235712) a TaskbarMorph(882262784) a SpDi...etc...
		fullBounds: 	(0@0) corner: (1512@851)
		color: 	(Color r: 0.29521016617790813 g: 0.29521016617790813 b: 0.29521016617790...etc...
		extension: 	a MorphExtension (219690240) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(603310592) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1512@851)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(1021235712) a TaskbarMorph(882262784) a SpDi...etc...
		fullBounds: 	(0@0) corner: (1512@851)
		color: 	(Color r: 0.29521016617790813 g: 0.29521016617790813 b: 0.29521016617790...etc...
		extension: 	a MorphExtension (219690240) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 
		extraWorldsToDraw: 	#()
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65547
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->nil #CursorOwnerWorld->a WorldMorph(60...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		announcer: 	nil
		displayScaleFactor: 	1


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extr...etc...
	Arguments and temporary variables: 
		aBlock: 	[
		self doInterCycleWait
	]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	WorldMorph class>>doOneCycle
		startpc: 	a CompiledBlock: [
		| extraWorldsToDraw |
		extraWorldsToDraw := Extr...etc...
		numArgs: 	0
		receiver: 	WorldMorph


WorldState class>>doDrawCycleWith:
	Receiver: WorldState
	Arguments and temporary variables: 
		aBlock: 	[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex cr...etc...
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#activeHand->WorldState>>#activeHand #activeHand...etc...
		format: 	65547
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldState}
		name: 	#WorldState
		classPool: 	a Dictionary(#CanSurrenderToOS->nil #DebugShowDamage->false #Deferre...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'


WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65547
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->nil #CursorOwnerWorld->a WorldMorph(60...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		announcer: 	nil
		displayScaleFactor: 	1


MorphicRenderLoop>>doOneCycle
	Receiver: a MorphicRenderLoop
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
a MorphicRenderLoop

MorphicRenderLoop>>doOneCycleWhile:
	Receiver: a MorphicRenderLoop
	Arguments and temporary variables: 
		aBlock: 	[ true ]
	Receiver's instance variables: 
a MorphicRenderLoop

[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		activeTranscript: 	Transcript



--- The full stack ---
IceTipLocalRepositoryPanel(Object)>>assert:description:
IceTipLocalRepositoryPanel>>validate
IceTipRegisterRepositoryDialog>>doAccept
[ self doAccept ] in IceTipRegisterRepositoryDialog(IceTipOptionDialog)>>initializeDialogWindow:
FullBlockClosure(BlockClosure)>>cull:
SpDialogWindowPresenter>>triggerOkAction
[ :presenter | 
			presenter triggerOkAction.
			presenter close ] in SpAbstractPresenter>>initializeDialogWindow:
FullBlockClosure(BlockClosure)>>cull:
[ aBlock cull: self ] in SpDialogWindowPresenter>>addButton:do:
SpButtonPresenter>>performAction
SpMorphicButtonAdapter>>action
PluggableButtonMorph>>performAction:
[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in PluggableButtonMorph>>mouseUp:
Array(SequenceableCollection)>>do:
PluggableButtonMorph>>mouseUp:
PluggableButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableButtonMorph(Morph)>>handleEvent:
PluggableButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
AssertionFailure: Project location does not seems to be a valid git repository.
26 September 2022 7:25:35.245691 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
StackToRegisterMappingCogit * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
v9.0.18 - Commit: 7249c170 - Date: 2022-09-02 14:31:12 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

IceTipLocalRepositoryPanel(Object)>>assert:description:
	Receiver: an IceTipLocalRepositoryPanel
	Arguments and temporary variables: 
		aBlock: 	false
		aStringOrBlock: 	'Project location does not seems to be a valid git repository.'...etc...
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	an IceTipRegisterRepositoryDialog
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		projectLocation: 	an IceTipDirectoryPresenter
		remoteLabel: 	nil
		remoteInputText: 	nil
		repository: 	nil


IceTipLocalRepositoryPanel>>validate
	Receiver: an IceTipLocalRepositoryPanel
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	an IceTipRegisterRepositoryDialog
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		projectLocation: 	an IceTipDirectoryPresenter
		remoteLabel: 	nil
		remoteInputText: 	nil
		repository: 	nil


IceTipRegisterRepositoryDialog>>doAccept
	Receiver: an IceTipRegisterRepositoryDialog
	Arguments and temporary variables: 
		newRepository: 	nil
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		owner: 	a SpDialogWindowPresenter
		adapter: 	a SpMorphicPanedAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a SpNullApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpPanedLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		typeList: 	a SpTablePresenter
		type: 	an IceTipLocalRepositoryPanel
		contentPanel: 	an IceTipLocalRepositoryPanel
		types: 	an OrderedCollection(an IceTipNewRepositoryPanel an IceTipLocalRepositor...etc...
		repository: 	nil
		acceptBlock: 	nil


[ self doAccept ] in IceTipRegisterRepositoryDialog(IceTipOptionDialog)>>initializeDialogWindow:
	Receiver: an IceTipRegisterRepositoryDialog
	Arguments and temporary variables: 
		aWindowPresenter: 	a SpDialogWindowPresenter
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		owner: 	a SpDialogWindowPresenter
		adapter: 	a SpMorphicPanedAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a SpNullApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpPanedLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		typeList: 	a SpTablePresenter
		type: 	an IceTipLocalRepositoryPanel
		contentPanel: 	an IceTipLocalRepositoryPanel
		types: 	an OrderedCollection(an IceTipNewRepositoryPanel an IceTipLocalRepositor...etc...
		repository: 	nil
		acceptBlock: 	nil


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ self doAccept ]
	Arguments and temporary variables: 
		anArg: 	a SpDialogWindowPresenter
	Receiver's instance variables: 
		outerContext: 	IceTipRegisterRepositoryDialog(IceTipOptionDialog)>>initializeDia...etc...
		startpc: 	a CompiledBlock: [ self doAccept ]
		numArgs: 	0
		receiver: 	an IceTipRegisterRepositoryDialog


SpDialogWindowPresenter>>triggerOkAction
	Receiver: a SpDialogWindowPresenter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicDialogWindowAdapter a SpDialogWindow(3...etc...
		announcer: 	an Announcer
		owner: 	nil
		adapter: 	a SpMorphicDialogWindowAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a SpNullApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ Form(16x16x32) ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ true ]
		titleHolder: 	an ObservableValueHolder[ 'Import from existing clone' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ nil ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		presenter: 	an ObservableValueHolder[ an IceTipRegisterRepositoryDialog ]
		initialPosition: 	an ObservableValueHolder[ nil ]
		initialExtent: 	an ObservableValueHolder[ (600@300) ]
		isResizeable: 	an ObservableValueHolder[ true ]
		menu: 	an ObservableValueHolder[ nil ]
		centered: 	an ObservableValueHolder[ false ]
		isClosed: 	an ObservableValueHolder[ false ]
		toolbar: 	an ObservableValueHolder[ nil ]
		statusbar: 	an ObservableValueHolder[ nil ]
		window: 	an ObservableValueHolder[ a SpDialogWindow(308885760) named: Import fro...etc...
		decorations: 	an ObservableValueHolder[ true ]
		buttons: 	an OrderedCollection(a SpButtonPresenter a SpButtonPresenter)
		okAction: 	[ self doAccept ]
		cancelAction: 	[ 
		cancelled := true.
		self close ]
		cancelled: 	true
		defaultButton: 	nil


[ :presenter | 
			presenter triggerOkAction.
			presenter close ] in SpAbstractPresenter>>initializeDialogWindow:
	Receiver: an IceTipRegisterRepositoryDialog
	Arguments and temporary variables: 
		aDialogWindowPresenter: 	a SpDialogWindowPresenter
		presenter: 	a SpDialogWindowPresenter
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		owner: 	a SpDialogWindowPresenter
		adapter: 	a SpMorphicPanedAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a SpNullApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpPanedLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		typeList: 	a SpTablePresenter
		type: 	an IceTipLocalRepositoryPanel
		contentPanel: 	an IceTipLocalRepositoryPanel
		types: 	an OrderedCollection(an IceTipNewRepositoryPanel an IceTipLocalRepositor...etc...
		repository: 	nil
		acceptBlock: 	nil


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ :presenter | 
			presenter triggerOkAction.
			presenter close ]
	Arguments and temporary variables: 
		anArg: 	a SpDialogWindowPresenter
	Receiver's instance variables: 
		outerContext: 	IceTipRegisterRepositoryDialog(SpAbstractPresenter)>>initializeDi...etc...
		startpc: 	a CompiledBlock: [ :presenter | 
			presenter triggerOkAction.
			pres...etc...
		numArgs: 	1
		receiver: 	an IceTipRegisterRepositoryDialog


[ aBlock cull: self ] in SpDialogWindowPresenter>>addButton:do:
	Receiver: a SpDialogWindowPresenter
	Arguments and temporary variables: 
		aString: 	'Ok'
		aBlock: 	[ :presenter | 
			presenter triggerOkAction.
			presenter close ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicDialogWindowAdapter a SpDialogWindow(3...etc...
		announcer: 	an Announcer
		owner: 	nil
		adapter: 	a SpMorphicDialogWindowAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a SpNullApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ Form(16x16x32) ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ true ]
		titleHolder: 	an ObservableValueHolder[ 'Import from existing clone' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ nil ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		presenter: 	an ObservableValueHolder[ an IceTipRegisterRepositoryDialog ]
		initialPosition: 	an ObservableValueHolder[ nil ]
		initialExtent: 	an ObservableValueHolder[ (600@300) ]
		isResizeable: 	an ObservableValueHolder[ true ]
		menu: 	an ObservableValueHolder[ nil ]
		centered: 	an ObservableValueHolder[ false ]
		isClosed: 	an ObservableValueHolder[ false ]
		toolbar: 	an ObservableValueHolder[ nil ]
		statusbar: 	an ObservableValueHolder[ nil ]
		window: 	an ObservableValueHolder[ a SpDialogWindow(308885760) named: Import fro...etc...
		decorations: 	an ObservableValueHolder[ true ]
		buttons: 	an OrderedCollection(a SpButtonPresenter a SpButtonPresenter)
		okAction: 	[ self doAccept ]
		cancelAction: 	[ 
		cancelled := true.
		self close ]
		cancelled: 	true
		defaultButton: 	nil


SpButtonPresenter>>performAction
	Receiver: a SpButtonPresenter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicButtonAdapter)
		announcer: 	an Announcer
		owner: 	a SpButtonBarPresenter
		adapter: 	a SpMorphicButtonAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Button' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		icon: 	an ObservableValueHolder[ nil ]
		label: 	an ObservableValueHolder[ 'Ok' ]
		action: 	an ObservableValueHolder[ [ aBlock cull: self ] ]
		actionPerformed: 	an ObservableValueHolder[ nil ]
		askBeforeChanging: 	an ObservableValueHolder[ false ]
		font: 	an ObservableValueHolder[ nil ]
		shortcut: 	an ObservableValueHolder[ nil ]
		state: 	an ObservableValueHolder[ false ]
		contextMenu: 	an ObservableValueHolder[ nil ]


SpMorphicButtonAdapter>>action
	Receiver: a SpMorphicButtonAdapter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a PluggableButtonMorph(335468288))
		announcer: 	nil
		model: 	a SpButtonPresenter
		widget: 	a PluggableButtonMorph(335468288)
		selector: 	nil
		owner: 	a SpButtonPresenter
		subMenuWidget: 	nil
		styleName: 	nil


PluggableButtonMorph>>performAction:
	Receiver: a PluggableButtonMorph(335468288)
	Arguments and temporary variables: 
		event: 	[(843@453) mouseUp 188910 nil]
	Receiver's instance variables: 
		bounds: 	(769.0@436.0) corner: (869.0@466.0)
		owner: 	a PanelMorph(1071747072)
		submorphs: 	an Array(an AlignmentMorph(502232320))
		fullBounds: 	nil
		color: 	(Color r: 0.2903225806451613 g: 0.2883675464320626 b: 0.2883675464320626...etc...
		extension: 	a MorphExtension (169478144) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a SpMorphicButtonAdapter
		label: 	'Ok'
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	#state
		actionSelector: 	#action
		font: 	nil
		getLabelSelector: 	#label
		getMenuSelector: 	#menu:
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		getFontSelector: 	#font
		labelMorph: 	a LabelMorph(236987904)'Ok'
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	false


[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(335468288)
	Arguments and temporary variables: 
		evt: 	[(843@453) mouseUp 188910 nil]
		all: 	an Array(a PluggableButtonMorph(857193472) a PluggableButtonMorph(33546828...etc...
		m: 	a PluggableButtonMorph(335468288)
	Receiver's instance variables: 
		bounds: 	(769.0@436.0) corner: (869.0@466.0)
		owner: 	a PanelMorph(1071747072)
		submorphs: 	an Array(an AlignmentMorph(502232320))
		fullBounds: 	nil
		color: 	(Color r: 0.2903225806451613 g: 0.2883675464320626 b: 0.2883675464320626...etc...
		extension: 	a MorphExtension (169478144) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a SpMorphicButtonAdapter
		label: 	'Ok'
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	#state
		actionSelector: 	#action
		font: 	nil
		getLabelSelector: 	#label
		getMenuSelector: 	#menu:
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		getFontSelector: 	#font
		labelMorph: 	a LabelMorph(236987904)'Ok'
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	false


Array(SequenceableCollection)>>do:
	Receiver: an Array(a PluggableButtonMorph(857193472) a PluggableButtonMorph(335468288))
	Arguments and temporary variables: 
		aBlock: 	[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [...etc...
		index: 	2
	Receiver's instance variables: 
an Array(a PluggableButtonMorph(857193472) a PluggableButtonMorph(335468288))

PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(335468288)
	Arguments and temporary variables: 
		evt: 	[(843@453) mouseUp 188910 nil]
		all: 	an Array(a PluggableButtonMorph(857193472) a PluggableButtonMorph(33546828...etc...
	Receiver's instance variables: 
		bounds: 	(769.0@436.0) corner: (869.0@466.0)
		owner: 	a PanelMorph(1071747072)
		submorphs: 	an Array(an AlignmentMorph(502232320))
		fullBounds: 	nil
		color: 	(Color r: 0.2903225806451613 g: 0.2883675464320626 b: 0.2883675464320626...etc...
		extension: 	a MorphExtension (169478144) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a SpMorphicButtonAdapter
		label: 	'Ok'
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	#state
		actionSelector: 	#action
		font: 	nil
		getLabelSelector: 	#label
		getMenuSelector: 	#menu:
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		getFontSelector: 	#font
		labelMorph: 	a LabelMorph(236987904)'Ok'
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	false


PluggableButtonMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableButtonMorph(335468288)
	Arguments and temporary variables: 
		anEvent: 	[(843@453) mouseUp 188910 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(769.0@436.0) corner: (869.0@466.0)
		owner: 	a PanelMorph(1071747072)
		submorphs: 	an Array(an AlignmentMorph(502232320))
		fullBounds: 	nil
		color: 	(Color r: 0.2903225806451613 g: 0.2883675464320626 b: 0.2883675464320626...etc...
		extension: 	a MorphExtension (169478144) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a SpMorphicButtonAdapter
		label: 	'Ok'
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	#state
		actionSelector: 	#action
		font: 	nil
		getLabelSelector: 	#label
		getMenuSelector: 	#menu:
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		getFontSelector: 	#font
		labelMorph: 	a LabelMorph(236987904)'Ok'
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	false


MouseButtonEvent>>sentTo:
	Receiver: [(843@453) mouseUp 188910 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableButtonMorph(335468288)
	Receiver's instance variables: 
		timeStamp: 	188910
		source: 	a HandMorph(986102528)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(843@453)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableButtonMorph(Morph)>>handleEvent:
	Receiver: a PluggableButtonMorph(335468288)
	Arguments and temporary variables: 
		anEvent: 	[(843@453) mouseUp 188910 nil]
	Receiver's instance variables: 
		bounds: 	(769.0@436.0) corner: (869.0@466.0)
		owner: 	a PanelMorph(1071747072)
		submorphs: 	an Array(an AlignmentMorph(502232320))
		fullBounds: 	nil
		color: 	(Color r: 0.2903225806451613 g: 0.2883675464320626 b: 0.2883675464320626...etc...
		extension: 	a MorphExtension (169478144) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a SpMorphicButtonAdapter
		label: 	'Ok'
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	#state
		actionSelector: 	#action
		font: 	nil
		getLabelSelector: 	#label
		getMenuSelector: 	#menu:
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		getFontSelector: 	#font
		labelMorph: 	a LabelMorph(236987904)'Ok'
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	false


PluggableButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a PluggableButtonMorph(335468288)
	Arguments and temporary variables: 
		anEvent: 	[(843@453) mouseUp 188910 nil]
	Receiver's instance variables: 
		bounds: 	(769.0@436.0) corner: (869.0@466.0)
		owner: 	a PanelMorph(1071747072)
		submorphs: 	an Array(an AlignmentMorph(502232320))
		fullBounds: 	nil
		color: 	(Color r: 0.2903225806451613 g: 0.2883675464320626 b: 0.2883675464320626...etc...
		extension: 	a MorphExtension (169478144) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a SpMorphicButtonAdapter
		label: 	'Ok'
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	#state
		actionSelector: 	#action
		font: 	nil
		getLabelSelector: 	#label
		getMenuSelector: 	#menu:
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		getFontSelector: 	#font
		labelMorph: 	a LabelMorph(236987904)'Ok'
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	false


[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(986102528)
	Arguments and temporary variables: 
		anEvent: 	[(843@453) mouseUp 188910 nil]
		focusHolder: 	a PluggableButtonMorph(335468288)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(603310592) [world]
		transformedEvent: 	[(843@453) mouseUp 188910 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(843@453) corner: (859@469)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	#()
		fullBounds: 	(843@453) corner: (859@469)
		color: 	Color blue
		extension: 	a MorphExtension (1065441536)
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(335468288)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(843@453) mouseUp 188910 nil]
		targetOffset: 	(74.0@17.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		lastKeyScanCode: 	nil
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		result := focusHolder handleFocusEvent: transformedEvent.
	]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
			ActiveWorld := priorWorld.
			ex pass ]
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	a CompiledBlock: [
		result := focusHolder handleFocusEvent: transform...etc...
		numArgs: 	0
		receiver: 	a HandMorph(986102528)


WorldMorph>>becomeActiveDuring:
	Receiver: a WorldMorph(603310592) [world]
	Arguments and temporary variables: 
		aBlock: 	[
		result := focusHolder handleFocusEvent: transformedEvent.
	]
		priorWorld: 	a WorldMorph(603310592) [world]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1512@851)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(1021235712) a TaskbarMorph(882262784) a SpDi...etc...
		fullBounds: 	(0@0) corner: (1512@851)
		color: 	(Color r: 0.29521016617790813 g: 0.29521016617790813 b: 0.29521016617790...etc...
		extension: 	a MorphExtension (219690240) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(986102528)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(843@453) mouseUp 188910 nil]
		focusHolder: 	a PluggableButtonMorph(335468288)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(603310592) [world]
		transformedEvent: 	[(843@453) mouseUp 188910 nil]
	Receiver's instance variables: 
		bounds: 	(843@453) corner: (859@469)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	#()
		fullBounds: 	(843@453) corner: (859@469)
		color: 	Color blue
		extension: 	a MorphExtension (1065441536)
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(335468288)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(843@453) mouseUp 188910 nil]
		targetOffset: 	(74.0@17.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		lastKeyScanCode: 	nil
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(986102528)
	Arguments and temporary variables: 
		anEvent: 	[(843@453) mouseUp 188910 nil]
		focusHolder: 	a PluggableButtonMorph(335468288)
		aBlock: 	[self mouseFocus: nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(843@453) corner: (859@469)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	#()
		fullBounds: 	(843@453) corner: (859@469)
		color: 	Color blue
		extension: 	a MorphExtension (1065441536)
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(335468288)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(843@453) mouseUp 188910 nil]
		targetOffset: 	(74.0@17.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		lastKeyScanCode: 	nil
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(986102528)
	Arguments and temporary variables: 
		anEvent: 	[(843@453) mouseUp 188910 nil]
	Receiver's instance variables: 
		bounds: 	(843@453) corner: (859@469)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	#()
		fullBounds: 	(843@453) corner: (859@469)
		color: 	Color blue
		extension: 	a MorphExtension (1065441536)
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(335468288)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(843@453) mouseUp 188910 nil]
		targetOffset: 	(74.0@17.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		lastKeyScanCode: 	nil
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>handleEvent:
	Receiver: a HandMorph(986102528)
	Arguments and temporary variables: 
		anEvent: 	[(843@453) mouseUp 188910 nil]
		evt: 	[(843@453) mouseUp 188910 nil]
	Receiver's instance variables: 
		bounds: 	(843@453) corner: (859@469)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	#()
		fullBounds: 	(843@453) corner: (859@469)
		color: 	Color blue
		extension: 	a MorphExtension (1065441536)
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(335468288)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(843@453) mouseUp 188910 nil]
		targetOffset: 	(74.0@17.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		lastKeyScanCode: 	nil
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
	Receiver: an OSWindowMorphicEventHandler
	Arguments and temporary variables: 
		anEvent: 	[(843@453) mouseUp 188910 nil]
	Receiver's instance variables: 
		morphicWorld: 	a WorldMorph(603310592) [world]


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(603310592) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(986102528))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	184678
		lastStepMessage: 	nil
		alarms: 	a Heap()
		lastAlarmTime: 	188889
		activeHand: 	a HandMorph(986102528)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1512@851)


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(603310592) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1512@851)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(1021235712) a TaskbarMorph(882262784) a SpDi...etc...
		fullBounds: 	(0@0) corner: (1512@851)
		color: 	(Color r: 0.29521016617790813 g: 0.29521016617790813 b: 0.29521016617790...etc...
		extension: 	a MorphExtension (219690240) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(603310592) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(986102528))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	184678
		lastStepMessage: 	nil
		alarms: 	a Heap()
		lastAlarmTime: 	188889
		activeHand: 	a HandMorph(986102528)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1512@851)


WorldMorph>>doOneCycleNow
	Receiver: a WorldMorph(603310592) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1512@851)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(1021235712) a TaskbarMorph(882262784) a SpDi...etc...
		fullBounds: 	(0@0) corner: (1512@851)
		color: 	(Color r: 0.29521016617790813 g: 0.29521016617790813 b: 0.29521016617790...etc...
		extension: 	a MorphExtension (219690240) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(603310592) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1512@851)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(1021235712) a TaskbarMorph(882262784) a SpDi...etc...
		fullBounds: 	(0@0) corner: (1512@851)
		color: 	(Color r: 0.29521016617790813 g: 0.29521016617790813 b: 0.29521016617790...etc...
		extension: 	a MorphExtension (219690240) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 
		extraWorldsToDraw: 	#()
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65547
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->nil #CursorOwnerWorld->a WorldMorph(60...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		announcer: 	nil
		displayScaleFactor: 	1


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extr...etc...
	Arguments and temporary variables: 
		aBlock: 	[
		self doInterCycleWait
	]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	WorldMorph class>>doOneCycle
		startpc: 	a CompiledBlock: [
		| extraWorldsToDraw |
		extraWorldsToDraw := Extr...etc...
		numArgs: 	0
		receiver: 	WorldMorph


WorldState class>>doDrawCycleWith:
	Receiver: WorldState
	Arguments and temporary variables: 
		aBlock: 	[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex cr...etc...
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#activeHand->WorldState>>#activeHand #activeHand...etc...
		format: 	65547
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldState}
		name: 	#WorldState
		classPool: 	a Dictionary(#CanSurrenderToOS->nil #DebugShowDamage->false #Deferre...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'


WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65547
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->nil #CursorOwnerWorld->a WorldMorph(60...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		announcer: 	nil
		displayScaleFactor: 	1


MorphicRenderLoop>>doOneCycle
	Receiver: a MorphicRenderLoop
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
a MorphicRenderLoop

MorphicRenderLoop>>doOneCycleWhile:
	Receiver: a MorphicRenderLoop
	Arguments and temporary variables: 
		aBlock: 	[ true ]
	Receiver's instance variables: 
a MorphicRenderLoop

[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		activeTranscript: 	nil



--- The full stack ---
IceTipLocalRepositoryPanel(Object)>>assert:description:
IceTipLocalRepositoryPanel>>validate
IceTipRegisterRepositoryDialog>>doAccept
[ self doAccept ] in IceTipRegisterRepositoryDialog(IceTipOptionDialog)>>initializeDialogWindow:
FullBlockClosure(BlockClosure)>>cull:
SpDialogWindowPresenter>>triggerOkAction
[ :presenter | 
			presenter triggerOkAction.
			presenter close ] in SpAbstractPresenter>>initializeDialogWindow:
FullBlockClosure(BlockClosure)>>cull:
[ aBlock cull: self ] in SpDialogWindowPresenter>>addButton:do:
SpButtonPresenter>>performAction
SpMorphicButtonAdapter>>action
PluggableButtonMorph>>performAction:
[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in PluggableButtonMorph>>mouseUp:
Array(SequenceableCollection)>>do:
PluggableButtonMorph>>mouseUp:
PluggableButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableButtonMorph(Morph)>>handleEvent:
PluggableButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
AssertionFailure: Project location does not seems to be a valid git repository.
26 September 2022 7:25:35.311349 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
StackToRegisterMappingCogit * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
v9.0.18 - Commit: 7249c170 - Date: 2022-09-02 14:31:12 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

IceTipLocalRepositoryPanel(Object)>>assert:description:
	Receiver: an IceTipLocalRepositoryPanel
	Arguments and temporary variables: 
		aBlock: 	false
		aStringOrBlock: 	'Project location does not seems to be a valid git repository.'...etc...
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	an IceTipRegisterRepositoryDialog
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		projectLocation: 	an IceTipDirectoryPresenter
		remoteLabel: 	nil
		remoteInputText: 	nil
		repository: 	nil


IceTipLocalRepositoryPanel>>validate
	Receiver: an IceTipLocalRepositoryPanel
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	an IceTipRegisterRepositoryDialog
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		projectLocation: 	an IceTipDirectoryPresenter
		remoteLabel: 	nil
		remoteInputText: 	nil
		repository: 	nil


IceTipRegisterRepositoryDialog>>doAccept
	Receiver: an IceTipRegisterRepositoryDialog
	Arguments and temporary variables: 
		newRepository: 	nil
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		owner: 	a SpDialogWindowPresenter
		adapter: 	a SpMorphicPanedAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a SpNullApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpPanedLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		typeList: 	a SpTablePresenter
		type: 	an IceTipLocalRepositoryPanel
		contentPanel: 	an IceTipLocalRepositoryPanel
		types: 	an OrderedCollection(an IceTipNewRepositoryPanel an IceTipLocalRepositor...etc...
		repository: 	nil
		acceptBlock: 	nil


[ self doAccept ] in IceTipRegisterRepositoryDialog(IceTipOptionDialog)>>initializeDialogWindow:
	Receiver: an IceTipRegisterRepositoryDialog
	Arguments and temporary variables: 
		aWindowPresenter: 	a SpDialogWindowPresenter
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		owner: 	a SpDialogWindowPresenter
		adapter: 	a SpMorphicPanedAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a SpNullApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpPanedLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		typeList: 	a SpTablePresenter
		type: 	an IceTipLocalRepositoryPanel
		contentPanel: 	an IceTipLocalRepositoryPanel
		types: 	an OrderedCollection(an IceTipNewRepositoryPanel an IceTipLocalRepositor...etc...
		repository: 	nil
		acceptBlock: 	nil


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ self doAccept ]
	Arguments and temporary variables: 
		anArg: 	a SpDialogWindowPresenter
	Receiver's instance variables: 
		outerContext: 	IceTipRegisterRepositoryDialog(IceTipOptionDialog)>>initializeDia...etc...
		startpc: 	a CompiledBlock: [ self doAccept ]
		numArgs: 	0
		receiver: 	an IceTipRegisterRepositoryDialog


SpDialogWindowPresenter>>triggerOkAction
	Receiver: a SpDialogWindowPresenter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicDialogWindowAdapter a SpDialogWindow(3...etc...
		announcer: 	an Announcer
		owner: 	nil
		adapter: 	a SpMorphicDialogWindowAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a SpNullApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ Form(16x16x32) ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ true ]
		titleHolder: 	an ObservableValueHolder[ 'Import from existing clone' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ nil ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		presenter: 	an ObservableValueHolder[ an IceTipRegisterRepositoryDialog ]
		initialPosition: 	an ObservableValueHolder[ nil ]
		initialExtent: 	an ObservableValueHolder[ (600@300) ]
		isResizeable: 	an ObservableValueHolder[ true ]
		menu: 	an ObservableValueHolder[ nil ]
		centered: 	an ObservableValueHolder[ false ]
		isClosed: 	an ObservableValueHolder[ false ]
		toolbar: 	an ObservableValueHolder[ nil ]
		statusbar: 	an ObservableValueHolder[ nil ]
		window: 	an ObservableValueHolder[ a SpDialogWindow(308885760) named: Import fro...etc...
		decorations: 	an ObservableValueHolder[ true ]
		buttons: 	an OrderedCollection(a SpButtonPresenter a SpButtonPresenter)
		okAction: 	[ self doAccept ]
		cancelAction: 	[ 
		cancelled := true.
		self close ]
		cancelled: 	true
		defaultButton: 	nil


[ :presenter | 
			presenter triggerOkAction.
			presenter close ] in SpAbstractPresenter>>initializeDialogWindow:
	Receiver: an IceTipRegisterRepositoryDialog
	Arguments and temporary variables: 
		aDialogWindowPresenter: 	a SpDialogWindowPresenter
		presenter: 	a SpDialogWindowPresenter
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		owner: 	a SpDialogWindowPresenter
		adapter: 	a SpMorphicPanedAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a SpNullApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpPanedLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		typeList: 	a SpTablePresenter
		type: 	an IceTipLocalRepositoryPanel
		contentPanel: 	an IceTipLocalRepositoryPanel
		types: 	an OrderedCollection(an IceTipNewRepositoryPanel an IceTipLocalRepositor...etc...
		repository: 	nil
		acceptBlock: 	nil


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ :presenter | 
			presenter triggerOkAction.
			presenter close ]
	Arguments and temporary variables: 
		anArg: 	a SpDialogWindowPresenter
	Receiver's instance variables: 
		outerContext: 	IceTipRegisterRepositoryDialog(SpAbstractPresenter)>>initializeDi...etc...
		startpc: 	a CompiledBlock: [ :presenter | 
			presenter triggerOkAction.
			pres...etc...
		numArgs: 	1
		receiver: 	an IceTipRegisterRepositoryDialog


[ aBlock cull: self ] in SpDialogWindowPresenter>>addButton:do:
	Receiver: a SpDialogWindowPresenter
	Arguments and temporary variables: 
		aString: 	'Ok'
		aBlock: 	[ :presenter | 
			presenter triggerOkAction.
			presenter close ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicDialogWindowAdapter a SpDialogWindow(3...etc...
		announcer: 	an Announcer
		owner: 	nil
		adapter: 	a SpMorphicDialogWindowAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a SpNullApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ Form(16x16x32) ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ true ]
		titleHolder: 	an ObservableValueHolder[ 'Import from existing clone' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ nil ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		presenter: 	an ObservableValueHolder[ an IceTipRegisterRepositoryDialog ]
		initialPosition: 	an ObservableValueHolder[ nil ]
		initialExtent: 	an ObservableValueHolder[ (600@300) ]
		isResizeable: 	an ObservableValueHolder[ true ]
		menu: 	an ObservableValueHolder[ nil ]
		centered: 	an ObservableValueHolder[ false ]
		isClosed: 	an ObservableValueHolder[ false ]
		toolbar: 	an ObservableValueHolder[ nil ]
		statusbar: 	an ObservableValueHolder[ nil ]
		window: 	an ObservableValueHolder[ a SpDialogWindow(308885760) named: Import fro...etc...
		decorations: 	an ObservableValueHolder[ true ]
		buttons: 	an OrderedCollection(a SpButtonPresenter a SpButtonPresenter)
		okAction: 	[ self doAccept ]
		cancelAction: 	[ 
		cancelled := true.
		self close ]
		cancelled: 	true
		defaultButton: 	nil


SpButtonPresenter>>performAction
	Receiver: a SpButtonPresenter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicButtonAdapter)
		announcer: 	an Announcer
		owner: 	a SpButtonBarPresenter
		adapter: 	a SpMorphicButtonAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Button' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		icon: 	an ObservableValueHolder[ nil ]
		label: 	an ObservableValueHolder[ 'Ok' ]
		action: 	an ObservableValueHolder[ [ aBlock cull: self ] ]
		actionPerformed: 	an ObservableValueHolder[ nil ]
		askBeforeChanging: 	an ObservableValueHolder[ false ]
		font: 	an ObservableValueHolder[ nil ]
		shortcut: 	an ObservableValueHolder[ nil ]
		state: 	an ObservableValueHolder[ false ]
		contextMenu: 	an ObservableValueHolder[ nil ]


SpMorphicButtonAdapter>>action
	Receiver: a SpMorphicButtonAdapter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a PluggableButtonMorph(335468288))
		announcer: 	nil
		model: 	a SpButtonPresenter
		widget: 	a PluggableButtonMorph(335468288)
		selector: 	nil
		owner: 	a SpButtonPresenter
		subMenuWidget: 	nil
		styleName: 	nil


PluggableButtonMorph>>performAction:
	Receiver: a PluggableButtonMorph(335468288)
	Arguments and temporary variables: 
		event: 	[(843@453) mouseUp 188910 nil]
	Receiver's instance variables: 
		bounds: 	(769.0@436.0) corner: (869.0@466.0)
		owner: 	a PanelMorph(1071747072)
		submorphs: 	an Array(an AlignmentMorph(502232320))
		fullBounds: 	nil
		color: 	(Color r: 0.2903225806451613 g: 0.2883675464320626 b: 0.2883675464320626...etc...
		extension: 	a MorphExtension (169478144) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a SpMorphicButtonAdapter
		label: 	'Ok'
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	#state
		actionSelector: 	#action
		font: 	nil
		getLabelSelector: 	#label
		getMenuSelector: 	#menu:
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		getFontSelector: 	#font
		labelMorph: 	a LabelMorph(236987904)'Ok'
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	false


[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(335468288)
	Arguments and temporary variables: 
		evt: 	[(843@453) mouseUp 188910 nil]
		all: 	an Array(a PluggableButtonMorph(857193472) a PluggableButtonMorph(33546828...etc...
		m: 	a PluggableButtonMorph(335468288)
	Receiver's instance variables: 
		bounds: 	(769.0@436.0) corner: (869.0@466.0)
		owner: 	a PanelMorph(1071747072)
		submorphs: 	an Array(an AlignmentMorph(502232320))
		fullBounds: 	nil
		color: 	(Color r: 0.2903225806451613 g: 0.2883675464320626 b: 0.2883675464320626...etc...
		extension: 	a MorphExtension (169478144) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a SpMorphicButtonAdapter
		label: 	'Ok'
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	#state
		actionSelector: 	#action
		font: 	nil
		getLabelSelector: 	#label
		getMenuSelector: 	#menu:
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		getFontSelector: 	#font
		labelMorph: 	a LabelMorph(236987904)'Ok'
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	false


Array(SequenceableCollection)>>do:
	Receiver: an Array(a PluggableButtonMorph(857193472) a PluggableButtonMorph(335468288))
	Arguments and temporary variables: 
		aBlock: 	[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [...etc...
		index: 	2
	Receiver's instance variables: 
an Array(a PluggableButtonMorph(857193472) a PluggableButtonMorph(335468288))

PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(335468288)
	Arguments and temporary variables: 
		evt: 	[(843@453) mouseUp 188910 nil]
		all: 	an Array(a PluggableButtonMorph(857193472) a PluggableButtonMorph(33546828...etc...
	Receiver's instance variables: 
		bounds: 	(769.0@436.0) corner: (869.0@466.0)
		owner: 	a PanelMorph(1071747072)
		submorphs: 	an Array(an AlignmentMorph(502232320))
		fullBounds: 	nil
		color: 	(Color r: 0.2903225806451613 g: 0.2883675464320626 b: 0.2883675464320626...etc...
		extension: 	a MorphExtension (169478144) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a SpMorphicButtonAdapter
		label: 	'Ok'
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	#state
		actionSelector: 	#action
		font: 	nil
		getLabelSelector: 	#label
		getMenuSelector: 	#menu:
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		getFontSelector: 	#font
		labelMorph: 	a LabelMorph(236987904)'Ok'
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	false


PluggableButtonMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableButtonMorph(335468288)
	Arguments and temporary variables: 
		anEvent: 	[(843@453) mouseUp 188910 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(769.0@436.0) corner: (869.0@466.0)
		owner: 	a PanelMorph(1071747072)
		submorphs: 	an Array(an AlignmentMorph(502232320))
		fullBounds: 	nil
		color: 	(Color r: 0.2903225806451613 g: 0.2883675464320626 b: 0.2883675464320626...etc...
		extension: 	a MorphExtension (169478144) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a SpMorphicButtonAdapter
		label: 	'Ok'
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	#state
		actionSelector: 	#action
		font: 	nil
		getLabelSelector: 	#label
		getMenuSelector: 	#menu:
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		getFontSelector: 	#font
		labelMorph: 	a LabelMorph(236987904)'Ok'
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	false


MouseButtonEvent>>sentTo:
	Receiver: [(843@453) mouseUp 188910 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableButtonMorph(335468288)
	Receiver's instance variables: 
		timeStamp: 	188910
		source: 	a HandMorph(986102528)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(843@453)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableButtonMorph(Morph)>>handleEvent:
	Receiver: a PluggableButtonMorph(335468288)
	Arguments and temporary variables: 
		anEvent: 	[(843@453) mouseUp 188910 nil]
	Receiver's instance variables: 
		bounds: 	(769.0@436.0) corner: (869.0@466.0)
		owner: 	a PanelMorph(1071747072)
		submorphs: 	an Array(an AlignmentMorph(502232320))
		fullBounds: 	nil
		color: 	(Color r: 0.2903225806451613 g: 0.2883675464320626 b: 0.2883675464320626...etc...
		extension: 	a MorphExtension (169478144) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a SpMorphicButtonAdapter
		label: 	'Ok'
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	#state
		actionSelector: 	#action
		font: 	nil
		getLabelSelector: 	#label
		getMenuSelector: 	#menu:
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		getFontSelector: 	#font
		labelMorph: 	a LabelMorph(236987904)'Ok'
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	false


PluggableButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a PluggableButtonMorph(335468288)
	Arguments and temporary variables: 
		anEvent: 	[(843@453) mouseUp 188910 nil]
	Receiver's instance variables: 
		bounds: 	(769.0@436.0) corner: (869.0@466.0)
		owner: 	a PanelMorph(1071747072)
		submorphs: 	an Array(an AlignmentMorph(502232320))
		fullBounds: 	nil
		color: 	(Color r: 0.2903225806451613 g: 0.2883675464320626 b: 0.2883675464320626...etc...
		extension: 	a MorphExtension (169478144) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a SpMorphicButtonAdapter
		label: 	'Ok'
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	#state
		actionSelector: 	#action
		font: 	nil
		getLabelSelector: 	#label
		getMenuSelector: 	#menu:
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		getFontSelector: 	#font
		labelMorph: 	a LabelMorph(236987904)'Ok'
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	false


[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(986102528)
	Arguments and temporary variables: 
		anEvent: 	[(843@453) mouseUp 188910 nil]
		focusHolder: 	a PluggableButtonMorph(335468288)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(603310592) [world]
		transformedEvent: 	[(843@453) mouseUp 188910 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(843@453) corner: (859@469)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	#()
		fullBounds: 	(843@453) corner: (859@469)
		color: 	Color blue
		extension: 	a MorphExtension (1065441536)
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(335468288)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(843@453) mouseUp 188910 nil]
		targetOffset: 	(74.0@17.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		lastKeyScanCode: 	nil
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		result := focusHolder handleFocusEvent: transformedEvent.
	]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
			ActiveWorld := priorWorld.
			ex pass ]
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	a CompiledBlock: [
		result := focusHolder handleFocusEvent: transform...etc...
		numArgs: 	0
		receiver: 	a HandMorph(986102528)


WorldMorph>>becomeActiveDuring:
	Receiver: a WorldMorph(603310592) [world]
	Arguments and temporary variables: 
		aBlock: 	[
		result := focusHolder handleFocusEvent: transformedEvent.
	]
		priorWorld: 	a WorldMorph(603310592) [world]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1512@851)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(1021235712) a TaskbarMorph(882262784) a SpDi...etc...
		fullBounds: 	(0@0) corner: (1512@851)
		color: 	(Color r: 0.29521016617790813 g: 0.29521016617790813 b: 0.29521016617790...etc...
		extension: 	a MorphExtension (219690240) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(986102528)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(843@453) mouseUp 188910 nil]
		focusHolder: 	a PluggableButtonMorph(335468288)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(603310592) [world]
		transformedEvent: 	[(843@453) mouseUp 188910 nil]
	Receiver's instance variables: 
		bounds: 	(843@453) corner: (859@469)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	#()
		fullBounds: 	(843@453) corner: (859@469)
		color: 	Color blue
		extension: 	a MorphExtension (1065441536)
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(335468288)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(843@453) mouseUp 188910 nil]
		targetOffset: 	(74.0@17.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		lastKeyScanCode: 	nil
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(986102528)
	Arguments and temporary variables: 
		anEvent: 	[(843@453) mouseUp 188910 nil]
		focusHolder: 	a PluggableButtonMorph(335468288)
		aBlock: 	[self mouseFocus: nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(843@453) corner: (859@469)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	#()
		fullBounds: 	(843@453) corner: (859@469)
		color: 	Color blue
		extension: 	a MorphExtension (1065441536)
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(335468288)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(843@453) mouseUp 188910 nil]
		targetOffset: 	(74.0@17.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		lastKeyScanCode: 	nil
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(986102528)
	Arguments and temporary variables: 
		anEvent: 	[(843@453) mouseUp 188910 nil]
	Receiver's instance variables: 
		bounds: 	(843@453) corner: (859@469)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	#()
		fullBounds: 	(843@453) corner: (859@469)
		color: 	Color blue
		extension: 	a MorphExtension (1065441536)
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(335468288)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(843@453) mouseUp 188910 nil]
		targetOffset: 	(74.0@17.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		lastKeyScanCode: 	nil
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>handleEvent:
	Receiver: a HandMorph(986102528)
	Arguments and temporary variables: 
		anEvent: 	[(843@453) mouseUp 188910 nil]
		evt: 	[(843@453) mouseUp 188910 nil]
	Receiver's instance variables: 
		bounds: 	(843@453) corner: (859@469)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	#()
		fullBounds: 	(843@453) corner: (859@469)
		color: 	Color blue
		extension: 	a MorphExtension (1065441536)
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(335468288)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(843@453) mouseUp 188910 nil]
		targetOffset: 	(74.0@17.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		lastKeyScanCode: 	nil
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
	Receiver: an OSWindowMorphicEventHandler
	Arguments and temporary variables: 
		anEvent: 	[(843@453) mouseUp 188910 nil]
	Receiver's instance variables: 
		morphicWorld: 	a WorldMorph(603310592) [world]


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(603310592) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(986102528))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	184678
		lastStepMessage: 	nil
		alarms: 	a Heap()
		lastAlarmTime: 	188889
		activeHand: 	a HandMorph(986102528)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1512@851)


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(603310592) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1512@851)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(1021235712) a TaskbarMorph(882262784) a SpDi...etc...
		fullBounds: 	(0@0) corner: (1512@851)
		color: 	(Color r: 0.29521016617790813 g: 0.29521016617790813 b: 0.29521016617790...etc...
		extension: 	a MorphExtension (219690240) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(603310592) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(986102528))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	184678
		lastStepMessage: 	nil
		alarms: 	a Heap()
		lastAlarmTime: 	188889
		activeHand: 	a HandMorph(986102528)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1512@851)


WorldMorph>>doOneCycleNow
	Receiver: a WorldMorph(603310592) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1512@851)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(1021235712) a TaskbarMorph(882262784) a SpDi...etc...
		fullBounds: 	(0@0) corner: (1512@851)
		color: 	(Color r: 0.29521016617790813 g: 0.29521016617790813 b: 0.29521016617790...etc...
		extension: 	a MorphExtension (219690240) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(603310592) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1512@851)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(1021235712) a TaskbarMorph(882262784) a SpDi...etc...
		fullBounds: 	(0@0) corner: (1512@851)
		color: 	(Color r: 0.29521016617790813 g: 0.29521016617790813 b: 0.29521016617790...etc...
		extension: 	a MorphExtension (219690240) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 
		extraWorldsToDraw: 	#()
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65547
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->nil #CursorOwnerWorld->a WorldMorph(60...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		announcer: 	nil
		displayScaleFactor: 	1


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extr...etc...
	Arguments and temporary variables: 
		aBlock: 	[
		self doInterCycleWait
	]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	WorldMorph class>>doOneCycle
		startpc: 	a CompiledBlock: [
		| extraWorldsToDraw |
		extraWorldsToDraw := Extr...etc...
		numArgs: 	0
		receiver: 	WorldMorph


WorldState class>>doDrawCycleWith:
	Receiver: WorldState
	Arguments and temporary variables: 
		aBlock: 	[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex cr...etc...
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#activeHand->WorldState>>#activeHand #activeHand...etc...
		format: 	65547
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldState}
		name: 	#WorldState
		classPool: 	a Dictionary(#CanSurrenderToOS->nil #DebugShowDamage->false #Deferre...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'


WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65547
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->nil #CursorOwnerWorld->a WorldMorph(60...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		announcer: 	nil
		displayScaleFactor: 	1


MorphicRenderLoop>>doOneCycle
	Receiver: a MorphicRenderLoop
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
a MorphicRenderLoop

MorphicRenderLoop>>doOneCycleWhile:
	Receiver: a MorphicRenderLoop
	Arguments and temporary variables: 
		aBlock: 	[ true ]
	Receiver's instance variables: 
a MorphicRenderLoop

[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		activeTranscript: 	nil



--- The full stack ---
IceTipLocalRepositoryPanel(Object)>>assert:description:
IceTipLocalRepositoryPanel>>validate
IceTipRegisterRepositoryDialog>>doAccept
[ self doAccept ] in IceTipRegisterRepositoryDialog(IceTipOptionDialog)>>initializeDialogWindow:
FullBlockClosure(BlockClosure)>>cull:
SpDialogWindowPresenter>>triggerOkAction
[ :presenter | 
			presenter triggerOkAction.
			presenter close ] in SpAbstractPresenter>>initializeDialogWindow:
FullBlockClosure(BlockClosure)>>cull:
[ aBlock cull: self ] in SpDialogWindowPresenter>>addButton:do:
SpButtonPresenter>>performAction
SpMorphicButtonAdapter>>action
PluggableButtonMorph>>performAction:
[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in PluggableButtonMorph>>mouseUp:
Array(SequenceableCollection)>>do:
PluggableButtonMorph>>mouseUp:
PluggableButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableButtonMorph(Morph)>>handleEvent:
PluggableButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
AssertionFailure: Project location does not seems to be a valid git repository.
26 September 2022 7:26:06.688621 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
StackToRegisterMappingCogit * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
v9.0.18 - Commit: 7249c170 - Date: 2022-09-02 14:31:12 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

IceTipLocalRepositoryPanel(Object)>>assert:description:
	Receiver: an IceTipLocalRepositoryPanel
	Arguments and temporary variables: 
		aBlock: 	false
		aStringOrBlock: 	'Project location does not seems to be a valid git repository.'...etc...
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	an IceTipRegisterRepositoryDialog
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		projectLocation: 	an IceTipDirectoryPresenter
		remoteLabel: 	nil
		remoteInputText: 	nil
		repository: 	nil


IceTipLocalRepositoryPanel>>validate
	Receiver: an IceTipLocalRepositoryPanel
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	an IceTipRegisterRepositoryDialog
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		projectLocation: 	an IceTipDirectoryPresenter
		remoteLabel: 	nil
		remoteInputText: 	nil
		repository: 	nil


IceTipRegisterRepositoryDialog>>doAccept
	Receiver: an IceTipRegisterRepositoryDialog
	Arguments and temporary variables: 
		newRepository: 	nil
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		owner: 	a SpDialogWindowPresenter
		adapter: 	a SpMorphicPanedAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a SpNullApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpPanedLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		typeList: 	a SpTablePresenter
		type: 	an IceTipLocalRepositoryPanel
		contentPanel: 	an IceTipLocalRepositoryPanel
		types: 	an OrderedCollection(an IceTipNewRepositoryPanel an IceTipLocalRepositor...etc...
		repository: 	nil
		acceptBlock: 	nil


[ self doAccept ] in IceTipRegisterRepositoryDialog(IceTipOptionDialog)>>initializeDialogWindow:
	Receiver: an IceTipRegisterRepositoryDialog
	Arguments and temporary variables: 
		aWindowPresenter: 	a SpDialogWindowPresenter
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		owner: 	a SpDialogWindowPresenter
		adapter: 	a SpMorphicPanedAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a SpNullApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpPanedLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		typeList: 	a SpTablePresenter
		type: 	an IceTipLocalRepositoryPanel
		contentPanel: 	an IceTipLocalRepositoryPanel
		types: 	an OrderedCollection(an IceTipNewRepositoryPanel an IceTipLocalRepositor...etc...
		repository: 	nil
		acceptBlock: 	nil


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ self doAccept ]
	Arguments and temporary variables: 
		anArg: 	a SpDialogWindowPresenter
	Receiver's instance variables: 
		outerContext: 	IceTipRegisterRepositoryDialog(IceTipOptionDialog)>>initializeDia...etc...
		startpc: 	a CompiledBlock: [ self doAccept ]
		numArgs: 	0
		receiver: 	an IceTipRegisterRepositoryDialog


SpDialogWindowPresenter>>triggerOkAction
	Receiver: a SpDialogWindowPresenter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicDialogWindowAdapter a SpDialogWindow(3...etc...
		announcer: 	an Announcer
		owner: 	nil
		adapter: 	a SpMorphicDialogWindowAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a SpNullApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ Form(16x16x32) ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ true ]
		titleHolder: 	an ObservableValueHolder[ 'Import from existing clone' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ nil ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		presenter: 	an ObservableValueHolder[ an IceTipRegisterRepositoryDialog ]
		initialPosition: 	an ObservableValueHolder[ nil ]
		initialExtent: 	an ObservableValueHolder[ (600@300) ]
		isResizeable: 	an ObservableValueHolder[ true ]
		menu: 	an ObservableValueHolder[ nil ]
		centered: 	an ObservableValueHolder[ false ]
		isClosed: 	an ObservableValueHolder[ false ]
		toolbar: 	an ObservableValueHolder[ nil ]
		statusbar: 	an ObservableValueHolder[ nil ]
		window: 	an ObservableValueHolder[ a SpDialogWindow(308885760) named: Import fro...etc...
		decorations: 	an ObservableValueHolder[ true ]
		buttons: 	an OrderedCollection(a SpButtonPresenter a SpButtonPresenter)
		okAction: 	[ self doAccept ]
		cancelAction: 	[ 
		cancelled := true.
		self close ]
		cancelled: 	true
		defaultButton: 	nil


[ :presenter | 
			presenter triggerOkAction.
			presenter close ] in SpAbstractPresenter>>initializeDialogWindow:
	Receiver: an IceTipRegisterRepositoryDialog
	Arguments and temporary variables: 
		aDialogWindowPresenter: 	a SpDialogWindowPresenter
		presenter: 	a SpDialogWindowPresenter
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		owner: 	a SpDialogWindowPresenter
		adapter: 	a SpMorphicPanedAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a SpNullApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpPanedLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		typeList: 	a SpTablePresenter
		type: 	an IceTipLocalRepositoryPanel
		contentPanel: 	an IceTipLocalRepositoryPanel
		types: 	an OrderedCollection(an IceTipNewRepositoryPanel an IceTipLocalRepositor...etc...
		repository: 	nil
		acceptBlock: 	nil


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ :presenter | 
			presenter triggerOkAction.
			presenter close ]
	Arguments and temporary variables: 
		anArg: 	a SpDialogWindowPresenter
	Receiver's instance variables: 
		outerContext: 	IceTipRegisterRepositoryDialog(SpAbstractPresenter)>>initializeDi...etc...
		startpc: 	a CompiledBlock: [ :presenter | 
			presenter triggerOkAction.
			pres...etc...
		numArgs: 	1
		receiver: 	an IceTipRegisterRepositoryDialog


[ aBlock cull: self ] in SpDialogWindowPresenter>>addButton:do:
	Receiver: a SpDialogWindowPresenter
	Arguments and temporary variables: 
		aString: 	'Ok'
		aBlock: 	[ :presenter | 
			presenter triggerOkAction.
			presenter close ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicDialogWindowAdapter a SpDialogWindow(3...etc...
		announcer: 	an Announcer
		owner: 	nil
		adapter: 	a SpMorphicDialogWindowAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a SpNullApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ Form(16x16x32) ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ true ]
		titleHolder: 	an ObservableValueHolder[ 'Import from existing clone' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ nil ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		presenter: 	an ObservableValueHolder[ an IceTipRegisterRepositoryDialog ]
		initialPosition: 	an ObservableValueHolder[ nil ]
		initialExtent: 	an ObservableValueHolder[ (600@300) ]
		isResizeable: 	an ObservableValueHolder[ true ]
		menu: 	an ObservableValueHolder[ nil ]
		centered: 	an ObservableValueHolder[ false ]
		isClosed: 	an ObservableValueHolder[ false ]
		toolbar: 	an ObservableValueHolder[ nil ]
		statusbar: 	an ObservableValueHolder[ nil ]
		window: 	an ObservableValueHolder[ a SpDialogWindow(308885760) named: Import fro...etc...
		decorations: 	an ObservableValueHolder[ true ]
		buttons: 	an OrderedCollection(a SpButtonPresenter a SpButtonPresenter)
		okAction: 	[ self doAccept ]
		cancelAction: 	[ 
		cancelled := true.
		self close ]
		cancelled: 	true
		defaultButton: 	nil


SpButtonPresenter>>performAction
	Receiver: a SpButtonPresenter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicButtonAdapter)
		announcer: 	an Announcer
		owner: 	a SpButtonBarPresenter
		adapter: 	a SpMorphicButtonAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Button' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		icon: 	an ObservableValueHolder[ nil ]
		label: 	an ObservableValueHolder[ 'Ok' ]
		action: 	an ObservableValueHolder[ [ aBlock cull: self ] ]
		actionPerformed: 	an ObservableValueHolder[ nil ]
		askBeforeChanging: 	an ObservableValueHolder[ false ]
		font: 	an ObservableValueHolder[ nil ]
		shortcut: 	an ObservableValueHolder[ nil ]
		state: 	an ObservableValueHolder[ false ]
		contextMenu: 	an ObservableValueHolder[ nil ]


SpMorphicButtonAdapter>>action
	Receiver: a SpMorphicButtonAdapter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a PluggableButtonMorph(335468288))
		announcer: 	nil
		model: 	a SpButtonPresenter
		widget: 	a PluggableButtonMorph(335468288)
		selector: 	nil
		owner: 	a SpButtonPresenter
		subMenuWidget: 	nil
		styleName: 	nil


PluggableButtonMorph>>performAction:
	Receiver: a PluggableButtonMorph(335468288)
	Arguments and temporary variables: 
		event: 	[(823@441) mouseUp 220343 nil]
	Receiver's instance variables: 
		bounds: 	(769.0@436.0) corner: (869.0@466.0)
		owner: 	a PanelMorph(1071747072)
		submorphs: 	an Array(an AlignmentMorph(502232320))
		fullBounds: 	nil
		color: 	(Color r: 0.2903225806451613 g: 0.2883675464320626 b: 0.2883675464320626...etc...
		extension: 	a MorphExtension (169478144) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a SpMorphicButtonAdapter
		label: 	'Ok'
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	#state
		actionSelector: 	#action
		font: 	nil
		getLabelSelector: 	#label
		getMenuSelector: 	#menu:
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		getFontSelector: 	#font
		labelMorph: 	a LabelMorph(236987904)'Ok'
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	false


[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(335468288)
	Arguments and temporary variables: 
		evt: 	[(823@441) mouseUp 220343 nil]
		all: 	an Array(a PluggableButtonMorph(857193472) a PluggableButtonMorph(33546828...etc...
		m: 	a PluggableButtonMorph(335468288)
	Receiver's instance variables: 
		bounds: 	(769.0@436.0) corner: (869.0@466.0)
		owner: 	a PanelMorph(1071747072)
		submorphs: 	an Array(an AlignmentMorph(502232320))
		fullBounds: 	nil
		color: 	(Color r: 0.2903225806451613 g: 0.2883675464320626 b: 0.2883675464320626...etc...
		extension: 	a MorphExtension (169478144) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a SpMorphicButtonAdapter
		label: 	'Ok'
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	#state
		actionSelector: 	#action
		font: 	nil
		getLabelSelector: 	#label
		getMenuSelector: 	#menu:
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		getFontSelector: 	#font
		labelMorph: 	a LabelMorph(236987904)'Ok'
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	false


Array(SequenceableCollection)>>do:
	Receiver: an Array(a PluggableButtonMorph(857193472) a PluggableButtonMorph(335468288))
	Arguments and temporary variables: 
		aBlock: 	[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [...etc...
		index: 	2
	Receiver's instance variables: 
an Array(a PluggableButtonMorph(857193472) a PluggableButtonMorph(335468288))

PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(335468288)
	Arguments and temporary variables: 
		evt: 	[(823@441) mouseUp 220343 nil]
		all: 	an Array(a PluggableButtonMorph(857193472) a PluggableButtonMorph(33546828...etc...
	Receiver's instance variables: 
		bounds: 	(769.0@436.0) corner: (869.0@466.0)
		owner: 	a PanelMorph(1071747072)
		submorphs: 	an Array(an AlignmentMorph(502232320))
		fullBounds: 	nil
		color: 	(Color r: 0.2903225806451613 g: 0.2883675464320626 b: 0.2883675464320626...etc...
		extension: 	a MorphExtension (169478144) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a SpMorphicButtonAdapter
		label: 	'Ok'
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	#state
		actionSelector: 	#action
		font: 	nil
		getLabelSelector: 	#label
		getMenuSelector: 	#menu:
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		getFontSelector: 	#font
		labelMorph: 	a LabelMorph(236987904)'Ok'
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	false


PluggableButtonMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableButtonMorph(335468288)
	Arguments and temporary variables: 
		anEvent: 	[(823@441) mouseUp 220343 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(769.0@436.0) corner: (869.0@466.0)
		owner: 	a PanelMorph(1071747072)
		submorphs: 	an Array(an AlignmentMorph(502232320))
		fullBounds: 	nil
		color: 	(Color r: 0.2903225806451613 g: 0.2883675464320626 b: 0.2883675464320626...etc...
		extension: 	a MorphExtension (169478144) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a SpMorphicButtonAdapter
		label: 	'Ok'
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	#state
		actionSelector: 	#action
		font: 	nil
		getLabelSelector: 	#label
		getMenuSelector: 	#menu:
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		getFontSelector: 	#font
		labelMorph: 	a LabelMorph(236987904)'Ok'
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	false


MouseButtonEvent>>sentTo:
	Receiver: [(823@441) mouseUp 220343 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableButtonMorph(335468288)
	Receiver's instance variables: 
		timeStamp: 	220343
		source: 	a HandMorph(986102528)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(823@441)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableButtonMorph(Morph)>>handleEvent:
	Receiver: a PluggableButtonMorph(335468288)
	Arguments and temporary variables: 
		anEvent: 	[(823@441) mouseUp 220343 nil]
	Receiver's instance variables: 
		bounds: 	(769.0@436.0) corner: (869.0@466.0)
		owner: 	a PanelMorph(1071747072)
		submorphs: 	an Array(an AlignmentMorph(502232320))
		fullBounds: 	nil
		color: 	(Color r: 0.2903225806451613 g: 0.2883675464320626 b: 0.2883675464320626...etc...
		extension: 	a MorphExtension (169478144) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a SpMorphicButtonAdapter
		label: 	'Ok'
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	#state
		actionSelector: 	#action
		font: 	nil
		getLabelSelector: 	#label
		getMenuSelector: 	#menu:
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		getFontSelector: 	#font
		labelMorph: 	a LabelMorph(236987904)'Ok'
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	false


PluggableButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a PluggableButtonMorph(335468288)
	Arguments and temporary variables: 
		anEvent: 	[(823@441) mouseUp 220343 nil]
	Receiver's instance variables: 
		bounds: 	(769.0@436.0) corner: (869.0@466.0)
		owner: 	a PanelMorph(1071747072)
		submorphs: 	an Array(an AlignmentMorph(502232320))
		fullBounds: 	nil
		color: 	(Color r: 0.2903225806451613 g: 0.2883675464320626 b: 0.2883675464320626...etc...
		extension: 	a MorphExtension (169478144) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a SpMorphicButtonAdapter
		label: 	'Ok'
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	#state
		actionSelector: 	#action
		font: 	nil
		getLabelSelector: 	#label
		getMenuSelector: 	#menu:
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		getFontSelector: 	#font
		labelMorph: 	a LabelMorph(236987904)'Ok'
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	false


[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(986102528)
	Arguments and temporary variables: 
		anEvent: 	[(823@441) mouseUp 220343 nil]
		focusHolder: 	a PluggableButtonMorph(335468288)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(603310592) [world]
		transformedEvent: 	[(823@441) mouseUp 220343 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(823@441) corner: (839@457)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	#()
		fullBounds: 	(823@441) corner: (839@457)
		color: 	Color blue
		extension: 	a MorphExtension (1065441536)
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(335468288)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(823@441) mouseUp 220343 nil]
		targetOffset: 	(54.0@5.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		lastKeyScanCode: 	nil
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		result := focusHolder handleFocusEvent: transformedEvent.
	]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
			ActiveWorld := priorWorld.
			ex pass ]
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	a CompiledBlock: [
		result := focusHolder handleFocusEvent: transform...etc...
		numArgs: 	0
		receiver: 	a HandMorph(986102528)


WorldMorph>>becomeActiveDuring:
	Receiver: a WorldMorph(603310592) [world]
	Arguments and temporary variables: 
		aBlock: 	[
		result := focusHolder handleFocusEvent: transformedEvent.
	]
		priorWorld: 	a WorldMorph(603310592) [world]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1512@851)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(1021235712) a TaskbarMorph(882262784) a SpDi...etc...
		fullBounds: 	(0@0) corner: (1512@851)
		color: 	(Color r: 0.29521016617790813 g: 0.29521016617790813 b: 0.29521016617790...etc...
		extension: 	a MorphExtension (219690240) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(986102528)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(823@441) mouseUp 220343 nil]
		focusHolder: 	a PluggableButtonMorph(335468288)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(603310592) [world]
		transformedEvent: 	[(823@441) mouseUp 220343 nil]
	Receiver's instance variables: 
		bounds: 	(823@441) corner: (839@457)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	#()
		fullBounds: 	(823@441) corner: (839@457)
		color: 	Color blue
		extension: 	a MorphExtension (1065441536)
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(335468288)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(823@441) mouseUp 220343 nil]
		targetOffset: 	(54.0@5.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		lastKeyScanCode: 	nil
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(986102528)
	Arguments and temporary variables: 
		anEvent: 	[(823@441) mouseUp 220343 nil]
		focusHolder: 	a PluggableButtonMorph(335468288)
		aBlock: 	[self mouseFocus: nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(823@441) corner: (839@457)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	#()
		fullBounds: 	(823@441) corner: (839@457)
		color: 	Color blue
		extension: 	a MorphExtension (1065441536)
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(335468288)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(823@441) mouseUp 220343 nil]
		targetOffset: 	(54.0@5.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		lastKeyScanCode: 	nil
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(986102528)
	Arguments and temporary variables: 
		anEvent: 	[(823@441) mouseUp 220343 nil]
	Receiver's instance variables: 
		bounds: 	(823@441) corner: (839@457)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	#()
		fullBounds: 	(823@441) corner: (839@457)
		color: 	Color blue
		extension: 	a MorphExtension (1065441536)
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(335468288)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(823@441) mouseUp 220343 nil]
		targetOffset: 	(54.0@5.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		lastKeyScanCode: 	nil
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>handleEvent:
	Receiver: a HandMorph(986102528)
	Arguments and temporary variables: 
		anEvent: 	[(823@441) mouseUp 220343 nil]
		evt: 	[(823@441) mouseUp 220343 nil]
	Receiver's instance variables: 
		bounds: 	(823@441) corner: (839@457)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	#()
		fullBounds: 	(823@441) corner: (839@457)
		color: 	Color blue
		extension: 	a MorphExtension (1065441536)
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(335468288)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(823@441) mouseUp 220343 nil]
		targetOffset: 	(54.0@5.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		lastKeyScanCode: 	nil
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
	Receiver: an OSWindowMorphicEventHandler
	Arguments and temporary variables: 
		anEvent: 	[(823@441) mouseUp 220343 nil]
	Receiver's instance variables: 
		morphicWorld: 	a WorldMorph(603310592) [world]


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(603310592) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(986102528))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	184678
		lastStepMessage: 	nil
		alarms: 	a Heap()
		lastAlarmTime: 	220330
		activeHand: 	a HandMorph(986102528)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1512@851)


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(603310592) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1512@851)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(1021235712) a TaskbarMorph(882262784) a SpDi...etc...
		fullBounds: 	(0@0) corner: (1512@851)
		color: 	(Color r: 0.29521016617790813 g: 0.29521016617790813 b: 0.29521016617790...etc...
		extension: 	a MorphExtension (219690240) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(603310592) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(986102528))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	184678
		lastStepMessage: 	nil
		alarms: 	a Heap()
		lastAlarmTime: 	220330
		activeHand: 	a HandMorph(986102528)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1512@851)


WorldMorph>>doOneCycleNow
	Receiver: a WorldMorph(603310592) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1512@851)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(1021235712) a TaskbarMorph(882262784) a SpDi...etc...
		fullBounds: 	(0@0) corner: (1512@851)
		color: 	(Color r: 0.29521016617790813 g: 0.29521016617790813 b: 0.29521016617790...etc...
		extension: 	a MorphExtension (219690240) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(603310592) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1512@851)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(1021235712) a TaskbarMorph(882262784) a SpDi...etc...
		fullBounds: 	(0@0) corner: (1512@851)
		color: 	(Color r: 0.29521016617790813 g: 0.29521016617790813 b: 0.29521016617790...etc...
		extension: 	a MorphExtension (219690240) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 
		extraWorldsToDraw: 	#()
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65547
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->nil #CursorOwnerWorld->a WorldMorph(60...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		announcer: 	nil
		displayScaleFactor: 	1


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extr...etc...
	Arguments and temporary variables: 
		aBlock: 	[
		self doInterCycleWait
	]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	WorldMorph class>>doOneCycle
		startpc: 	a CompiledBlock: [
		| extraWorldsToDraw |
		extraWorldsToDraw := Extr...etc...
		numArgs: 	0
		receiver: 	WorldMorph


WorldState class>>doDrawCycleWith:
	Receiver: WorldState
	Arguments and temporary variables: 
		aBlock: 	[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex cr...etc...
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#activeHand->WorldState>>#activeHand #activeHand...etc...
		format: 	65547
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldState}
		name: 	#WorldState
		classPool: 	a Dictionary(#CanSurrenderToOS->nil #DebugShowDamage->false #Deferre...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'


WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65547
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->nil #CursorOwnerWorld->a WorldMorph(60...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		announcer: 	nil
		displayScaleFactor: 	1


MorphicRenderLoop>>doOneCycle
	Receiver: a MorphicRenderLoop
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
a MorphicRenderLoop

MorphicRenderLoop>>doOneCycleWhile:
	Receiver: a MorphicRenderLoop
	Arguments and temporary variables: 
		aBlock: 	[ true ]
	Receiver's instance variables: 
a MorphicRenderLoop

[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		activeTranscript: 	nil



--- The full stack ---
IceTipLocalRepositoryPanel(Object)>>assert:description:
IceTipLocalRepositoryPanel>>validate
IceTipRegisterRepositoryDialog>>doAccept
[ self doAccept ] in IceTipRegisterRepositoryDialog(IceTipOptionDialog)>>initializeDialogWindow:
FullBlockClosure(BlockClosure)>>cull:
SpDialogWindowPresenter>>triggerOkAction
[ :presenter | 
			presenter triggerOkAction.
			presenter close ] in SpAbstractPresenter>>initializeDialogWindow:
FullBlockClosure(BlockClosure)>>cull:
[ aBlock cull: self ] in SpDialogWindowPresenter>>addButton:do:
SpButtonPresenter>>performAction
SpMorphicButtonAdapter>>action
PluggableButtonMorph>>performAction:
[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in PluggableButtonMorph>>mouseUp:
Array(SequenceableCollection)>>do:
PluggableButtonMorph>>mouseUp:
PluggableButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableButtonMorph(Morph)>>handleEvent:
PluggableButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
AssertionFailure: Project location does not seems to be a valid git repository.
26 September 2022 7:26:06.715152 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
StackToRegisterMappingCogit * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
v9.0.18 - Commit: 7249c170 - Date: 2022-09-02 14:31:12 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

IceTipLocalRepositoryPanel(Object)>>assert:description:
	Receiver: an IceTipLocalRepositoryPanel
	Arguments and temporary variables: 
		aBlock: 	false
		aStringOrBlock: 	'Project location does not seems to be a valid git repository.'...etc...
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	an IceTipRegisterRepositoryDialog
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		projectLocation: 	an IceTipDirectoryPresenter
		remoteLabel: 	nil
		remoteInputText: 	nil
		repository: 	nil


IceTipLocalRepositoryPanel>>validate
	Receiver: an IceTipLocalRepositoryPanel
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	an IceTipRegisterRepositoryDialog
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		projectLocation: 	an IceTipDirectoryPresenter
		remoteLabel: 	nil
		remoteInputText: 	nil
		repository: 	nil


IceTipRegisterRepositoryDialog>>doAccept
	Receiver: an IceTipRegisterRepositoryDialog
	Arguments and temporary variables: 
		newRepository: 	nil
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		owner: 	a SpDialogWindowPresenter
		adapter: 	a SpMorphicPanedAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a SpNullApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpPanedLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		typeList: 	a SpTablePresenter
		type: 	an IceTipLocalRepositoryPanel
		contentPanel: 	an IceTipLocalRepositoryPanel
		types: 	an OrderedCollection(an IceTipNewRepositoryPanel an IceTipLocalRepositor...etc...
		repository: 	nil
		acceptBlock: 	nil


[ self doAccept ] in IceTipRegisterRepositoryDialog(IceTipOptionDialog)>>initializeDialogWindow:
	Receiver: an IceTipRegisterRepositoryDialog
	Arguments and temporary variables: 
		aWindowPresenter: 	a SpDialogWindowPresenter
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		owner: 	a SpDialogWindowPresenter
		adapter: 	a SpMorphicPanedAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a SpNullApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpPanedLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		typeList: 	a SpTablePresenter
		type: 	an IceTipLocalRepositoryPanel
		contentPanel: 	an IceTipLocalRepositoryPanel
		types: 	an OrderedCollection(an IceTipNewRepositoryPanel an IceTipLocalRepositor...etc...
		repository: 	nil
		acceptBlock: 	nil


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ self doAccept ]
	Arguments and temporary variables: 
		anArg: 	a SpDialogWindowPresenter
	Receiver's instance variables: 
		outerContext: 	IceTipRegisterRepositoryDialog(IceTipOptionDialog)>>initializeDia...etc...
		startpc: 	a CompiledBlock: [ self doAccept ]
		numArgs: 	0
		receiver: 	an IceTipRegisterRepositoryDialog


SpDialogWindowPresenter>>triggerOkAction
	Receiver: a SpDialogWindowPresenter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicDialogWindowAdapter a SpDialogWindow(3...etc...
		announcer: 	an Announcer
		owner: 	nil
		adapter: 	a SpMorphicDialogWindowAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a SpNullApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ Form(16x16x32) ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ true ]
		titleHolder: 	an ObservableValueHolder[ 'Import from existing clone' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ nil ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		presenter: 	an ObservableValueHolder[ an IceTipRegisterRepositoryDialog ]
		initialPosition: 	an ObservableValueHolder[ nil ]
		initialExtent: 	an ObservableValueHolder[ (600@300) ]
		isResizeable: 	an ObservableValueHolder[ true ]
		menu: 	an ObservableValueHolder[ nil ]
		centered: 	an ObservableValueHolder[ false ]
		isClosed: 	an ObservableValueHolder[ false ]
		toolbar: 	an ObservableValueHolder[ nil ]
		statusbar: 	an ObservableValueHolder[ nil ]
		window: 	an ObservableValueHolder[ a SpDialogWindow(308885760) named: Import fro...etc...
		decorations: 	an ObservableValueHolder[ true ]
		buttons: 	an OrderedCollection(a SpButtonPresenter a SpButtonPresenter)
		okAction: 	[ self doAccept ]
		cancelAction: 	[ 
		cancelled := true.
		self close ]
		cancelled: 	true
		defaultButton: 	nil


[ :presenter | 
			presenter triggerOkAction.
			presenter close ] in SpAbstractPresenter>>initializeDialogWindow:
	Receiver: an IceTipRegisterRepositoryDialog
	Arguments and temporary variables: 
		aDialogWindowPresenter: 	a SpDialogWindowPresenter
		presenter: 	a SpDialogWindowPresenter
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		owner: 	a SpDialogWindowPresenter
		adapter: 	a SpMorphicPanedAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a SpNullApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpPanedLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		typeList: 	a SpTablePresenter
		type: 	an IceTipLocalRepositoryPanel
		contentPanel: 	an IceTipLocalRepositoryPanel
		types: 	an OrderedCollection(an IceTipNewRepositoryPanel an IceTipLocalRepositor...etc...
		repository: 	nil
		acceptBlock: 	nil


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ :presenter | 
			presenter triggerOkAction.
			presenter close ]
	Arguments and temporary variables: 
		anArg: 	a SpDialogWindowPresenter
	Receiver's instance variables: 
		outerContext: 	IceTipRegisterRepositoryDialog(SpAbstractPresenter)>>initializeDi...etc...
		startpc: 	a CompiledBlock: [ :presenter | 
			presenter triggerOkAction.
			pres...etc...
		numArgs: 	1
		receiver: 	an IceTipRegisterRepositoryDialog


[ aBlock cull: self ] in SpDialogWindowPresenter>>addButton:do:
	Receiver: a SpDialogWindowPresenter
	Arguments and temporary variables: 
		aString: 	'Ok'
		aBlock: 	[ :presenter | 
			presenter triggerOkAction.
			presenter close ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicDialogWindowAdapter a SpDialogWindow(3...etc...
		announcer: 	an Announcer
		owner: 	nil
		adapter: 	a SpMorphicDialogWindowAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a SpNullApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ Form(16x16x32) ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ true ]
		titleHolder: 	an ObservableValueHolder[ 'Import from existing clone' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ nil ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		presenter: 	an ObservableValueHolder[ an IceTipRegisterRepositoryDialog ]
		initialPosition: 	an ObservableValueHolder[ nil ]
		initialExtent: 	an ObservableValueHolder[ (600@300) ]
		isResizeable: 	an ObservableValueHolder[ true ]
		menu: 	an ObservableValueHolder[ nil ]
		centered: 	an ObservableValueHolder[ false ]
		isClosed: 	an ObservableValueHolder[ false ]
		toolbar: 	an ObservableValueHolder[ nil ]
		statusbar: 	an ObservableValueHolder[ nil ]
		window: 	an ObservableValueHolder[ a SpDialogWindow(308885760) named: Import fro...etc...
		decorations: 	an ObservableValueHolder[ true ]
		buttons: 	an OrderedCollection(a SpButtonPresenter a SpButtonPresenter)
		okAction: 	[ self doAccept ]
		cancelAction: 	[ 
		cancelled := true.
		self close ]
		cancelled: 	true
		defaultButton: 	nil


SpButtonPresenter>>performAction
	Receiver: a SpButtonPresenter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicButtonAdapter)
		announcer: 	an Announcer
		owner: 	a SpButtonBarPresenter
		adapter: 	a SpMorphicButtonAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Button' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		icon: 	an ObservableValueHolder[ nil ]
		label: 	an ObservableValueHolder[ 'Ok' ]
		action: 	an ObservableValueHolder[ [ aBlock cull: self ] ]
		actionPerformed: 	an ObservableValueHolder[ nil ]
		askBeforeChanging: 	an ObservableValueHolder[ false ]
		font: 	an ObservableValueHolder[ nil ]
		shortcut: 	an ObservableValueHolder[ nil ]
		state: 	an ObservableValueHolder[ false ]
		contextMenu: 	an ObservableValueHolder[ nil ]


SpMorphicButtonAdapter>>action
	Receiver: a SpMorphicButtonAdapter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a PluggableButtonMorph(335468288))
		announcer: 	nil
		model: 	a SpButtonPresenter
		widget: 	a PluggableButtonMorph(335468288)
		selector: 	nil
		owner: 	a SpButtonPresenter
		subMenuWidget: 	nil
		styleName: 	nil


PluggableButtonMorph>>performAction:
	Receiver: a PluggableButtonMorph(335468288)
	Arguments and temporary variables: 
		event: 	[(823@441) mouseUp 220343 nil]
	Receiver's instance variables: 
		bounds: 	(769.0@436.0) corner: (869.0@466.0)
		owner: 	a PanelMorph(1071747072)
		submorphs: 	an Array(an AlignmentMorph(502232320))
		fullBounds: 	nil
		color: 	(Color r: 0.2903225806451613 g: 0.2883675464320626 b: 0.2883675464320626...etc...
		extension: 	a MorphExtension (169478144) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a SpMorphicButtonAdapter
		label: 	'Ok'
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	#state
		actionSelector: 	#action
		font: 	nil
		getLabelSelector: 	#label
		getMenuSelector: 	#menu:
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		getFontSelector: 	#font
		labelMorph: 	a LabelMorph(236987904)'Ok'
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	false


[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(335468288)
	Arguments and temporary variables: 
		evt: 	[(823@441) mouseUp 220343 nil]
		all: 	an Array(a PluggableButtonMorph(857193472) a PluggableButtonMorph(33546828...etc...
		m: 	a PluggableButtonMorph(335468288)
	Receiver's instance variables: 
		bounds: 	(769.0@436.0) corner: (869.0@466.0)
		owner: 	a PanelMorph(1071747072)
		submorphs: 	an Array(an AlignmentMorph(502232320))
		fullBounds: 	nil
		color: 	(Color r: 0.2903225806451613 g: 0.2883675464320626 b: 0.2883675464320626...etc...
		extension: 	a MorphExtension (169478144) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a SpMorphicButtonAdapter
		label: 	'Ok'
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	#state
		actionSelector: 	#action
		font: 	nil
		getLabelSelector: 	#label
		getMenuSelector: 	#menu:
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		getFontSelector: 	#font
		labelMorph: 	a LabelMorph(236987904)'Ok'
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	false


Array(SequenceableCollection)>>do:
	Receiver: an Array(a PluggableButtonMorph(857193472) a PluggableButtonMorph(335468288))
	Arguments and temporary variables: 
		aBlock: 	[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [...etc...
		index: 	2
	Receiver's instance variables: 
an Array(a PluggableButtonMorph(857193472) a PluggableButtonMorph(335468288))

PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(335468288)
	Arguments and temporary variables: 
		evt: 	[(823@441) mouseUp 220343 nil]
		all: 	an Array(a PluggableButtonMorph(857193472) a PluggableButtonMorph(33546828...etc...
	Receiver's instance variables: 
		bounds: 	(769.0@436.0) corner: (869.0@466.0)
		owner: 	a PanelMorph(1071747072)
		submorphs: 	an Array(an AlignmentMorph(502232320))
		fullBounds: 	nil
		color: 	(Color r: 0.2903225806451613 g: 0.2883675464320626 b: 0.2883675464320626...etc...
		extension: 	a MorphExtension (169478144) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a SpMorphicButtonAdapter
		label: 	'Ok'
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	#state
		actionSelector: 	#action
		font: 	nil
		getLabelSelector: 	#label
		getMenuSelector: 	#menu:
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		getFontSelector: 	#font
		labelMorph: 	a LabelMorph(236987904)'Ok'
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	false


PluggableButtonMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableButtonMorph(335468288)
	Arguments and temporary variables: 
		anEvent: 	[(823@441) mouseUp 220343 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(769.0@436.0) corner: (869.0@466.0)
		owner: 	a PanelMorph(1071747072)
		submorphs: 	an Array(an AlignmentMorph(502232320))
		fullBounds: 	nil
		color: 	(Color r: 0.2903225806451613 g: 0.2883675464320626 b: 0.2883675464320626...etc...
		extension: 	a MorphExtension (169478144) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a SpMorphicButtonAdapter
		label: 	'Ok'
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	#state
		actionSelector: 	#action
		font: 	nil
		getLabelSelector: 	#label
		getMenuSelector: 	#menu:
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		getFontSelector: 	#font
		labelMorph: 	a LabelMorph(236987904)'Ok'
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	false


MouseButtonEvent>>sentTo:
	Receiver: [(823@441) mouseUp 220343 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableButtonMorph(335468288)
	Receiver's instance variables: 
		timeStamp: 	220343
		source: 	a HandMorph(986102528)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(823@441)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableButtonMorph(Morph)>>handleEvent:
	Receiver: a PluggableButtonMorph(335468288)
	Arguments and temporary variables: 
		anEvent: 	[(823@441) mouseUp 220343 nil]
	Receiver's instance variables: 
		bounds: 	(769.0@436.0) corner: (869.0@466.0)
		owner: 	a PanelMorph(1071747072)
		submorphs: 	an Array(an AlignmentMorph(502232320))
		fullBounds: 	nil
		color: 	(Color r: 0.2903225806451613 g: 0.2883675464320626 b: 0.2883675464320626...etc...
		extension: 	a MorphExtension (169478144) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a SpMorphicButtonAdapter
		label: 	'Ok'
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	#state
		actionSelector: 	#action
		font: 	nil
		getLabelSelector: 	#label
		getMenuSelector: 	#menu:
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		getFontSelector: 	#font
		labelMorph: 	a LabelMorph(236987904)'Ok'
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	false


PluggableButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a PluggableButtonMorph(335468288)
	Arguments and temporary variables: 
		anEvent: 	[(823@441) mouseUp 220343 nil]
	Receiver's instance variables: 
		bounds: 	(769.0@436.0) corner: (869.0@466.0)
		owner: 	a PanelMorph(1071747072)
		submorphs: 	an Array(an AlignmentMorph(502232320))
		fullBounds: 	nil
		color: 	(Color r: 0.2903225806451613 g: 0.2883675464320626 b: 0.2883675464320626...etc...
		extension: 	a MorphExtension (169478144) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a SpMorphicButtonAdapter
		label: 	'Ok'
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	#state
		actionSelector: 	#action
		font: 	nil
		getLabelSelector: 	#label
		getMenuSelector: 	#menu:
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		getFontSelector: 	#font
		labelMorph: 	a LabelMorph(236987904)'Ok'
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	false


[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(986102528)
	Arguments and temporary variables: 
		anEvent: 	[(823@441) mouseUp 220343 nil]
		focusHolder: 	a PluggableButtonMorph(335468288)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(603310592) [world]
		transformedEvent: 	[(823@441) mouseUp 220343 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(823@441) corner: (839@457)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	#()
		fullBounds: 	(823@441) corner: (839@457)
		color: 	Color blue
		extension: 	a MorphExtension (1065441536)
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(335468288)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(823@441) mouseUp 220343 nil]
		targetOffset: 	(54.0@5.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		lastKeyScanCode: 	nil
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		result := focusHolder handleFocusEvent: transformedEvent.
	]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
			ActiveWorld := priorWorld.
			ex pass ]
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	a CompiledBlock: [
		result := focusHolder handleFocusEvent: transform...etc...
		numArgs: 	0
		receiver: 	a HandMorph(986102528)


WorldMorph>>becomeActiveDuring:
	Receiver: a WorldMorph(603310592) [world]
	Arguments and temporary variables: 
		aBlock: 	[
		result := focusHolder handleFocusEvent: transformedEvent.
	]
		priorWorld: 	a WorldMorph(603310592) [world]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1512@851)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(1021235712) a TaskbarMorph(882262784) a SpDi...etc...
		fullBounds: 	(0@0) corner: (1512@851)
		color: 	(Color r: 0.29521016617790813 g: 0.29521016617790813 b: 0.29521016617790...etc...
		extension: 	a MorphExtension (219690240) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(986102528)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(823@441) mouseUp 220343 nil]
		focusHolder: 	a PluggableButtonMorph(335468288)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(603310592) [world]
		transformedEvent: 	[(823@441) mouseUp 220343 nil]
	Receiver's instance variables: 
		bounds: 	(823@441) corner: (839@457)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	#()
		fullBounds: 	(823@441) corner: (839@457)
		color: 	Color blue
		extension: 	a MorphExtension (1065441536)
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(335468288)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(823@441) mouseUp 220343 nil]
		targetOffset: 	(54.0@5.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		lastKeyScanCode: 	nil
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(986102528)
	Arguments and temporary variables: 
		anEvent: 	[(823@441) mouseUp 220343 nil]
		focusHolder: 	a PluggableButtonMorph(335468288)
		aBlock: 	[self mouseFocus: nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(823@441) corner: (839@457)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	#()
		fullBounds: 	(823@441) corner: (839@457)
		color: 	Color blue
		extension: 	a MorphExtension (1065441536)
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(335468288)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(823@441) mouseUp 220343 nil]
		targetOffset: 	(54.0@5.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		lastKeyScanCode: 	nil
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(986102528)
	Arguments and temporary variables: 
		anEvent: 	[(823@441) mouseUp 220343 nil]
	Receiver's instance variables: 
		bounds: 	(823@441) corner: (839@457)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	#()
		fullBounds: 	(823@441) corner: (839@457)
		color: 	Color blue
		extension: 	a MorphExtension (1065441536)
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(335468288)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(823@441) mouseUp 220343 nil]
		targetOffset: 	(54.0@5.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		lastKeyScanCode: 	nil
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>handleEvent:
	Receiver: a HandMorph(986102528)
	Arguments and temporary variables: 
		anEvent: 	[(823@441) mouseUp 220343 nil]
		evt: 	[(823@441) mouseUp 220343 nil]
	Receiver's instance variables: 
		bounds: 	(823@441) corner: (839@457)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	#()
		fullBounds: 	(823@441) corner: (839@457)
		color: 	Color blue
		extension: 	a MorphExtension (1065441536)
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(335468288)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(823@441) mouseUp 220343 nil]
		targetOffset: 	(54.0@5.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		lastKeyScanCode: 	nil
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
	Receiver: an OSWindowMorphicEventHandler
	Arguments and temporary variables: 
		anEvent: 	[(823@441) mouseUp 220343 nil]
	Receiver's instance variables: 
		morphicWorld: 	a WorldMorph(603310592) [world]


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(603310592) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(986102528))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	184678
		lastStepMessage: 	nil
		alarms: 	a Heap()
		lastAlarmTime: 	220330
		activeHand: 	a HandMorph(986102528)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1512@851)


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(603310592) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1512@851)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(1021235712) a TaskbarMorph(882262784) a SpDi...etc...
		fullBounds: 	(0@0) corner: (1512@851)
		color: 	(Color r: 0.29521016617790813 g: 0.29521016617790813 b: 0.29521016617790...etc...
		extension: 	a MorphExtension (219690240) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(603310592) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(986102528))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	184678
		lastStepMessage: 	nil
		alarms: 	a Heap()
		lastAlarmTime: 	220330
		activeHand: 	a HandMorph(986102528)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1512@851)


WorldMorph>>doOneCycleNow
	Receiver: a WorldMorph(603310592) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1512@851)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(1021235712) a TaskbarMorph(882262784) a SpDi...etc...
		fullBounds: 	(0@0) corner: (1512@851)
		color: 	(Color r: 0.29521016617790813 g: 0.29521016617790813 b: 0.29521016617790...etc...
		extension: 	a MorphExtension (219690240) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(603310592) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1512@851)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(1021235712) a TaskbarMorph(882262784) a SpDi...etc...
		fullBounds: 	(0@0) corner: (1512@851)
		color: 	(Color r: 0.29521016617790813 g: 0.29521016617790813 b: 0.29521016617790...etc...
		extension: 	a MorphExtension (219690240) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 
		extraWorldsToDraw: 	#()
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65547
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->nil #CursorOwnerWorld->a WorldMorph(60...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		announcer: 	nil
		displayScaleFactor: 	1


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extr...etc...
	Arguments and temporary variables: 
		aBlock: 	[
		self doInterCycleWait
	]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	WorldMorph class>>doOneCycle
		startpc: 	a CompiledBlock: [
		| extraWorldsToDraw |
		extraWorldsToDraw := Extr...etc...
		numArgs: 	0
		receiver: 	WorldMorph


WorldState class>>doDrawCycleWith:
	Receiver: WorldState
	Arguments and temporary variables: 
		aBlock: 	[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex cr...etc...
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#activeHand->WorldState>>#activeHand #activeHand...etc...
		format: 	65547
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldState}
		name: 	#WorldState
		classPool: 	a Dictionary(#CanSurrenderToOS->nil #DebugShowDamage->false #Deferre...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'


WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65547
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->nil #CursorOwnerWorld->a WorldMorph(60...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		announcer: 	nil
		displayScaleFactor: 	1


MorphicRenderLoop>>doOneCycle
	Receiver: a MorphicRenderLoop
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
a MorphicRenderLoop

MorphicRenderLoop>>doOneCycleWhile:
	Receiver: a MorphicRenderLoop
	Arguments and temporary variables: 
		aBlock: 	[ true ]
	Receiver's instance variables: 
a MorphicRenderLoop

[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		activeTranscript: 	nil



--- The full stack ---
IceTipLocalRepositoryPanel(Object)>>assert:description:
IceTipLocalRepositoryPanel>>validate
IceTipRegisterRepositoryDialog>>doAccept
[ self doAccept ] in IceTipRegisterRepositoryDialog(IceTipOptionDialog)>>initializeDialogWindow:
FullBlockClosure(BlockClosure)>>cull:
SpDialogWindowPresenter>>triggerOkAction
[ :presenter | 
			presenter triggerOkAction.
			presenter close ] in SpAbstractPresenter>>initializeDialogWindow:
FullBlockClosure(BlockClosure)>>cull:
[ aBlock cull: self ] in SpDialogWindowPresenter>>addButton:do:
SpButtonPresenter>>performAction
SpMorphicButtonAdapter>>action
PluggableButtonMorph>>performAction:
[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in PluggableButtonMorph>>mouseUp:
Array(SequenceableCollection)>>do:
PluggableButtonMorph>>mouseUp:
PluggableButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableButtonMorph(Morph)>>handleEvent:
PluggableButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

