THERE_BE_DRAGONS_HERE
Instance of Object class did not understand #initialize:
26 September 2022 7:12:12.856175 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
StackToRegisterMappingCogit * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
v9.0.18 - Commit: 7249c170 - Date: 2022-09-02 14:31:12 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

Pile class(Object)>>doesNotUnderstand: #initialize:
	Receiver: Pile
	Arguments and temporary variables: 
		aMessage: 	initialize: nil
		exception: 	Instance of Object class did not understand #initialize:
		resumeValue: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#grow->Pile>>#grow #initialize:->Pile>>#initiali...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#Pile
		classPool: 	a Dictionary(#tailleDefaut->nil )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#HAI914I


Pile class>>new:
	Receiver: Pile
	Arguments and temporary variables: 
		taille: 	4
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#grow->Pile>>#grow #initialize:->Pile>>#initiali...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#Pile
		classPool: 	a Dictionary(#tailleDefaut->nil )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#HAI914I


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ p := Pile new: 4
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ p := Pile new: 4
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'p:= Pile new: 4.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 16) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'p:= Pile new: 4.' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'p:= Pile new: 4.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 16) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'p:= Pile new: 4.' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodeInspectItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodeInspectItCommand
	Arguments and temporary variables: 
		aString: 	'p:= Pile new: 4.'
		aBlock: 	[ :result | 
		self inspectObject: result ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Inspect it'
		basicDescription: 	'Evaluate selection and inspect the result.'
		transform: 	[ :aContext | aContext ]


SpCodeInspectItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodeInspectItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
		self inspectObject: result ]
		selection: 	'p:= Pile new: 4.'
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Inspect it'
		basicDescription: 	'Evaluate selection and inspect the result.'
		transform: 	[ :aContext | aContext ]


SpCodeInspectItCommand>>execute
	Receiver: a SpCodeInspectItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Inspect it'
		basicDescription: 	'Evaluate selection and inspect the result.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Inspect it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodeInspectItCommand
		iconProvider: 	a ThemeIcons(idea11)
		iconName: 	#smallInspectIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Inspect it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Inspect it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ aCommand execute ] in SpMenuPresenterBuilder>>fillItem:with:
	Receiver: a SpMenuPresenterBuilder
	Arguments and temporary variables: 
		aMenuItem: 	a SpMenuItemPresenter
		aCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		menuPresenter: 	a SpMenuPresenter
		stack: 	a Stack(a SpMenuPresenter)


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ aCommand execute ]
	Arguments and temporary variables: 
		anArg: 	a SpMorphicMenuItemAdapter
	Receiver's instance variables: 
		outerContext: 	SpMenuPresenterBuilder>>fillItem:with:
		startpc: 	a CompiledBlock: [ aCommand execute ]
		numArgs: 	0
		receiver: 	a SpMenuPresenterBuilder


SpMenuItemPresenter>>performMenuActionWith:
	Receiver: a SpMenuItemPresenter
	Arguments and temporary variables: 
		aMenuItem: 	a SpMorphicMenuItemAdapter
		en: 	true
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicMenuItemAdapter)
		announcer: 	an Announcer
		owner: 	a SpMenuGroupPresenter
		adapter: 	a SpMorphicMenuItemAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		name: 	an ObservableValueHolder[ 'Inspect it' ]
		icon: 	an ObservableValueHolder[ Form(16x16x32) ]
		description: 	an ObservableValueHolder[ 'Evaluate selection and inspect the resu...etc...
		action: 	[ aCommand execute ]
		shortcut: 	a KMKeyCombinationChoice
		subMenu: 	nil
		state: 	nil
		autoRefresh: 	false


SpMorphicMenuItemAdapter>>performMenuActionWith:
	Receiver: a SpMorphicMenuItemAdapter
	Arguments and temporary variables: 
		arguments: 	a SpMorphicMenuItemAdapter
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	nil
		model: 	a SpMenuItemPresenter
		widget: 	a SpToggleMenuItemMorph(499177728)'Inspect it'
		selector: 	nil
		owner: 	a SpMenuItemPresenter


[ | selArgCount |  "show cursor in case item opens a new MVC window"
		(selArgCount := selector numArgs) = 0
			ifTrue:
				[target perform: selector]
			ifFalse:
				[selArgCount = arguments size
					ifTrue: [target perform: selector withArguments: arguments]
					ifFalse: [target perform: selector withArguments: (arguments copyWith: evt)]].
		self showShortcut.
		self changed] in SpToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
	Receiver: a SpToggleMenuItemMorph(499177728)'Inspect it'
	Arguments and temporary variables: 
		evt: 	[(663@377) mouseUp 3193838 nil]
		w: 	a WorldMorph(603310592) [world]
		selArgCount: 	1
	Receiver's instance variables: 
		bounds: 	(601.0@372.0) corner: (723.0@390.0)
		owner: 	a MenuMorph(665071104)
		submorphs: 	#()
		fullBounds: 	(601.0@372.0) corner: (723.0@390.0)
		color: 	Color white
		extension: 	a MorphExtension (984295680) [balloonText]  [other:  (kmDispatcher -...etc...
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Inspect it'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a SpMorphicMenuItemAdapter
		selector: 	#performMenuActionWith:
		arguments: 	an Array(a SpMorphicMenuItemAdapter)
		icon: 	Form(16x16x32)
		keyText: 	'⌘I'
		getStateSelector: 	nil
		enablementSelector: 	#enabled


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ | selArgCount |  "show cursor in case item opens a new MVC window"
		(selArgCount := sel...etc...
	Arguments and temporary variables: 
		aBlock: 	[oldcursor show]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
		startpc: 	a CompiledBlock: [ | selArgCount |  "show cursor in case item opens a ...etc...
		numArgs: 	0
		receiver: 	a SpToggleMenuItemMorph(499177728)'Inspect it'


CursorWithMask(Cursor)>>showWhile:
	Receiver: ((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0
		2r100000000000000000000...etc...
	Arguments and temporary variables: 
		aBlock: 	[ | selArgCount |  "show cursor in case item opens a new MVC window"
		...etc...
		oldcursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0
		2...etc...
	Receiver's instance variables: 
		bits: 	a Bitmap of length 16
		width: 	16
		height: 	16
		depth: 	1
		offset: 	(-1@ -1)
		maskForm: 	Form(16x16x1)


SpToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
	Receiver: a SpToggleMenuItemMorph(499177728)'Inspect it'
	Arguments and temporary variables: 
		evt: 	[(663@377) mouseUp 3193838 nil]
		w: 	a WorldMorph(603310592) [world]
	Receiver's instance variables: 
		bounds: 	(601.0@372.0) corner: (723.0@390.0)
		owner: 	a MenuMorph(665071104)
		submorphs: 	#()
		fullBounds: 	(601.0@372.0) corner: (723.0@390.0)
		color: 	Color white
		extension: 	a MorphExtension (984295680) [balloonText]  [other:  (kmDispatcher -...etc...
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Inspect it'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a SpMorphicMenuItemAdapter
		selector: 	#performMenuActionWith:
		arguments: 	an Array(a SpMorphicMenuItemAdapter)
		icon: 	Form(16x16x32)
		keyText: 	'⌘I'
		getStateSelector: 	nil
		enablementSelector: 	#enabled


SpToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
	Receiver: a SpToggleMenuItemMorph(499177728)'Inspect it'
	Arguments and temporary variables: 
		evt: 	[(663@377) mouseUp 3193838 nil]
	Receiver's instance variables: 
		bounds: 	(601.0@372.0) corner: (723.0@390.0)
		owner: 	a MenuMorph(665071104)
		submorphs: 	#()
		fullBounds: 	(601.0@372.0) corner: (723.0@390.0)
		color: 	Color white
		extension: 	a MorphExtension (984295680) [balloonText]  [other:  (kmDispatcher -...etc...
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Inspect it'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a SpMorphicMenuItemAdapter
		selector: 	#performMenuActionWith:
		arguments: 	an Array(a SpMorphicMenuItemAdapter)
		icon: 	Form(16x16x32)
		keyText: 	'⌘I'
		getStateSelector: 	nil
		enablementSelector: 	#enabled


SpToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
	Receiver: a SpToggleMenuItemMorph(499177728)'Inspect it'
	Arguments and temporary variables: 
		anEvent: 	[(663@377) mouseUp 3193838 nil]
	Receiver's instance variables: 
		bounds: 	(601.0@372.0) corner: (723.0@390.0)
		owner: 	a MenuMorph(665071104)
		submorphs: 	#()
		fullBounds: 	(601.0@372.0) corner: (723.0@390.0)
		color: 	Color white
		extension: 	a MorphExtension (984295680) [balloonText]  [other:  (kmDispatcher -...etc...
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Inspect it'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a SpMorphicMenuItemAdapter
		selector: 	#performMenuActionWith:
		arguments: 	an Array(a SpMorphicMenuItemAdapter)
		icon: 	Form(16x16x32)
		keyText: 	'⌘I'
		getStateSelector: 	nil
		enablementSelector: 	#enabled


MouseButtonEvent>>sentTo:
	Receiver: [(663@377) mouseUp 3193838 nil]
	Arguments and temporary variables: 
		anObject: 	a SpToggleMenuItemMorph(499177728)'Inspect it'
	Receiver's instance variables: 
		timeStamp: 	3193838
		source: 	a HandMorph(986102528)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(663@377)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


SpToggleMenuItemMorph(Morph)>>handleEvent:
	Receiver: a SpToggleMenuItemMorph(499177728)'Inspect it'
	Arguments and temporary variables: 
		anEvent: 	[(663@377) mouseUp 3193838 nil]
	Receiver's instance variables: 
		bounds: 	(601.0@372.0) corner: (723.0@390.0)
		owner: 	a MenuMorph(665071104)
		submorphs: 	#()
		fullBounds: 	(601.0@372.0) corner: (723.0@390.0)
		color: 	Color white
		extension: 	a MorphExtension (984295680) [balloonText]  [other:  (kmDispatcher -...etc...
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Inspect it'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a SpMorphicMenuItemAdapter
		selector: 	#performMenuActionWith:
		arguments: 	an Array(a SpMorphicMenuItemAdapter)
		icon: 	Form(16x16x32)
		keyText: 	'⌘I'
		getStateSelector: 	nil
		enablementSelector: 	#enabled


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(663@377) mouseUp 3193838 nil]
		aMorph: 	a SpToggleMenuItemMorph(499177728)'Inspect it'
		localEvt: 	nil
		index: 	1
		child: 	nil
		morphs: 	#()
		inside: 	true
	Receiver's instance variables: 
		morph: 	a SpToggleMenuItemMorph(499177728)'Inspect it'


MorphicEventDispatcher>>handleMouseUp:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(663@377) mouseUp 3193838 nil]
	Receiver's instance variables: 
		morph: 	a SpToggleMenuItemMorph(499177728)'Inspect it'



--- The full stack ---
Pile class(Object)>>doesNotUnderstand: #initialize:
Pile class>>new:
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeInspectItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeInspectItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeInspectItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ aCommand execute ] in SpMenuPresenterBuilder>>fillItem:with:
FullBlockClosure(BlockClosure)>>cull:
SpMenuItemPresenter>>performMenuActionWith:
SpMorphicMenuItemAdapter>>performMenuActionWith:
[ | selArgCount |  "show cursor in case item opens a new MVC window"
		(selArgCount := selector numArgs) = 0
			ifTrue:
				[target perform: selector]
			ifFalse:
				[selArgCount = arguments size
					ifTrue: [target perform: selector withArguments: arguments]
					ifFalse: [target perform: selector withArguments: (arguments copyWith: evt)]].
		self showShortcut.
		self changed] in SpToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
SpToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
SpToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
SpToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
SpToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
SpToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MenuMorph(Morph)>>processEvent:using:
MenuMorph(Morph)>>processEvent:
MenuMorph>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
MenuMorph>>invokeAt:in:allowKeyboard:
MenuMorph>>invokeAt:in:
MenuMorph>>invokeModal
RubEditingArea(RubAbstractTextArea)>>yellowButtonActivity:
RubEditingArea(RubAbstractTextArea)>>mouseDown:
RubEditingArea(Morph)>>handleMouseDown:
MouseButtonEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
RubEditingArea(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
TransformWithLayoutMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
RubTextScrollPane(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
SpRubScrolledTextMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
Morph>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
Morph>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
Morph>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
TransformWithLayoutMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MillerScrollPane(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
Morph>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
Morph>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
Morph>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
Morph>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
Morph>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
SpWindow(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
-- and more not shown ---------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of Object class did not understand #initialize:
26 September 2022 7:12:12.894609 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
StackToRegisterMappingCogit * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
v9.0.18 - Commit: 7249c170 - Date: 2022-09-02 14:31:12 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

Pile class(Object)>>doesNotUnderstand: #initialize:
	Receiver: Pile
	Arguments and temporary variables: 
		aMessage: 	initialize: nil
		exception: 	Instance of Object class did not understand #initialize:
		resumeValue: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#grow->Pile>>#grow #initialize:->Pile>>#initiali...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#Pile
		classPool: 	a Dictionary(#tailleDefaut->nil )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#HAI914I


Pile class>>new:
	Receiver: Pile
	Arguments and temporary variables: 
		taille: 	4
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#grow->Pile>>#grow #initialize:->Pile>>#initiali...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#Pile
		classPool: 	a Dictionary(#tailleDefaut->nil )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#HAI914I


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ p := Pile new: 4
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ p := Pile new: 4
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'p:= Pile new: 4.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 16) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'p:= Pile new: 4.' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'p:= Pile new: 4.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 16) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'p:= Pile new: 4.' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodeInspectItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodeInspectItCommand
	Arguments and temporary variables: 
		aString: 	'p:= Pile new: 4.'
		aBlock: 	[ :result | 
		self inspectObject: result ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Inspect it'
		basicDescription: 	'Evaluate selection and inspect the result.'
		transform: 	[ :aContext | aContext ]


SpCodeInspectItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodeInspectItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
		self inspectObject: result ]
		selection: 	'p:= Pile new: 4.'
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Inspect it'
		basicDescription: 	'Evaluate selection and inspect the result.'
		transform: 	[ :aContext | aContext ]


SpCodeInspectItCommand>>execute
	Receiver: a SpCodeInspectItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Inspect it'
		basicDescription: 	'Evaluate selection and inspect the result.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Inspect it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodeInspectItCommand
		iconProvider: 	a ThemeIcons(idea11)
		iconName: 	#smallInspectIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Inspect it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Inspect it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ aCommand execute ] in SpMenuPresenterBuilder>>fillItem:with:
	Receiver: a SpMenuPresenterBuilder
	Arguments and temporary variables: 
		aMenuItem: 	a SpMenuItemPresenter
		aCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		menuPresenter: 	a SpMenuPresenter
		stack: 	a Stack(a SpMenuPresenter)


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ aCommand execute ]
	Arguments and temporary variables: 
		anArg: 	a SpMorphicMenuItemAdapter
	Receiver's instance variables: 
		outerContext: 	SpMenuPresenterBuilder>>fillItem:with:
		startpc: 	a CompiledBlock: [ aCommand execute ]
		numArgs: 	0
		receiver: 	a SpMenuPresenterBuilder


SpMenuItemPresenter>>performMenuActionWith:
	Receiver: a SpMenuItemPresenter
	Arguments and temporary variables: 
		aMenuItem: 	a SpMorphicMenuItemAdapter
		en: 	true
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicMenuItemAdapter)
		announcer: 	an Announcer
		owner: 	a SpMenuGroupPresenter
		adapter: 	a SpMorphicMenuItemAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		name: 	an ObservableValueHolder[ 'Inspect it' ]
		icon: 	an ObservableValueHolder[ Form(16x16x32) ]
		description: 	an ObservableValueHolder[ 'Evaluate selection and inspect the resu...etc...
		action: 	[ aCommand execute ]
		shortcut: 	a KMKeyCombinationChoice
		subMenu: 	nil
		state: 	nil
		autoRefresh: 	false


SpMorphicMenuItemAdapter>>performMenuActionWith:
	Receiver: a SpMorphicMenuItemAdapter
	Arguments and temporary variables: 
		arguments: 	a SpMorphicMenuItemAdapter
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	nil
		model: 	a SpMenuItemPresenter
		widget: 	a SpToggleMenuItemMorph(499177728)'Inspect it'
		selector: 	nil
		owner: 	a SpMenuItemPresenter


[ | selArgCount |  "show cursor in case item opens a new MVC window"
		(selArgCount := selector numArgs) = 0
			ifTrue:
				[target perform: selector]
			ifFalse:
				[selArgCount = arguments size
					ifTrue: [target perform: selector withArguments: arguments]
					ifFalse: [target perform: selector withArguments: (arguments copyWith: evt)]].
		self showShortcut.
		self changed] in SpToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
	Receiver: a SpToggleMenuItemMorph(499177728)'Inspect it'
	Arguments and temporary variables: 
		evt: 	[(663@377) mouseUp 3193838 nil]
		w: 	a WorldMorph(603310592) [world]
		selArgCount: 	1
	Receiver's instance variables: 
		bounds: 	(601.0@372.0) corner: (723.0@390.0)
		owner: 	a MenuMorph(665071104)
		submorphs: 	#()
		fullBounds: 	(601.0@372.0) corner: (723.0@390.0)
		color: 	Color white
		extension: 	a MorphExtension (984295680) [balloonText]  [other:  (kmDispatcher -...etc...
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Inspect it'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a SpMorphicMenuItemAdapter
		selector: 	#performMenuActionWith:
		arguments: 	an Array(a SpMorphicMenuItemAdapter)
		icon: 	Form(16x16x32)
		keyText: 	'⌘I'
		getStateSelector: 	nil
		enablementSelector: 	#enabled


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ | selArgCount |  "show cursor in case item opens a new MVC window"
		(selArgCount := sel...etc...
	Arguments and temporary variables: 
		aBlock: 	[oldcursor show]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
		startpc: 	a CompiledBlock: [ | selArgCount |  "show cursor in case item opens a ...etc...
		numArgs: 	0
		receiver: 	a SpToggleMenuItemMorph(499177728)'Inspect it'


CursorWithMask(Cursor)>>showWhile:
	Receiver: ((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0
		2r100000000000000000000...etc...
	Arguments and temporary variables: 
		aBlock: 	[ | selArgCount |  "show cursor in case item opens a new MVC window"
		...etc...
		oldcursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0
		2...etc...
	Receiver's instance variables: 
		bits: 	a Bitmap of length 16
		width: 	16
		height: 	16
		depth: 	1
		offset: 	(-1@ -1)
		maskForm: 	Form(16x16x1)


SpToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
	Receiver: a SpToggleMenuItemMorph(499177728)'Inspect it'
	Arguments and temporary variables: 
		evt: 	[(663@377) mouseUp 3193838 nil]
		w: 	a WorldMorph(603310592) [world]
	Receiver's instance variables: 
		bounds: 	(601.0@372.0) corner: (723.0@390.0)
		owner: 	a MenuMorph(665071104)
		submorphs: 	#()
		fullBounds: 	(601.0@372.0) corner: (723.0@390.0)
		color: 	Color white
		extension: 	a MorphExtension (984295680) [balloonText]  [other:  (kmDispatcher -...etc...
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Inspect it'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a SpMorphicMenuItemAdapter
		selector: 	#performMenuActionWith:
		arguments: 	an Array(a SpMorphicMenuItemAdapter)
		icon: 	Form(16x16x32)
		keyText: 	'⌘I'
		getStateSelector: 	nil
		enablementSelector: 	#enabled


SpToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
	Receiver: a SpToggleMenuItemMorph(499177728)'Inspect it'
	Arguments and temporary variables: 
		evt: 	[(663@377) mouseUp 3193838 nil]
	Receiver's instance variables: 
		bounds: 	(601.0@372.0) corner: (723.0@390.0)
		owner: 	a MenuMorph(665071104)
		submorphs: 	#()
		fullBounds: 	(601.0@372.0) corner: (723.0@390.0)
		color: 	Color white
		extension: 	a MorphExtension (984295680) [balloonText]  [other:  (kmDispatcher -...etc...
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Inspect it'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a SpMorphicMenuItemAdapter
		selector: 	#performMenuActionWith:
		arguments: 	an Array(a SpMorphicMenuItemAdapter)
		icon: 	Form(16x16x32)
		keyText: 	'⌘I'
		getStateSelector: 	nil
		enablementSelector: 	#enabled


SpToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
	Receiver: a SpToggleMenuItemMorph(499177728)'Inspect it'
	Arguments and temporary variables: 
		anEvent: 	[(663@377) mouseUp 3193838 nil]
	Receiver's instance variables: 
		bounds: 	(601.0@372.0) corner: (723.0@390.0)
		owner: 	a MenuMorph(665071104)
		submorphs: 	#()
		fullBounds: 	(601.0@372.0) corner: (723.0@390.0)
		color: 	Color white
		extension: 	a MorphExtension (984295680) [balloonText]  [other:  (kmDispatcher -...etc...
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Inspect it'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a SpMorphicMenuItemAdapter
		selector: 	#performMenuActionWith:
		arguments: 	an Array(a SpMorphicMenuItemAdapter)
		icon: 	Form(16x16x32)
		keyText: 	'⌘I'
		getStateSelector: 	nil
		enablementSelector: 	#enabled


MouseButtonEvent>>sentTo:
	Receiver: [(663@377) mouseUp 3193838 nil]
	Arguments and temporary variables: 
		anObject: 	a SpToggleMenuItemMorph(499177728)'Inspect it'
	Receiver's instance variables: 
		timeStamp: 	3193838
		source: 	a HandMorph(986102528)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(663@377)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


SpToggleMenuItemMorph(Morph)>>handleEvent:
	Receiver: a SpToggleMenuItemMorph(499177728)'Inspect it'
	Arguments and temporary variables: 
		anEvent: 	[(663@377) mouseUp 3193838 nil]
	Receiver's instance variables: 
		bounds: 	(601.0@372.0) corner: (723.0@390.0)
		owner: 	a MenuMorph(665071104)
		submorphs: 	#()
		fullBounds: 	(601.0@372.0) corner: (723.0@390.0)
		color: 	Color white
		extension: 	a MorphExtension (984295680) [balloonText]  [other:  (kmDispatcher -...etc...
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Inspect it'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a SpMorphicMenuItemAdapter
		selector: 	#performMenuActionWith:
		arguments: 	an Array(a SpMorphicMenuItemAdapter)
		icon: 	Form(16x16x32)
		keyText: 	'⌘I'
		getStateSelector: 	nil
		enablementSelector: 	#enabled


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(663@377) mouseUp 3193838 nil]
		aMorph: 	a SpToggleMenuItemMorph(499177728)'Inspect it'
		localEvt: 	nil
		index: 	1
		child: 	nil
		morphs: 	#()
		inside: 	true
	Receiver's instance variables: 
		morph: 	a SpToggleMenuItemMorph(499177728)'Inspect it'


MorphicEventDispatcher>>handleMouseUp:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(663@377) mouseUp 3193838 nil]
	Receiver's instance variables: 
		morph: 	a SpToggleMenuItemMorph(499177728)'Inspect it'



--- The full stack ---
Pile class(Object)>>doesNotUnderstand: #initialize:
Pile class>>new:
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeInspectItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeInspectItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeInspectItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ aCommand execute ] in SpMenuPresenterBuilder>>fillItem:with:
FullBlockClosure(BlockClosure)>>cull:
SpMenuItemPresenter>>performMenuActionWith:
SpMorphicMenuItemAdapter>>performMenuActionWith:
[ | selArgCount |  "show cursor in case item opens a new MVC window"
		(selArgCount := selector numArgs) = 0
			ifTrue:
				[target perform: selector]
			ifFalse:
				[selArgCount = arguments size
					ifTrue: [target perform: selector withArguments: arguments]
					ifFalse: [target perform: selector withArguments: (arguments copyWith: evt)]].
		self showShortcut.
		self changed] in SpToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
SpToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
SpToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
SpToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
SpToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
SpToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MenuMorph(Morph)>>processEvent:using:
MenuMorph(Morph)>>processEvent:
MenuMorph>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
MenuMorph>>invokeAt:in:allowKeyboard:
MenuMorph>>invokeAt:in:
MenuMorph>>invokeModal
RubEditingArea(RubAbstractTextArea)>>yellowButtonActivity:
RubEditingArea(RubAbstractTextArea)>>mouseDown:
RubEditingArea(Morph)>>handleMouseDown:
MouseButtonEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
RubEditingArea(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
TransformWithLayoutMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
RubTextScrollPane(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
SpRubScrolledTextMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
Morph>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
Morph>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
Morph>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
TransformWithLayoutMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MillerScrollPane(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
Morph>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
Morph>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
Morph>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
Morph>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
Morph>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
SpWindow(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
-- and more not shown ---------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of Object class did not understand #initialize:
26 September 2022 7:12:45.526029 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
StackToRegisterMappingCogit * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
v9.0.18 - Commit: 7249c170 - Date: 2022-09-02 14:31:12 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

Pile class(Object)>>doesNotUnderstand: #initialize:
	Receiver: Pile
	Arguments and temporary variables: 
		aMessage: 	initialize: nil
		exception: 	Instance of Object class did not understand #initialize:
		resumeValue: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#grow->Pile>>#grow #initialize:->Pile>>#initiali...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#Pile
		classPool: 	a Dictionary(#tailleDefaut->nil )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#HAI914I


Pile class>>new:
	Receiver: Pile
	Arguments and temporary variables: 
		taille: 	4
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#grow->Pile>>#grow #initialize:->Pile>>#initiali...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#Pile
		classPool: 	a Dictionary(#tailleDefaut->nil )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#HAI914I


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ p := Pile new: 4
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ p := Pile new: 4
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'p:= Pile new: 4.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#p->nil )
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 16) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'p:= Pile new: 4.' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#p->nil )
		aString: 	'p:= Pile new: 4.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 16) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'p:= Pile new: 4.' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aString: 	'p:= Pile new: 4.'
		aBlock: 	[ :result | ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | ]
		selection: 	'p:= Pile new: 4.'
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand>>execute
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodeDoItCommand
		iconProvider: 	a ThemeIcons(idea11)
		iconName: 	#smallDoIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ aCommand execute ] in SpMenuPresenterBuilder>>fillItem:with:
	Receiver: a SpMenuPresenterBuilder
	Arguments and temporary variables: 
		aMenuItem: 	a SpMenuItemPresenter
		aCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		menuPresenter: 	a SpMenuPresenter
		stack: 	a Stack(a SpMenuPresenter)


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ aCommand execute ]
	Arguments and temporary variables: 
		anArg: 	a SpMorphicMenuItemAdapter
	Receiver's instance variables: 
		outerContext: 	SpMenuPresenterBuilder>>fillItem:with:
		startpc: 	a CompiledBlock: [ aCommand execute ]
		numArgs: 	0
		receiver: 	a SpMenuPresenterBuilder


SpMenuItemPresenter>>performMenuActionWith:
	Receiver: a SpMenuItemPresenter
	Arguments and temporary variables: 
		aMenuItem: 	a SpMorphicMenuItemAdapter
		en: 	true
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicMenuItemAdapter)
		announcer: 	an Announcer
		owner: 	a SpMenuGroupPresenter
		adapter: 	a SpMorphicMenuItemAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		name: 	an ObservableValueHolder[ 'Do it' ]
		icon: 	an ObservableValueHolder[ Form(13x13x32) ]
		description: 	an ObservableValueHolder[ 'Evaluate selection.' ]
		action: 	[ aCommand execute ]
		shortcut: 	a KMKeyCombinationChoice
		subMenu: 	nil
		state: 	nil
		autoRefresh: 	false


SpMorphicMenuItemAdapter>>performMenuActionWith:
	Receiver: a SpMorphicMenuItemAdapter
	Arguments and temporary variables: 
		arguments: 	a SpMorphicMenuItemAdapter
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	nil
		model: 	a SpMenuItemPresenter
		widget: 	a SpToggleMenuItemMorph(1007108864)'Do it'
		selector: 	nil
		owner: 	a SpMenuItemPresenter


[ | selArgCount |  "show cursor in case item opens a new MVC window"
		(selArgCount := selector numArgs) = 0
			ifTrue:
				[target perform: selector]
			ifFalse:
				[selArgCount = arguments size
					ifTrue: [target perform: selector withArguments: arguments]
					ifFalse: [target perform: selector withArguments: (arguments copyWith: evt)]].
		self showShortcut.
		self changed] in SpToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
	Receiver: a SpToggleMenuItemMorph(1007108864)'Do it'
	Arguments and temporary variables: 
		evt: 	[(625@344) mouseUp 3226529 nil]
		w: 	a WorldMorph(603310592) [world]
		selArgCount: 	1
	Receiver's instance variables: 
		bounds: 	(601.0@336.0) corner: (723.0@353.0)
		owner: 	a MenuMorph(242376960)
		submorphs: 	#()
		fullBounds: 	(601.0@336.0) corner: (723.0@353.0)
		color: 	Color white
		extension: 	a MorphExtension (911430656) [balloonText]  [other:  (kmDispatcher -...etc...
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Do it'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a SpMorphicMenuItemAdapter
		selector: 	#performMenuActionWith:
		arguments: 	an Array(a SpMorphicMenuItemAdapter)
		icon: 	Form(13x13x32)
		keyText: 	'⌘D'
		getStateSelector: 	nil
		enablementSelector: 	#enabled


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ | selArgCount |  "show cursor in case item opens a new MVC window"
		(selArgCount := sel...etc...
	Arguments and temporary variables: 
		aBlock: 	[oldcursor show]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
		startpc: 	a CompiledBlock: [ | selArgCount |  "show cursor in case item opens a ...etc...
		numArgs: 	0
		receiver: 	a SpToggleMenuItemMorph(1007108864)'Do it'


CursorWithMask(Cursor)>>showWhile:
	Receiver: ((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0
		2r100000000000000000000...etc...
	Arguments and temporary variables: 
		aBlock: 	[ | selArgCount |  "show cursor in case item opens a new MVC window"
		...etc...
		oldcursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0
		2...etc...
	Receiver's instance variables: 
		bits: 	a Bitmap of length 16
		width: 	16
		height: 	16
		depth: 	1
		offset: 	(-1@ -1)
		maskForm: 	Form(16x16x1)


SpToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
	Receiver: a SpToggleMenuItemMorph(1007108864)'Do it'
	Arguments and temporary variables: 
		evt: 	[(625@344) mouseUp 3226529 nil]
		w: 	a WorldMorph(603310592) [world]
	Receiver's instance variables: 
		bounds: 	(601.0@336.0) corner: (723.0@353.0)
		owner: 	a MenuMorph(242376960)
		submorphs: 	#()
		fullBounds: 	(601.0@336.0) corner: (723.0@353.0)
		color: 	Color white
		extension: 	a MorphExtension (911430656) [balloonText]  [other:  (kmDispatcher -...etc...
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Do it'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a SpMorphicMenuItemAdapter
		selector: 	#performMenuActionWith:
		arguments: 	an Array(a SpMorphicMenuItemAdapter)
		icon: 	Form(13x13x32)
		keyText: 	'⌘D'
		getStateSelector: 	nil
		enablementSelector: 	#enabled


SpToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
	Receiver: a SpToggleMenuItemMorph(1007108864)'Do it'
	Arguments and temporary variables: 
		evt: 	[(625@344) mouseUp 3226529 nil]
	Receiver's instance variables: 
		bounds: 	(601.0@336.0) corner: (723.0@353.0)
		owner: 	a MenuMorph(242376960)
		submorphs: 	#()
		fullBounds: 	(601.0@336.0) corner: (723.0@353.0)
		color: 	Color white
		extension: 	a MorphExtension (911430656) [balloonText]  [other:  (kmDispatcher -...etc...
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Do it'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a SpMorphicMenuItemAdapter
		selector: 	#performMenuActionWith:
		arguments: 	an Array(a SpMorphicMenuItemAdapter)
		icon: 	Form(13x13x32)
		keyText: 	'⌘D'
		getStateSelector: 	nil
		enablementSelector: 	#enabled


SpToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
	Receiver: a SpToggleMenuItemMorph(1007108864)'Do it'
	Arguments and temporary variables: 
		anEvent: 	[(625@344) mouseUp 3226529 nil]
	Receiver's instance variables: 
		bounds: 	(601.0@336.0) corner: (723.0@353.0)
		owner: 	a MenuMorph(242376960)
		submorphs: 	#()
		fullBounds: 	(601.0@336.0) corner: (723.0@353.0)
		color: 	Color white
		extension: 	a MorphExtension (911430656) [balloonText]  [other:  (kmDispatcher -...etc...
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Do it'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a SpMorphicMenuItemAdapter
		selector: 	#performMenuActionWith:
		arguments: 	an Array(a SpMorphicMenuItemAdapter)
		icon: 	Form(13x13x32)
		keyText: 	'⌘D'
		getStateSelector: 	nil
		enablementSelector: 	#enabled


MouseButtonEvent>>sentTo:
	Receiver: [(625@344) mouseUp 3226529 nil]
	Arguments and temporary variables: 
		anObject: 	a SpToggleMenuItemMorph(1007108864)'Do it'
	Receiver's instance variables: 
		timeStamp: 	3226529
		source: 	a HandMorph(986102528)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(625@344)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


SpToggleMenuItemMorph(Morph)>>handleEvent:
	Receiver: a SpToggleMenuItemMorph(1007108864)'Do it'
	Arguments and temporary variables: 
		anEvent: 	[(625@344) mouseUp 3226529 nil]
	Receiver's instance variables: 
		bounds: 	(601.0@336.0) corner: (723.0@353.0)
		owner: 	a MenuMorph(242376960)
		submorphs: 	#()
		fullBounds: 	(601.0@336.0) corner: (723.0@353.0)
		color: 	Color white
		extension: 	a MorphExtension (911430656) [balloonText]  [other:  (kmDispatcher -...etc...
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Do it'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a SpMorphicMenuItemAdapter
		selector: 	#performMenuActionWith:
		arguments: 	an Array(a SpMorphicMenuItemAdapter)
		icon: 	Form(13x13x32)
		keyText: 	'⌘D'
		getStateSelector: 	nil
		enablementSelector: 	#enabled


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(625@344) mouseUp 3226529 nil]
		aMorph: 	a SpToggleMenuItemMorph(1007108864)'Do it'
		localEvt: 	nil
		index: 	1
		child: 	nil
		morphs: 	#()
		inside: 	true
	Receiver's instance variables: 
		morph: 	a SpToggleMenuItemMorph(1007108864)'Do it'


MorphicEventDispatcher>>handleMouseUp:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(625@344) mouseUp 3226529 nil]
	Receiver's instance variables: 
		morph: 	a SpToggleMenuItemMorph(1007108864)'Do it'



--- The full stack ---
Pile class(Object)>>doesNotUnderstand: #initialize:
Pile class>>new:
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ aCommand execute ] in SpMenuPresenterBuilder>>fillItem:with:
FullBlockClosure(BlockClosure)>>cull:
SpMenuItemPresenter>>performMenuActionWith:
SpMorphicMenuItemAdapter>>performMenuActionWith:
[ | selArgCount |  "show cursor in case item opens a new MVC window"
		(selArgCount := selector numArgs) = 0
			ifTrue:
				[target perform: selector]
			ifFalse:
				[selArgCount = arguments size
					ifTrue: [target perform: selector withArguments: arguments]
					ifFalse: [target perform: selector withArguments: (arguments copyWith: evt)]].
		self showShortcut.
		self changed] in SpToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
SpToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
SpToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
SpToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
SpToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
SpToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MenuMorph(Morph)>>processEvent:using:
MenuMorph(Morph)>>processEvent:
MenuMorph>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
MenuMorph>>invokeAt:in:allowKeyboard:
MenuMorph>>invokeAt:in:
MenuMorph>>invokeModal
RubEditingArea(RubAbstractTextArea)>>yellowButtonActivity:
RubEditingArea(RubAbstractTextArea)>>mouseDown:
RubEditingArea(Morph)>>handleMouseDown:
MouseButtonEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
RubEditingArea(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
TransformWithLayoutMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
RubTextScrollPane(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
SpRubScrolledTextMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
Morph>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
Morph>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
Morph>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
TransformWithLayoutMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MillerScrollPane(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
Morph>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
Morph>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
Morph>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
Morph>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
Morph>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
SpWindow(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
-- and more not shown ---------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of Object class did not understand #initialize:
26 September 2022 7:12:45.552082 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
StackToRegisterMappingCogit * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
v9.0.18 - Commit: 7249c170 - Date: 2022-09-02 14:31:12 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

Pile class(Object)>>doesNotUnderstand: #initialize:
	Receiver: Pile
	Arguments and temporary variables: 
		aMessage: 	initialize: nil
		exception: 	Instance of Object class did not understand #initialize:
		resumeValue: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#grow->Pile>>#grow #initialize:->Pile>>#initiali...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#Pile
		classPool: 	a Dictionary(#tailleDefaut->nil )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#HAI914I


Pile class>>new:
	Receiver: Pile
	Arguments and temporary variables: 
		taille: 	4
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#grow->Pile>>#grow #initialize:->Pile>>#initiali...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#Pile
		classPool: 	a Dictionary(#tailleDefaut->nil )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#HAI914I


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ p := Pile new: 4
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ p := Pile new: 4
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'p:= Pile new: 4.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#p->nil )
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 16) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'p:= Pile new: 4.' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#p->nil )
		aString: 	'p:= Pile new: 4.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 16) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'p:= Pile new: 4.' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aString: 	'p:= Pile new: 4.'
		aBlock: 	[ :result | ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | ]
		selection: 	'p:= Pile new: 4.'
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand>>execute
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodeDoItCommand
		iconProvider: 	a ThemeIcons(idea11)
		iconName: 	#smallDoIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ aCommand execute ] in SpMenuPresenterBuilder>>fillItem:with:
	Receiver: a SpMenuPresenterBuilder
	Arguments and temporary variables: 
		aMenuItem: 	a SpMenuItemPresenter
		aCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		menuPresenter: 	a SpMenuPresenter
		stack: 	a Stack(a SpMenuPresenter)


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ aCommand execute ]
	Arguments and temporary variables: 
		anArg: 	a SpMorphicMenuItemAdapter
	Receiver's instance variables: 
		outerContext: 	SpMenuPresenterBuilder>>fillItem:with:
		startpc: 	a CompiledBlock: [ aCommand execute ]
		numArgs: 	0
		receiver: 	a SpMenuPresenterBuilder


SpMenuItemPresenter>>performMenuActionWith:
	Receiver: a SpMenuItemPresenter
	Arguments and temporary variables: 
		aMenuItem: 	a SpMorphicMenuItemAdapter
		en: 	true
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicMenuItemAdapter)
		announcer: 	an Announcer
		owner: 	a SpMenuGroupPresenter
		adapter: 	a SpMorphicMenuItemAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		name: 	an ObservableValueHolder[ 'Do it' ]
		icon: 	an ObservableValueHolder[ Form(13x13x32) ]
		description: 	an ObservableValueHolder[ 'Evaluate selection.' ]
		action: 	[ aCommand execute ]
		shortcut: 	a KMKeyCombinationChoice
		subMenu: 	nil
		state: 	nil
		autoRefresh: 	false


SpMorphicMenuItemAdapter>>performMenuActionWith:
	Receiver: a SpMorphicMenuItemAdapter
	Arguments and temporary variables: 
		arguments: 	a SpMorphicMenuItemAdapter
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	nil
		model: 	a SpMenuItemPresenter
		widget: 	a SpToggleMenuItemMorph(1007108864)'Do it'
		selector: 	nil
		owner: 	a SpMenuItemPresenter


[ | selArgCount |  "show cursor in case item opens a new MVC window"
		(selArgCount := selector numArgs) = 0
			ifTrue:
				[target perform: selector]
			ifFalse:
				[selArgCount = arguments size
					ifTrue: [target perform: selector withArguments: arguments]
					ifFalse: [target perform: selector withArguments: (arguments copyWith: evt)]].
		self showShortcut.
		self changed] in SpToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
	Receiver: a SpToggleMenuItemMorph(1007108864)'Do it'
	Arguments and temporary variables: 
		evt: 	[(625@344) mouseUp 3226529 nil]
		w: 	a WorldMorph(603310592) [world]
		selArgCount: 	1
	Receiver's instance variables: 
		bounds: 	(601.0@336.0) corner: (723.0@353.0)
		owner: 	a MenuMorph(242376960)
		submorphs: 	#()
		fullBounds: 	(601.0@336.0) corner: (723.0@353.0)
		color: 	Color white
		extension: 	a MorphExtension (911430656) [balloonText]  [other:  (kmDispatcher -...etc...
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Do it'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a SpMorphicMenuItemAdapter
		selector: 	#performMenuActionWith:
		arguments: 	an Array(a SpMorphicMenuItemAdapter)
		icon: 	Form(13x13x32)
		keyText: 	'⌘D'
		getStateSelector: 	nil
		enablementSelector: 	#enabled


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ | selArgCount |  "show cursor in case item opens a new MVC window"
		(selArgCount := sel...etc...
	Arguments and temporary variables: 
		aBlock: 	[oldcursor show]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
		startpc: 	a CompiledBlock: [ | selArgCount |  "show cursor in case item opens a ...etc...
		numArgs: 	0
		receiver: 	a SpToggleMenuItemMorph(1007108864)'Do it'


CursorWithMask(Cursor)>>showWhile:
	Receiver: ((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0
		2r100000000000000000000...etc...
	Arguments and temporary variables: 
		aBlock: 	[ | selArgCount |  "show cursor in case item opens a new MVC window"
		...etc...
		oldcursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0
		2...etc...
	Receiver's instance variables: 
		bits: 	a Bitmap of length 16
		width: 	16
		height: 	16
		depth: 	1
		offset: 	(-1@ -1)
		maskForm: 	Form(16x16x1)


SpToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
	Receiver: a SpToggleMenuItemMorph(1007108864)'Do it'
	Arguments and temporary variables: 
		evt: 	[(625@344) mouseUp 3226529 nil]
		w: 	a WorldMorph(603310592) [world]
	Receiver's instance variables: 
		bounds: 	(601.0@336.0) corner: (723.0@353.0)
		owner: 	a MenuMorph(242376960)
		submorphs: 	#()
		fullBounds: 	(601.0@336.0) corner: (723.0@353.0)
		color: 	Color white
		extension: 	a MorphExtension (911430656) [balloonText]  [other:  (kmDispatcher -...etc...
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Do it'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a SpMorphicMenuItemAdapter
		selector: 	#performMenuActionWith:
		arguments: 	an Array(a SpMorphicMenuItemAdapter)
		icon: 	Form(13x13x32)
		keyText: 	'⌘D'
		getStateSelector: 	nil
		enablementSelector: 	#enabled


SpToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
	Receiver: a SpToggleMenuItemMorph(1007108864)'Do it'
	Arguments and temporary variables: 
		evt: 	[(625@344) mouseUp 3226529 nil]
	Receiver's instance variables: 
		bounds: 	(601.0@336.0) corner: (723.0@353.0)
		owner: 	a MenuMorph(242376960)
		submorphs: 	#()
		fullBounds: 	(601.0@336.0) corner: (723.0@353.0)
		color: 	Color white
		extension: 	a MorphExtension (911430656) [balloonText]  [other:  (kmDispatcher -...etc...
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Do it'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a SpMorphicMenuItemAdapter
		selector: 	#performMenuActionWith:
		arguments: 	an Array(a SpMorphicMenuItemAdapter)
		icon: 	Form(13x13x32)
		keyText: 	'⌘D'
		getStateSelector: 	nil
		enablementSelector: 	#enabled


SpToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
	Receiver: a SpToggleMenuItemMorph(1007108864)'Do it'
	Arguments and temporary variables: 
		anEvent: 	[(625@344) mouseUp 3226529 nil]
	Receiver's instance variables: 
		bounds: 	(601.0@336.0) corner: (723.0@353.0)
		owner: 	a MenuMorph(242376960)
		submorphs: 	#()
		fullBounds: 	(601.0@336.0) corner: (723.0@353.0)
		color: 	Color white
		extension: 	a MorphExtension (911430656) [balloonText]  [other:  (kmDispatcher -...etc...
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Do it'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a SpMorphicMenuItemAdapter
		selector: 	#performMenuActionWith:
		arguments: 	an Array(a SpMorphicMenuItemAdapter)
		icon: 	Form(13x13x32)
		keyText: 	'⌘D'
		getStateSelector: 	nil
		enablementSelector: 	#enabled


MouseButtonEvent>>sentTo:
	Receiver: [(625@344) mouseUp 3226529 nil]
	Arguments and temporary variables: 
		anObject: 	a SpToggleMenuItemMorph(1007108864)'Do it'
	Receiver's instance variables: 
		timeStamp: 	3226529
		source: 	a HandMorph(986102528)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(625@344)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


SpToggleMenuItemMorph(Morph)>>handleEvent:
	Receiver: a SpToggleMenuItemMorph(1007108864)'Do it'
	Arguments and temporary variables: 
		anEvent: 	[(625@344) mouseUp 3226529 nil]
	Receiver's instance variables: 
		bounds: 	(601.0@336.0) corner: (723.0@353.0)
		owner: 	a MenuMorph(242376960)
		submorphs: 	#()
		fullBounds: 	(601.0@336.0) corner: (723.0@353.0)
		color: 	Color white
		extension: 	a MorphExtension (911430656) [balloonText]  [other:  (kmDispatcher -...etc...
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Do it'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a SpMorphicMenuItemAdapter
		selector: 	#performMenuActionWith:
		arguments: 	an Array(a SpMorphicMenuItemAdapter)
		icon: 	Form(13x13x32)
		keyText: 	'⌘D'
		getStateSelector: 	nil
		enablementSelector: 	#enabled


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(625@344) mouseUp 3226529 nil]
		aMorph: 	a SpToggleMenuItemMorph(1007108864)'Do it'
		localEvt: 	nil
		index: 	1
		child: 	nil
		morphs: 	#()
		inside: 	true
	Receiver's instance variables: 
		morph: 	a SpToggleMenuItemMorph(1007108864)'Do it'


MorphicEventDispatcher>>handleMouseUp:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(625@344) mouseUp 3226529 nil]
	Receiver's instance variables: 
		morph: 	a SpToggleMenuItemMorph(1007108864)'Do it'



--- The full stack ---
Pile class(Object)>>doesNotUnderstand: #initialize:
Pile class>>new:
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ aCommand execute ] in SpMenuPresenterBuilder>>fillItem:with:
FullBlockClosure(BlockClosure)>>cull:
SpMenuItemPresenter>>performMenuActionWith:
SpMorphicMenuItemAdapter>>performMenuActionWith:
[ | selArgCount |  "show cursor in case item opens a new MVC window"
		(selArgCount := selector numArgs) = 0
			ifTrue:
				[target perform: selector]
			ifFalse:
				[selArgCount = arguments size
					ifTrue: [target perform: selector withArguments: arguments]
					ifFalse: [target perform: selector withArguments: (arguments copyWith: evt)]].
		self showShortcut.
		self changed] in SpToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
SpToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
SpToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
SpToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
SpToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
SpToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MenuMorph(Morph)>>processEvent:using:
MenuMorph(Morph)>>processEvent:
MenuMorph>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
MenuMorph>>invokeAt:in:allowKeyboard:
MenuMorph>>invokeAt:in:
MenuMorph>>invokeModal
RubEditingArea(RubAbstractTextArea)>>yellowButtonActivity:
RubEditingArea(RubAbstractTextArea)>>mouseDown:
RubEditingArea(Morph)>>handleMouseDown:
MouseButtonEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
RubEditingArea(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
TransformWithLayoutMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
RubTextScrollPane(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
SpRubScrolledTextMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
Morph>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
Morph>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
Morph>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
TransformWithLayoutMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MillerScrollPane(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
Morph>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
Morph>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
Morph>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
Morph>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
Morph>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
SpWindow(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
-- and more not shown ---------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
AssertionFailure: Project location must exist!
26 September 2022 7:24:55.865136 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
StackToRegisterMappingCogit * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
v9.0.18 - Commit: 7249c170 - Date: 2022-09-02 14:31:12 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

IceTipLocalRepositoryPanel(Object)>>assert:description:
	Receiver: an IceTipLocalRepositoryPanel
	Arguments and temporary variables: 
		aBlock: 	false
		aStringOrBlock: 	'Project location must exist!'
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	an IceTipRegisterRepositoryDialog
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		projectLocation: 	an IceTipDirectoryPresenter
		remoteLabel: 	nil
		remoteInputText: 	nil
		repository: 	nil


IceTipLocalRepositoryPanel>>validate
	Receiver: an IceTipLocalRepositoryPanel
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	an IceTipRegisterRepositoryDialog
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		projectLocation: 	an IceTipDirectoryPresenter
		remoteLabel: 	nil
		remoteInputText: 	nil
		repository: 	nil


IceTipRegisterRepositoryDialog>>doAccept
	Receiver: an IceTipRegisterRepositoryDialog
	Arguments and temporary variables: 
		newRepository: 	nil
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		owner: 	a SpDialogWindowPresenter
		adapter: 	a SpMorphicPanedAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a SpNullApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpPanedLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		typeList: 	a SpTablePresenter
		type: 	an IceTipLocalRepositoryPanel
		contentPanel: 	an IceTipLocalRepositoryPanel
		types: 	an OrderedCollection(an IceTipNewRepositoryPanel an IceTipLocalRepositor...etc...
		repository: 	nil
		acceptBlock: 	nil


[ self doAccept ] in IceTipRegisterRepositoryDialog(IceTipOptionDialog)>>initializeDialogWindow:
	Receiver: an IceTipRegisterRepositoryDialog
	Arguments and temporary variables: 
		aWindowPresenter: 	a SpDialogWindowPresenter
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		owner: 	a SpDialogWindowPresenter
		adapter: 	a SpMorphicPanedAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a SpNullApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpPanedLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		typeList: 	a SpTablePresenter
		type: 	an IceTipLocalRepositoryPanel
		contentPanel: 	an IceTipLocalRepositoryPanel
		types: 	an OrderedCollection(an IceTipNewRepositoryPanel an IceTipLocalRepositor...etc...
		repository: 	nil
		acceptBlock: 	nil


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ self doAccept ]
	Arguments and temporary variables: 
		anArg: 	a SpDialogWindowPresenter
	Receiver's instance variables: 
		outerContext: 	IceTipRegisterRepositoryDialog(IceTipOptionDialog)>>initializeDia...etc...
		startpc: 	a CompiledBlock: [ self doAccept ]
		numArgs: 	0
		receiver: 	an IceTipRegisterRepositoryDialog


SpDialogWindowPresenter>>triggerOkAction
	Receiver: a SpDialogWindowPresenter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicDialogWindowAdapter a SpDialogWindow(3...etc...
		announcer: 	an Announcer
		owner: 	nil
		adapter: 	a SpMorphicDialogWindowAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a SpNullApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ Form(16x16x32) ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ true ]
		titleHolder: 	an ObservableValueHolder[ 'Import from existing clone' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ nil ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		presenter: 	an ObservableValueHolder[ an IceTipRegisterRepositoryDialog ]
		initialPosition: 	an ObservableValueHolder[ nil ]
		initialExtent: 	an ObservableValueHolder[ (600@300) ]
		isResizeable: 	an ObservableValueHolder[ true ]
		menu: 	an ObservableValueHolder[ nil ]
		centered: 	an ObservableValueHolder[ false ]
		isClosed: 	an ObservableValueHolder[ false ]
		toolbar: 	an ObservableValueHolder[ nil ]
		statusbar: 	an ObservableValueHolder[ nil ]
		window: 	an ObservableValueHolder[ a SpDialogWindow(308885760) named: Import fro...etc...
		decorations: 	an ObservableValueHolder[ true ]
		buttons: 	an OrderedCollection(a SpButtonPresenter a SpButtonPresenter)
		okAction: 	[ self doAccept ]
		cancelAction: 	[ 
		cancelled := true.
		self close ]
		cancelled: 	true
		defaultButton: 	nil


[ :presenter | 
			presenter triggerOkAction.
			presenter close ] in SpAbstractPresenter>>initializeDialogWindow:
	Receiver: an IceTipRegisterRepositoryDialog
	Arguments and temporary variables: 
		aDialogWindowPresenter: 	a SpDialogWindowPresenter
		presenter: 	a SpDialogWindowPresenter
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		owner: 	a SpDialogWindowPresenter
		adapter: 	a SpMorphicPanedAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a SpNullApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpPanedLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		typeList: 	a SpTablePresenter
		type: 	an IceTipLocalRepositoryPanel
		contentPanel: 	an IceTipLocalRepositoryPanel
		types: 	an OrderedCollection(an IceTipNewRepositoryPanel an IceTipLocalRepositor...etc...
		repository: 	nil
		acceptBlock: 	nil


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ :presenter | 
			presenter triggerOkAction.
			presenter close ]
	Arguments and temporary variables: 
		anArg: 	a SpDialogWindowPresenter
	Receiver's instance variables: 
		outerContext: 	IceTipRegisterRepositoryDialog(SpAbstractPresenter)>>initializeDi...etc...
		startpc: 	a CompiledBlock: [ :presenter | 
			presenter triggerOkAction.
			pres...etc...
		numArgs: 	1
		receiver: 	an IceTipRegisterRepositoryDialog


[ aBlock cull: self ] in SpDialogWindowPresenter>>addButton:do:
	Receiver: a SpDialogWindowPresenter
	Arguments and temporary variables: 
		aString: 	'Ok'
		aBlock: 	[ :presenter | 
			presenter triggerOkAction.
			presenter close ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicDialogWindowAdapter a SpDialogWindow(3...etc...
		announcer: 	an Announcer
		owner: 	nil
		adapter: 	a SpMorphicDialogWindowAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a SpNullApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ Form(16x16x32) ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ true ]
		titleHolder: 	an ObservableValueHolder[ 'Import from existing clone' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ nil ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		presenter: 	an ObservableValueHolder[ an IceTipRegisterRepositoryDialog ]
		initialPosition: 	an ObservableValueHolder[ nil ]
		initialExtent: 	an ObservableValueHolder[ (600@300) ]
		isResizeable: 	an ObservableValueHolder[ true ]
		menu: 	an ObservableValueHolder[ nil ]
		centered: 	an ObservableValueHolder[ false ]
		isClosed: 	an ObservableValueHolder[ false ]
		toolbar: 	an ObservableValueHolder[ nil ]
		statusbar: 	an ObservableValueHolder[ nil ]
		window: 	an ObservableValueHolder[ a SpDialogWindow(308885760) named: Import fro...etc...
		decorations: 	an ObservableValueHolder[ true ]
		buttons: 	an OrderedCollection(a SpButtonPresenter a SpButtonPresenter)
		okAction: 	[ self doAccept ]
		cancelAction: 	[ 
		cancelled := true.
		self close ]
		cancelled: 	true
		defaultButton: 	nil


SpButtonPresenter>>performAction
	Receiver: a SpButtonPresenter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicButtonAdapter)
		announcer: 	an Announcer
		owner: 	a SpButtonBarPresenter
		adapter: 	a SpMorphicButtonAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Button' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		icon: 	an ObservableValueHolder[ nil ]
		label: 	an ObservableValueHolder[ 'Ok' ]
		action: 	an ObservableValueHolder[ [ aBlock cull: self ] ]
		actionPerformed: 	an ObservableValueHolder[ nil ]
		askBeforeChanging: 	an ObservableValueHolder[ false ]
		font: 	an ObservableValueHolder[ nil ]
		shortcut: 	an ObservableValueHolder[ nil ]
		state: 	an ObservableValueHolder[ false ]
		contextMenu: 	an ObservableValueHolder[ nil ]


SpMorphicButtonAdapter>>action
	Receiver: a SpMorphicButtonAdapter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a PluggableButtonMorph(335468288))
		announcer: 	nil
		model: 	a SpButtonPresenter
		widget: 	a PluggableButtonMorph(335468288)
		selector: 	nil
		owner: 	a SpButtonPresenter
		subMenuWidget: 	nil
		styleName: 	nil


PluggableButtonMorph>>performAction:
	Receiver: a PluggableButtonMorph(335468288)
	Arguments and temporary variables: 
		event: 	[(816@448) mouseUp 149507 nil]
	Receiver's instance variables: 
		bounds: 	(769.0@436.0) corner: (869.0@466.0)
		owner: 	a PanelMorph(1071747072)
		submorphs: 	an Array(an AlignmentMorph(502232320))
		fullBounds: 	nil
		color: 	(Color r: 0.2903225806451613 g: 0.2883675464320626 b: 0.2883675464320626...etc...
		extension: 	a MorphExtension (169478144) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a SpMorphicButtonAdapter
		label: 	'Ok'
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	#state
		actionSelector: 	#action
		font: 	nil
		getLabelSelector: 	#label
		getMenuSelector: 	#menu:
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		getFontSelector: 	#font
		labelMorph: 	a LabelMorph(236987904)'Ok'
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	false


[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(335468288)
	Arguments and temporary variables: 
		evt: 	[(816@448) mouseUp 149507 nil]
		all: 	an Array(a PluggableButtonMorph(857193472) a PluggableButtonMorph(33546828...etc...
		m: 	a PluggableButtonMorph(335468288)
	Receiver's instance variables: 
		bounds: 	(769.0@436.0) corner: (869.0@466.0)
		owner: 	a PanelMorph(1071747072)
		submorphs: 	an Array(an AlignmentMorph(502232320))
		fullBounds: 	nil
		color: 	(Color r: 0.2903225806451613 g: 0.2883675464320626 b: 0.2883675464320626...etc...
		extension: 	a MorphExtension (169478144) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a SpMorphicButtonAdapter
		label: 	'Ok'
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	#state
		actionSelector: 	#action
		font: 	nil
		getLabelSelector: 	#label
		getMenuSelector: 	#menu:
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		getFontSelector: 	#font
		labelMorph: 	a LabelMorph(236987904)'Ok'
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	false


Array(SequenceableCollection)>>do:
	Receiver: an Array(a PluggableButtonMorph(857193472) a PluggableButtonMorph(335468288))
	Arguments and temporary variables: 
		aBlock: 	[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [...etc...
		index: 	2
	Receiver's instance variables: 
an Array(a PluggableButtonMorph(857193472) a PluggableButtonMorph(335468288))

PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(335468288)
	Arguments and temporary variables: 
		evt: 	[(816@448) mouseUp 149507 nil]
		all: 	an Array(a PluggableButtonMorph(857193472) a PluggableButtonMorph(33546828...etc...
	Receiver's instance variables: 
		bounds: 	(769.0@436.0) corner: (869.0@466.0)
		owner: 	a PanelMorph(1071747072)
		submorphs: 	an Array(an AlignmentMorph(502232320))
		fullBounds: 	nil
		color: 	(Color r: 0.2903225806451613 g: 0.2883675464320626 b: 0.2883675464320626...etc...
		extension: 	a MorphExtension (169478144) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a SpMorphicButtonAdapter
		label: 	'Ok'
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	#state
		actionSelector: 	#action
		font: 	nil
		getLabelSelector: 	#label
		getMenuSelector: 	#menu:
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		getFontSelector: 	#font
		labelMorph: 	a LabelMorph(236987904)'Ok'
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	false


PluggableButtonMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableButtonMorph(335468288)
	Arguments and temporary variables: 
		anEvent: 	[(816@448) mouseUp 149507 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(769.0@436.0) corner: (869.0@466.0)
		owner: 	a PanelMorph(1071747072)
		submorphs: 	an Array(an AlignmentMorph(502232320))
		fullBounds: 	nil
		color: 	(Color r: 0.2903225806451613 g: 0.2883675464320626 b: 0.2883675464320626...etc...
		extension: 	a MorphExtension (169478144) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a SpMorphicButtonAdapter
		label: 	'Ok'
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	#state
		actionSelector: 	#action
		font: 	nil
		getLabelSelector: 	#label
		getMenuSelector: 	#menu:
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		getFontSelector: 	#font
		labelMorph: 	a LabelMorph(236987904)'Ok'
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	false


MouseButtonEvent>>sentTo:
	Receiver: [(816@448) mouseUp 149507 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableButtonMorph(335468288)
	Receiver's instance variables: 
		timeStamp: 	149507
		source: 	a HandMorph(986102528)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(816@448)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableButtonMorph(Morph)>>handleEvent:
	Receiver: a PluggableButtonMorph(335468288)
	Arguments and temporary variables: 
		anEvent: 	[(816@448) mouseUp 149507 nil]
	Receiver's instance variables: 
		bounds: 	(769.0@436.0) corner: (869.0@466.0)
		owner: 	a PanelMorph(1071747072)
		submorphs: 	an Array(an AlignmentMorph(502232320))
		fullBounds: 	nil
		color: 	(Color r: 0.2903225806451613 g: 0.2883675464320626 b: 0.2883675464320626...etc...
		extension: 	a MorphExtension (169478144) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a SpMorphicButtonAdapter
		label: 	'Ok'
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	#state
		actionSelector: 	#action
		font: 	nil
		getLabelSelector: 	#label
		getMenuSelector: 	#menu:
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		getFontSelector: 	#font
		labelMorph: 	a LabelMorph(236987904)'Ok'
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	false


PluggableButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a PluggableButtonMorph(335468288)
	Arguments and temporary variables: 
		anEvent: 	[(816@448) mouseUp 149507 nil]
	Receiver's instance variables: 
		bounds: 	(769.0@436.0) corner: (869.0@466.0)
		owner: 	a PanelMorph(1071747072)
		submorphs: 	an Array(an AlignmentMorph(502232320))
		fullBounds: 	nil
		color: 	(Color r: 0.2903225806451613 g: 0.2883675464320626 b: 0.2883675464320626...etc...
		extension: 	a MorphExtension (169478144) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a SpMorphicButtonAdapter
		label: 	'Ok'
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	#state
		actionSelector: 	#action
		font: 	nil
		getLabelSelector: 	#label
		getMenuSelector: 	#menu:
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		getFontSelector: 	#font
		labelMorph: 	a LabelMorph(236987904)'Ok'
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	false


[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(986102528)
	Arguments and temporary variables: 
		anEvent: 	[(816@448) mouseUp 149507 nil]
		focusHolder: 	a PluggableButtonMorph(335468288)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(603310592) [world]
		transformedEvent: 	[(816@448) mouseUp 149507 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(816@448) corner: (832@464)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	#()
		fullBounds: 	(816@448) corner: (832@464)
		color: 	Color blue
		extension: 	a MorphExtension (1065441536)
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(335468288)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(816@448) mouseUp 149507 nil]
		targetOffset: 	(47.0@12.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		lastKeyScanCode: 	nil
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		result := focusHolder handleFocusEvent: transformedEvent.
	]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
			ActiveWorld := priorWorld.
			ex pass ]
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	a CompiledBlock: [
		result := focusHolder handleFocusEvent: transform...etc...
		numArgs: 	0
		receiver: 	a HandMorph(986102528)


WorldMorph>>becomeActiveDuring:
	Receiver: a WorldMorph(603310592) [world]
	Arguments and temporary variables: 
		aBlock: 	[
		result := focusHolder handleFocusEvent: transformedEvent.
	]
		priorWorld: 	a WorldMorph(603310592) [world]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1512@851)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(1021235712) a TaskbarMorph(882262784) a SpDi...etc...
		fullBounds: 	(0@0) corner: (1512@851)
		color: 	(Color r: 0.29521016617790813 g: 0.29521016617790813 b: 0.29521016617790...etc...
		extension: 	a MorphExtension (219690240) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(986102528)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(816@448) mouseUp 149507 nil]
		focusHolder: 	a PluggableButtonMorph(335468288)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(603310592) [world]
		transformedEvent: 	[(816@448) mouseUp 149507 nil]
	Receiver's instance variables: 
		bounds: 	(816@448) corner: (832@464)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	#()
		fullBounds: 	(816@448) corner: (832@464)
		color: 	Color blue
		extension: 	a MorphExtension (1065441536)
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(335468288)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(816@448) mouseUp 149507 nil]
		targetOffset: 	(47.0@12.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		lastKeyScanCode: 	nil
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(986102528)
	Arguments and temporary variables: 
		anEvent: 	[(816@448) mouseUp 149507 nil]
		focusHolder: 	a PluggableButtonMorph(335468288)
		aBlock: 	[self mouseFocus: nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(816@448) corner: (832@464)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	#()
		fullBounds: 	(816@448) corner: (832@464)
		color: 	Color blue
		extension: 	a MorphExtension (1065441536)
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(335468288)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(816@448) mouseUp 149507 nil]
		targetOffset: 	(47.0@12.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		lastKeyScanCode: 	nil
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(986102528)
	Arguments and temporary variables: 
		anEvent: 	[(816@448) mouseUp 149507 nil]
	Receiver's instance variables: 
		bounds: 	(816@448) corner: (832@464)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	#()
		fullBounds: 	(816@448) corner: (832@464)
		color: 	Color blue
		extension: 	a MorphExtension (1065441536)
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(335468288)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(816@448) mouseUp 149507 nil]
		targetOffset: 	(47.0@12.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		lastKeyScanCode: 	nil
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>handleEvent:
	Receiver: a HandMorph(986102528)
	Arguments and temporary variables: 
		anEvent: 	[(816@448) mouseUp 149507 nil]
		evt: 	[(816@448) mouseUp 149507 nil]
	Receiver's instance variables: 
		bounds: 	(816@448) corner: (832@464)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	#()
		fullBounds: 	(816@448) corner: (832@464)
		color: 	Color blue
		extension: 	a MorphExtension (1065441536)
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(335468288)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(816@448) mouseUp 149507 nil]
		targetOffset: 	(47.0@12.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		lastKeyScanCode: 	nil
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
	Receiver: an OSWindowMorphicEventHandler
	Arguments and temporary variables: 
		anEvent: 	[(816@448) mouseUp 149507 nil]
	Receiver's instance variables: 
		morphicWorld: 	a WorldMorph(603310592) [world]


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(603310592) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(986102528))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	21497
		lastStepMessage: 	nil
		alarms: 	a Heap()
		lastAlarmTime: 	149479
		activeHand: 	a HandMorph(986102528)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1512@851)


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(603310592) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1512@851)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(1021235712) a TaskbarMorph(882262784) a SpDi...etc...
		fullBounds: 	(0@0) corner: (1512@851)
		color: 	(Color r: 0.29521016617790813 g: 0.29521016617790813 b: 0.29521016617790...etc...
		extension: 	a MorphExtension (219690240) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(603310592) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(986102528))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	21497
		lastStepMessage: 	nil
		alarms: 	a Heap()
		lastAlarmTime: 	149479
		activeHand: 	a HandMorph(986102528)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1512@851)


WorldMorph>>doOneCycleNow
	Receiver: a WorldMorph(603310592) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1512@851)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(1021235712) a TaskbarMorph(882262784) a SpDi...etc...
		fullBounds: 	(0@0) corner: (1512@851)
		color: 	(Color r: 0.29521016617790813 g: 0.29521016617790813 b: 0.29521016617790...etc...
		extension: 	a MorphExtension (219690240) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(603310592) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1512@851)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(1021235712) a TaskbarMorph(882262784) a SpDi...etc...
		fullBounds: 	(0@0) corner: (1512@851)
		color: 	(Color r: 0.29521016617790813 g: 0.29521016617790813 b: 0.29521016617790...etc...
		extension: 	a MorphExtension (219690240) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 
		extraWorldsToDraw: 	#()
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65547
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->nil #CursorOwnerWorld->a WorldMorph(60...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		announcer: 	nil
		displayScaleFactor: 	1


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extr...etc...
	Arguments and temporary variables: 
		aBlock: 	[
		self doInterCycleWait
	]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	WorldMorph class>>doOneCycle
		startpc: 	a CompiledBlock: [
		| extraWorldsToDraw |
		extraWorldsToDraw := Extr...etc...
		numArgs: 	0
		receiver: 	WorldMorph


WorldState class>>doDrawCycleWith:
	Receiver: WorldState
	Arguments and temporary variables: 
		aBlock: 	[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex cr...etc...
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#activeHand->WorldState>>#activeHand #activeHand...etc...
		format: 	65547
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldState}
		name: 	#WorldState
		classPool: 	a Dictionary(#CanSurrenderToOS->nil #DebugShowDamage->false #Deferre...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'


WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65547
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->nil #CursorOwnerWorld->a WorldMorph(60...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		announcer: 	nil
		displayScaleFactor: 	1


MorphicRenderLoop>>doOneCycle
	Receiver: a MorphicRenderLoop
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
a MorphicRenderLoop

MorphicRenderLoop>>doOneCycleWhile:
	Receiver: a MorphicRenderLoop
	Arguments and temporary variables: 
		aBlock: 	[ true ]
	Receiver's instance variables: 
a MorphicRenderLoop

[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		activeTranscript: 	Transcript



--- The full stack ---
IceTipLocalRepositoryPanel(Object)>>assert:description:
IceTipLocalRepositoryPanel>>validate
IceTipRegisterRepositoryDialog>>doAccept
[ self doAccept ] in IceTipRegisterRepositoryDialog(IceTipOptionDialog)>>initializeDialogWindow:
FullBlockClosure(BlockClosure)>>cull:
SpDialogWindowPresenter>>triggerOkAction
[ :presenter | 
			presenter triggerOkAction.
			presenter close ] in SpAbstractPresenter>>initializeDialogWindow:
FullBlockClosure(BlockClosure)>>cull:
[ aBlock cull: self ] in SpDialogWindowPresenter>>addButton:do:
SpButtonPresenter>>performAction
SpMorphicButtonAdapter>>action
PluggableButtonMorph>>performAction:
[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in PluggableButtonMorph>>mouseUp:
Array(SequenceableCollection)>>do:
PluggableButtonMorph>>mouseUp:
PluggableButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableButtonMorph(Morph)>>handleEvent:
PluggableButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
AssertionFailure: Project location must exist!
26 September 2022 7:24:55.907583 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
StackToRegisterMappingCogit * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
v9.0.18 - Commit: 7249c170 - Date: 2022-09-02 14:31:12 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

IceTipLocalRepositoryPanel(Object)>>assert:description:
	Receiver: an IceTipLocalRepositoryPanel
	Arguments and temporary variables: 
		aBlock: 	false
		aStringOrBlock: 	'Project location must exist!'
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	an IceTipRegisterRepositoryDialog
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		projectLocation: 	an IceTipDirectoryPresenter
		remoteLabel: 	nil
		remoteInputText: 	nil
		repository: 	nil


IceTipLocalRepositoryPanel>>validate
	Receiver: an IceTipLocalRepositoryPanel
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	an IceTipRegisterRepositoryDialog
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		projectLocation: 	an IceTipDirectoryPresenter
		remoteLabel: 	nil
		remoteInputText: 	nil
		repository: 	nil


IceTipRegisterRepositoryDialog>>doAccept
	Receiver: an IceTipRegisterRepositoryDialog
	Arguments and temporary variables: 
		newRepository: 	nil
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		owner: 	a SpDialogWindowPresenter
		adapter: 	a SpMorphicPanedAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a SpNullApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpPanedLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		typeList: 	a SpTablePresenter
		type: 	an IceTipLocalRepositoryPanel
		contentPanel: 	an IceTipLocalRepositoryPanel
		types: 	an OrderedCollection(an IceTipNewRepositoryPanel an IceTipLocalRepositor...etc...
		repository: 	nil
		acceptBlock: 	nil


[ self doAccept ] in IceTipRegisterRepositoryDialog(IceTipOptionDialog)>>initializeDialogWindow:
	Receiver: an IceTipRegisterRepositoryDialog
	Arguments and temporary variables: 
		aWindowPresenter: 	a SpDialogWindowPresenter
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		owner: 	a SpDialogWindowPresenter
		adapter: 	a SpMorphicPanedAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a SpNullApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpPanedLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		typeList: 	a SpTablePresenter
		type: 	an IceTipLocalRepositoryPanel
		contentPanel: 	an IceTipLocalRepositoryPanel
		types: 	an OrderedCollection(an IceTipNewRepositoryPanel an IceTipLocalRepositor...etc...
		repository: 	nil
		acceptBlock: 	nil


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ self doAccept ]
	Arguments and temporary variables: 
		anArg: 	a SpDialogWindowPresenter
	Receiver's instance variables: 
		outerContext: 	IceTipRegisterRepositoryDialog(IceTipOptionDialog)>>initializeDia...etc...
		startpc: 	a CompiledBlock: [ self doAccept ]
		numArgs: 	0
		receiver: 	an IceTipRegisterRepositoryDialog


SpDialogWindowPresenter>>triggerOkAction
	Receiver: a SpDialogWindowPresenter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicDialogWindowAdapter a SpDialogWindow(3...etc...
		announcer: 	an Announcer
		owner: 	nil
		adapter: 	a SpMorphicDialogWindowAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a SpNullApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ Form(16x16x32) ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ true ]
		titleHolder: 	an ObservableValueHolder[ 'Import from existing clone' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ nil ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		presenter: 	an ObservableValueHolder[ an IceTipRegisterRepositoryDialog ]
		initialPosition: 	an ObservableValueHolder[ nil ]
		initialExtent: 	an ObservableValueHolder[ (600@300) ]
		isResizeable: 	an ObservableValueHolder[ true ]
		menu: 	an ObservableValueHolder[ nil ]
		centered: 	an ObservableValueHolder[ false ]
		isClosed: 	an ObservableValueHolder[ false ]
		toolbar: 	an ObservableValueHolder[ nil ]
		statusbar: 	an ObservableValueHolder[ nil ]
		window: 	an ObservableValueHolder[ a SpDialogWindow(308885760) named: Import fro...etc...
		decorations: 	an ObservableValueHolder[ true ]
		buttons: 	an OrderedCollection(a SpButtonPresenter a SpButtonPresenter)
		okAction: 	[ self doAccept ]
		cancelAction: 	[ 
		cancelled := true.
		self close ]
		cancelled: 	true
		defaultButton: 	nil


[ :presenter | 
			presenter triggerOkAction.
			presenter close ] in SpAbstractPresenter>>initializeDialogWindow:
	Receiver: an IceTipRegisterRepositoryDialog
	Arguments and temporary variables: 
		aDialogWindowPresenter: 	a SpDialogWindowPresenter
		presenter: 	a SpDialogWindowPresenter
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		owner: 	a SpDialogWindowPresenter
		adapter: 	a SpMorphicPanedAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a SpNullApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpPanedLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		typeList: 	a SpTablePresenter
		type: 	an IceTipLocalRepositoryPanel
		contentPanel: 	an IceTipLocalRepositoryPanel
		types: 	an OrderedCollection(an IceTipNewRepositoryPanel an IceTipLocalRepositor...etc...
		repository: 	nil
		acceptBlock: 	nil


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ :presenter | 
			presenter triggerOkAction.
			presenter close ]
	Arguments and temporary variables: 
		anArg: 	a SpDialogWindowPresenter
	Receiver's instance variables: 
		outerContext: 	IceTipRegisterRepositoryDialog(SpAbstractPresenter)>>initializeDi...etc...
		startpc: 	a CompiledBlock: [ :presenter | 
			presenter triggerOkAction.
			pres...etc...
		numArgs: 	1
		receiver: 	an IceTipRegisterRepositoryDialog


[ aBlock cull: self ] in SpDialogWindowPresenter>>addButton:do:
	Receiver: a SpDialogWindowPresenter
	Arguments and temporary variables: 
		aString: 	'Ok'
		aBlock: 	[ :presenter | 
			presenter triggerOkAction.
			presenter close ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicDialogWindowAdapter a SpDialogWindow(3...etc...
		announcer: 	an Announcer
		owner: 	nil
		adapter: 	a SpMorphicDialogWindowAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a SpNullApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ Form(16x16x32) ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ true ]
		titleHolder: 	an ObservableValueHolder[ 'Import from existing clone' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ nil ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		presenter: 	an ObservableValueHolder[ an IceTipRegisterRepositoryDialog ]
		initialPosition: 	an ObservableValueHolder[ nil ]
		initialExtent: 	an ObservableValueHolder[ (600@300) ]
		isResizeable: 	an ObservableValueHolder[ true ]
		menu: 	an ObservableValueHolder[ nil ]
		centered: 	an ObservableValueHolder[ false ]
		isClosed: 	an ObservableValueHolder[ false ]
		toolbar: 	an ObservableValueHolder[ nil ]
		statusbar: 	an ObservableValueHolder[ nil ]
		window: 	an ObservableValueHolder[ a SpDialogWindow(308885760) named: Import fro...etc...
		decorations: 	an ObservableValueHolder[ true ]
		buttons: 	an OrderedCollection(a SpButtonPresenter a SpButtonPresenter)
		okAction: 	[ self doAccept ]
		cancelAction: 	[ 
		cancelled := true.
		self close ]
		cancelled: 	true
		defaultButton: 	nil


SpButtonPresenter>>performAction
	Receiver: a SpButtonPresenter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicButtonAdapter)
		announcer: 	an Announcer
		owner: 	a SpButtonBarPresenter
		adapter: 	a SpMorphicButtonAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Button' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		icon: 	an ObservableValueHolder[ nil ]
		label: 	an ObservableValueHolder[ 'Ok' ]
		action: 	an ObservableValueHolder[ [ aBlock cull: self ] ]
		actionPerformed: 	an ObservableValueHolder[ nil ]
		askBeforeChanging: 	an ObservableValueHolder[ false ]
		font: 	an ObservableValueHolder[ nil ]
		shortcut: 	an ObservableValueHolder[ nil ]
		state: 	an ObservableValueHolder[ false ]
		contextMenu: 	an ObservableValueHolder[ nil ]


SpMorphicButtonAdapter>>action
	Receiver: a SpMorphicButtonAdapter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a PluggableButtonMorph(335468288))
		announcer: 	nil
		model: 	a SpButtonPresenter
		widget: 	a PluggableButtonMorph(335468288)
		selector: 	nil
		owner: 	a SpButtonPresenter
		subMenuWidget: 	nil
		styleName: 	nil


PluggableButtonMorph>>performAction:
	Receiver: a PluggableButtonMorph(335468288)
	Arguments and temporary variables: 
		event: 	[(816@448) mouseUp 149507 nil]
	Receiver's instance variables: 
		bounds: 	(769.0@436.0) corner: (869.0@466.0)
		owner: 	a PanelMorph(1071747072)
		submorphs: 	an Array(an AlignmentMorph(502232320))
		fullBounds: 	nil
		color: 	(Color r: 0.2903225806451613 g: 0.2883675464320626 b: 0.2883675464320626...etc...
		extension: 	a MorphExtension (169478144) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a SpMorphicButtonAdapter
		label: 	'Ok'
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	#state
		actionSelector: 	#action
		font: 	nil
		getLabelSelector: 	#label
		getMenuSelector: 	#menu:
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		getFontSelector: 	#font
		labelMorph: 	a LabelMorph(236987904)'Ok'
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	false


[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(335468288)
	Arguments and temporary variables: 
		evt: 	[(816@448) mouseUp 149507 nil]
		all: 	an Array(a PluggableButtonMorph(857193472) a PluggableButtonMorph(33546828...etc...
		m: 	a PluggableButtonMorph(335468288)
	Receiver's instance variables: 
		bounds: 	(769.0@436.0) corner: (869.0@466.0)
		owner: 	a PanelMorph(1071747072)
		submorphs: 	an Array(an AlignmentMorph(502232320))
		fullBounds: 	nil
		color: 	(Color r: 0.2903225806451613 g: 0.2883675464320626 b: 0.2883675464320626...etc...
		extension: 	a MorphExtension (169478144) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a SpMorphicButtonAdapter
		label: 	'Ok'
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	#state
		actionSelector: 	#action
		font: 	nil
		getLabelSelector: 	#label
		getMenuSelector: 	#menu:
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		getFontSelector: 	#font
		labelMorph: 	a LabelMorph(236987904)'Ok'
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	false


Array(SequenceableCollection)>>do:
	Receiver: an Array(a PluggableButtonMorph(857193472) a PluggableButtonMorph(335468288))
	Arguments and temporary variables: 
		aBlock: 	[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [...etc...
		index: 	2
	Receiver's instance variables: 
an Array(a PluggableButtonMorph(857193472) a PluggableButtonMorph(335468288))

PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(335468288)
	Arguments and temporary variables: 
		evt: 	[(816@448) mouseUp 149507 nil]
		all: 	an Array(a PluggableButtonMorph(857193472) a PluggableButtonMorph(33546828...etc...
	Receiver's instance variables: 
		bounds: 	(769.0@436.0) corner: (869.0@466.0)
		owner: 	a PanelMorph(1071747072)
		submorphs: 	an Array(an AlignmentMorph(502232320))
		fullBounds: 	nil
		color: 	(Color r: 0.2903225806451613 g: 0.2883675464320626 b: 0.2883675464320626...etc...
		extension: 	a MorphExtension (169478144) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a SpMorphicButtonAdapter
		label: 	'Ok'
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	#state
		actionSelector: 	#action
		font: 	nil
		getLabelSelector: 	#label
		getMenuSelector: 	#menu:
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		getFontSelector: 	#font
		labelMorph: 	a LabelMorph(236987904)'Ok'
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	false


PluggableButtonMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableButtonMorph(335468288)
	Arguments and temporary variables: 
		anEvent: 	[(816@448) mouseUp 149507 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(769.0@436.0) corner: (869.0@466.0)
		owner: 	a PanelMorph(1071747072)
		submorphs: 	an Array(an AlignmentMorph(502232320))
		fullBounds: 	nil
		color: 	(Color r: 0.2903225806451613 g: 0.2883675464320626 b: 0.2883675464320626...etc...
		extension: 	a MorphExtension (169478144) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a SpMorphicButtonAdapter
		label: 	'Ok'
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	#state
		actionSelector: 	#action
		font: 	nil
		getLabelSelector: 	#label
		getMenuSelector: 	#menu:
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		getFontSelector: 	#font
		labelMorph: 	a LabelMorph(236987904)'Ok'
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	false


MouseButtonEvent>>sentTo:
	Receiver: [(816@448) mouseUp 149507 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableButtonMorph(335468288)
	Receiver's instance variables: 
		timeStamp: 	149507
		source: 	a HandMorph(986102528)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(816@448)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableButtonMorph(Morph)>>handleEvent:
	Receiver: a PluggableButtonMorph(335468288)
	Arguments and temporary variables: 
		anEvent: 	[(816@448) mouseUp 149507 nil]
	Receiver's instance variables: 
		bounds: 	(769.0@436.0) corner: (869.0@466.0)
		owner: 	a PanelMorph(1071747072)
		submorphs: 	an Array(an AlignmentMorph(502232320))
		fullBounds: 	nil
		color: 	(Color r: 0.2903225806451613 g: 0.2883675464320626 b: 0.2883675464320626...etc...
		extension: 	a MorphExtension (169478144) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a SpMorphicButtonAdapter
		label: 	'Ok'
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	#state
		actionSelector: 	#action
		font: 	nil
		getLabelSelector: 	#label
		getMenuSelector: 	#menu:
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		getFontSelector: 	#font
		labelMorph: 	a LabelMorph(236987904)'Ok'
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	false


PluggableButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a PluggableButtonMorph(335468288)
	Arguments and temporary variables: 
		anEvent: 	[(816@448) mouseUp 149507 nil]
	Receiver's instance variables: 
		bounds: 	(769.0@436.0) corner: (869.0@466.0)
		owner: 	a PanelMorph(1071747072)
		submorphs: 	an Array(an AlignmentMorph(502232320))
		fullBounds: 	nil
		color: 	(Color r: 0.2903225806451613 g: 0.2883675464320626 b: 0.2883675464320626...etc...
		extension: 	a MorphExtension (169478144) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a SpMorphicButtonAdapter
		label: 	'Ok'
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	#state
		actionSelector: 	#action
		font: 	nil
		getLabelSelector: 	#label
		getMenuSelector: 	#menu:
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		getFontSelector: 	#font
		labelMorph: 	a LabelMorph(236987904)'Ok'
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	false


[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(986102528)
	Arguments and temporary variables: 
		anEvent: 	[(816@448) mouseUp 149507 nil]
		focusHolder: 	a PluggableButtonMorph(335468288)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(603310592) [world]
		transformedEvent: 	[(816@448) mouseUp 149507 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(816@448) corner: (832@464)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	#()
		fullBounds: 	(816@448) corner: (832@464)
		color: 	Color blue
		extension: 	a MorphExtension (1065441536)
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(335468288)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(816@448) mouseUp 149507 nil]
		targetOffset: 	(47.0@12.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		lastKeyScanCode: 	nil
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		result := focusHolder handleFocusEvent: transformedEvent.
	]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
			ActiveWorld := priorWorld.
			ex pass ]
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	a CompiledBlock: [
		result := focusHolder handleFocusEvent: transform...etc...
		numArgs: 	0
		receiver: 	a HandMorph(986102528)


WorldMorph>>becomeActiveDuring:
	Receiver: a WorldMorph(603310592) [world]
	Arguments and temporary variables: 
		aBlock: 	[
		result := focusHolder handleFocusEvent: transformedEvent.
	]
		priorWorld: 	a WorldMorph(603310592) [world]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1512@851)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(1021235712) a TaskbarMorph(882262784) a SpDi...etc...
		fullBounds: 	(0@0) corner: (1512@851)
		color: 	(Color r: 0.29521016617790813 g: 0.29521016617790813 b: 0.29521016617790...etc...
		extension: 	a MorphExtension (219690240) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(986102528)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(816@448) mouseUp 149507 nil]
		focusHolder: 	a PluggableButtonMorph(335468288)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(603310592) [world]
		transformedEvent: 	[(816@448) mouseUp 149507 nil]
	Receiver's instance variables: 
		bounds: 	(816@448) corner: (832@464)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	#()
		fullBounds: 	(816@448) corner: (832@464)
		color: 	Color blue
		extension: 	a MorphExtension (1065441536)
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(335468288)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(816@448) mouseUp 149507 nil]
		targetOffset: 	(47.0@12.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		lastKeyScanCode: 	nil
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(986102528)
	Arguments and temporary variables: 
		anEvent: 	[(816@448) mouseUp 149507 nil]
		focusHolder: 	a PluggableButtonMorph(335468288)
		aBlock: 	[self mouseFocus: nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(816@448) corner: (832@464)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	#()
		fullBounds: 	(816@448) corner: (832@464)
		color: 	Color blue
		extension: 	a MorphExtension (1065441536)
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(335468288)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(816@448) mouseUp 149507 nil]
		targetOffset: 	(47.0@12.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		lastKeyScanCode: 	nil
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(986102528)
	Arguments and temporary variables: 
		anEvent: 	[(816@448) mouseUp 149507 nil]
	Receiver's instance variables: 
		bounds: 	(816@448) corner: (832@464)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	#()
		fullBounds: 	(816@448) corner: (832@464)
		color: 	Color blue
		extension: 	a MorphExtension (1065441536)
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(335468288)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(816@448) mouseUp 149507 nil]
		targetOffset: 	(47.0@12.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		lastKeyScanCode: 	nil
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>handleEvent:
	Receiver: a HandMorph(986102528)
	Arguments and temporary variables: 
		anEvent: 	[(816@448) mouseUp 149507 nil]
		evt: 	[(816@448) mouseUp 149507 nil]
	Receiver's instance variables: 
		bounds: 	(816@448) corner: (832@464)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	#()
		fullBounds: 	(816@448) corner: (832@464)
		color: 	Color blue
		extension: 	a MorphExtension (1065441536)
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(335468288)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(816@448) mouseUp 149507 nil]
		targetOffset: 	(47.0@12.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		lastKeyScanCode: 	nil
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
	Receiver: an OSWindowMorphicEventHandler
	Arguments and temporary variables: 
		anEvent: 	[(816@448) mouseUp 149507 nil]
	Receiver's instance variables: 
		morphicWorld: 	a WorldMorph(603310592) [world]


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(603310592) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(986102528))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	21497
		lastStepMessage: 	nil
		alarms: 	a Heap()
		lastAlarmTime: 	149479
		activeHand: 	a HandMorph(986102528)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1512@851)


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(603310592) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1512@851)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(1021235712) a TaskbarMorph(882262784) a SpDi...etc...
		fullBounds: 	(0@0) corner: (1512@851)
		color: 	(Color r: 0.29521016617790813 g: 0.29521016617790813 b: 0.29521016617790...etc...
		extension: 	a MorphExtension (219690240) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(603310592) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(986102528))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	21497
		lastStepMessage: 	nil
		alarms: 	a Heap()
		lastAlarmTime: 	149479
		activeHand: 	a HandMorph(986102528)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1512@851)


WorldMorph>>doOneCycleNow
	Receiver: a WorldMorph(603310592) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1512@851)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(1021235712) a TaskbarMorph(882262784) a SpDi...etc...
		fullBounds: 	(0@0) corner: (1512@851)
		color: 	(Color r: 0.29521016617790813 g: 0.29521016617790813 b: 0.29521016617790...etc...
		extension: 	a MorphExtension (219690240) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(603310592) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1512@851)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(1021235712) a TaskbarMorph(882262784) a SpDi...etc...
		fullBounds: 	(0@0) corner: (1512@851)
		color: 	(Color r: 0.29521016617790813 g: 0.29521016617790813 b: 0.29521016617790...etc...
		extension: 	a MorphExtension (219690240) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 
		extraWorldsToDraw: 	#()
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65547
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->nil #CursorOwnerWorld->a WorldMorph(60...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		announcer: 	nil
		displayScaleFactor: 	1


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extr...etc...
	Arguments and temporary variables: 
		aBlock: 	[
		self doInterCycleWait
	]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	WorldMorph class>>doOneCycle
		startpc: 	a CompiledBlock: [
		| extraWorldsToDraw |
		extraWorldsToDraw := Extr...etc...
		numArgs: 	0
		receiver: 	WorldMorph


WorldState class>>doDrawCycleWith:
	Receiver: WorldState
	Arguments and temporary variables: 
		aBlock: 	[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex cr...etc...
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#activeHand->WorldState>>#activeHand #activeHand...etc...
		format: 	65547
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldState}
		name: 	#WorldState
		classPool: 	a Dictionary(#CanSurrenderToOS->nil #DebugShowDamage->false #Deferre...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'


WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65547
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->nil #CursorOwnerWorld->a WorldMorph(60...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		announcer: 	nil
		displayScaleFactor: 	1


MorphicRenderLoop>>doOneCycle
	Receiver: a MorphicRenderLoop
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
a MorphicRenderLoop

MorphicRenderLoop>>doOneCycleWhile:
	Receiver: a MorphicRenderLoop
	Arguments and temporary variables: 
		aBlock: 	[ true ]
	Receiver's instance variables: 
a MorphicRenderLoop

[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		activeTranscript: 	Transcript



--- The full stack ---
IceTipLocalRepositoryPanel(Object)>>assert:description:
IceTipLocalRepositoryPanel>>validate
IceTipRegisterRepositoryDialog>>doAccept
[ self doAccept ] in IceTipRegisterRepositoryDialog(IceTipOptionDialog)>>initializeDialogWindow:
FullBlockClosure(BlockClosure)>>cull:
SpDialogWindowPresenter>>triggerOkAction
[ :presenter | 
			presenter triggerOkAction.
			presenter close ] in SpAbstractPresenter>>initializeDialogWindow:
FullBlockClosure(BlockClosure)>>cull:
[ aBlock cull: self ] in SpDialogWindowPresenter>>addButton:do:
SpButtonPresenter>>performAction
SpMorphicButtonAdapter>>action
PluggableButtonMorph>>performAction:
[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in PluggableButtonMorph>>mouseUp:
Array(SequenceableCollection)>>do:
PluggableButtonMorph>>mouseUp:
PluggableButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableButtonMorph(Morph)>>handleEvent:
PluggableButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
AssertionFailure: Project location does not seems to be a valid git repository.
26 September 2022 7:25:35.245691 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
StackToRegisterMappingCogit * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
v9.0.18 - Commit: 7249c170 - Date: 2022-09-02 14:31:12 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

IceTipLocalRepositoryPanel(Object)>>assert:description:
	Receiver: an IceTipLocalRepositoryPanel
	Arguments and temporary variables: 
		aBlock: 	false
		aStringOrBlock: 	'Project location does not seems to be a valid git repository.'...etc...
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	an IceTipRegisterRepositoryDialog
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		projectLocation: 	an IceTipDirectoryPresenter
		remoteLabel: 	nil
		remoteInputText: 	nil
		repository: 	nil


IceTipLocalRepositoryPanel>>validate
	Receiver: an IceTipLocalRepositoryPanel
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	an IceTipRegisterRepositoryDialog
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		projectLocation: 	an IceTipDirectoryPresenter
		remoteLabel: 	nil
		remoteInputText: 	nil
		repository: 	nil


IceTipRegisterRepositoryDialog>>doAccept
	Receiver: an IceTipRegisterRepositoryDialog
	Arguments and temporary variables: 
		newRepository: 	nil
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		owner: 	a SpDialogWindowPresenter
		adapter: 	a SpMorphicPanedAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a SpNullApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpPanedLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		typeList: 	a SpTablePresenter
		type: 	an IceTipLocalRepositoryPanel
		contentPanel: 	an IceTipLocalRepositoryPanel
		types: 	an OrderedCollection(an IceTipNewRepositoryPanel an IceTipLocalRepositor...etc...
		repository: 	nil
		acceptBlock: 	nil


[ self doAccept ] in IceTipRegisterRepositoryDialog(IceTipOptionDialog)>>initializeDialogWindow:
	Receiver: an IceTipRegisterRepositoryDialog
	Arguments and temporary variables: 
		aWindowPresenter: 	a SpDialogWindowPresenter
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		owner: 	a SpDialogWindowPresenter
		adapter: 	a SpMorphicPanedAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a SpNullApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpPanedLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		typeList: 	a SpTablePresenter
		type: 	an IceTipLocalRepositoryPanel
		contentPanel: 	an IceTipLocalRepositoryPanel
		types: 	an OrderedCollection(an IceTipNewRepositoryPanel an IceTipLocalRepositor...etc...
		repository: 	nil
		acceptBlock: 	nil


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ self doAccept ]
	Arguments and temporary variables: 
		anArg: 	a SpDialogWindowPresenter
	Receiver's instance variables: 
		outerContext: 	IceTipRegisterRepositoryDialog(IceTipOptionDialog)>>initializeDia...etc...
		startpc: 	a CompiledBlock: [ self doAccept ]
		numArgs: 	0
		receiver: 	an IceTipRegisterRepositoryDialog


SpDialogWindowPresenter>>triggerOkAction
	Receiver: a SpDialogWindowPresenter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicDialogWindowAdapter a SpDialogWindow(3...etc...
		announcer: 	an Announcer
		owner: 	nil
		adapter: 	a SpMorphicDialogWindowAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a SpNullApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ Form(16x16x32) ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ true ]
		titleHolder: 	an ObservableValueHolder[ 'Import from existing clone' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ nil ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		presenter: 	an ObservableValueHolder[ an IceTipRegisterRepositoryDialog ]
		initialPosition: 	an ObservableValueHolder[ nil ]
		initialExtent: 	an ObservableValueHolder[ (600@300) ]
		isResizeable: 	an ObservableValueHolder[ true ]
		menu: 	an ObservableValueHolder[ nil ]
		centered: 	an ObservableValueHolder[ false ]
		isClosed: 	an ObservableValueHolder[ false ]
		toolbar: 	an ObservableValueHolder[ nil ]
		statusbar: 	an ObservableValueHolder[ nil ]
		window: 	an ObservableValueHolder[ a SpDialogWindow(308885760) named: Import fro...etc...
		decorations: 	an ObservableValueHolder[ true ]
		buttons: 	an OrderedCollection(a SpButtonPresenter a SpButtonPresenter)
		okAction: 	[ self doAccept ]
		cancelAction: 	[ 
		cancelled := true.
		self close ]
		cancelled: 	true
		defaultButton: 	nil


[ :presenter | 
			presenter triggerOkAction.
			presenter close ] in SpAbstractPresenter>>initializeDialogWindow:
	Receiver: an IceTipRegisterRepositoryDialog
	Arguments and temporary variables: 
		aDialogWindowPresenter: 	a SpDialogWindowPresenter
		presenter: 	a SpDialogWindowPresenter
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		owner: 	a SpDialogWindowPresenter
		adapter: 	a SpMorphicPanedAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a SpNullApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpPanedLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		typeList: 	a SpTablePresenter
		type: 	an IceTipLocalRepositoryPanel
		contentPanel: 	an IceTipLocalRepositoryPanel
		types: 	an OrderedCollection(an IceTipNewRepositoryPanel an IceTipLocalRepositor...etc...
		repository: 	nil
		acceptBlock: 	nil


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ :presenter | 
			presenter triggerOkAction.
			presenter close ]
	Arguments and temporary variables: 
		anArg: 	a SpDialogWindowPresenter
	Receiver's instance variables: 
		outerContext: 	IceTipRegisterRepositoryDialog(SpAbstractPresenter)>>initializeDi...etc...
		startpc: 	a CompiledBlock: [ :presenter | 
			presenter triggerOkAction.
			pres...etc...
		numArgs: 	1
		receiver: 	an IceTipRegisterRepositoryDialog


[ aBlock cull: self ] in SpDialogWindowPresenter>>addButton:do:
	Receiver: a SpDialogWindowPresenter
	Arguments and temporary variables: 
		aString: 	'Ok'
		aBlock: 	[ :presenter | 
			presenter triggerOkAction.
			presenter close ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicDialogWindowAdapter a SpDialogWindow(3...etc...
		announcer: 	an Announcer
		owner: 	nil
		adapter: 	a SpMorphicDialogWindowAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a SpNullApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ Form(16x16x32) ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ true ]
		titleHolder: 	an ObservableValueHolder[ 'Import from existing clone' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ nil ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		presenter: 	an ObservableValueHolder[ an IceTipRegisterRepositoryDialog ]
		initialPosition: 	an ObservableValueHolder[ nil ]
		initialExtent: 	an ObservableValueHolder[ (600@300) ]
		isResizeable: 	an ObservableValueHolder[ true ]
		menu: 	an ObservableValueHolder[ nil ]
		centered: 	an ObservableValueHolder[ false ]
		isClosed: 	an ObservableValueHolder[ false ]
		toolbar: 	an ObservableValueHolder[ nil ]
		statusbar: 	an ObservableValueHolder[ nil ]
		window: 	an ObservableValueHolder[ a SpDialogWindow(308885760) named: Import fro...etc...
		decorations: 	an ObservableValueHolder[ true ]
		buttons: 	an OrderedCollection(a SpButtonPresenter a SpButtonPresenter)
		okAction: 	[ self doAccept ]
		cancelAction: 	[ 
		cancelled := true.
		self close ]
		cancelled: 	true
		defaultButton: 	nil


SpButtonPresenter>>performAction
	Receiver: a SpButtonPresenter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicButtonAdapter)
		announcer: 	an Announcer
		owner: 	a SpButtonBarPresenter
		adapter: 	a SpMorphicButtonAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Button' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		icon: 	an ObservableValueHolder[ nil ]
		label: 	an ObservableValueHolder[ 'Ok' ]
		action: 	an ObservableValueHolder[ [ aBlock cull: self ] ]
		actionPerformed: 	an ObservableValueHolder[ nil ]
		askBeforeChanging: 	an ObservableValueHolder[ false ]
		font: 	an ObservableValueHolder[ nil ]
		shortcut: 	an ObservableValueHolder[ nil ]
		state: 	an ObservableValueHolder[ false ]
		contextMenu: 	an ObservableValueHolder[ nil ]


SpMorphicButtonAdapter>>action
	Receiver: a SpMorphicButtonAdapter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a PluggableButtonMorph(335468288))
		announcer: 	nil
		model: 	a SpButtonPresenter
		widget: 	a PluggableButtonMorph(335468288)
		selector: 	nil
		owner: 	a SpButtonPresenter
		subMenuWidget: 	nil
		styleName: 	nil


PluggableButtonMorph>>performAction:
	Receiver: a PluggableButtonMorph(335468288)
	Arguments and temporary variables: 
		event: 	[(843@453) mouseUp 188910 nil]
	Receiver's instance variables: 
		bounds: 	(769.0@436.0) corner: (869.0@466.0)
		owner: 	a PanelMorph(1071747072)
		submorphs: 	an Array(an AlignmentMorph(502232320))
		fullBounds: 	nil
		color: 	(Color r: 0.2903225806451613 g: 0.2883675464320626 b: 0.2883675464320626...etc...
		extension: 	a MorphExtension (169478144) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a SpMorphicButtonAdapter
		label: 	'Ok'
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	#state
		actionSelector: 	#action
		font: 	nil
		getLabelSelector: 	#label
		getMenuSelector: 	#menu:
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		getFontSelector: 	#font
		labelMorph: 	a LabelMorph(236987904)'Ok'
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	false


[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(335468288)
	Arguments and temporary variables: 
		evt: 	[(843@453) mouseUp 188910 nil]
		all: 	an Array(a PluggableButtonMorph(857193472) a PluggableButtonMorph(33546828...etc...
		m: 	a PluggableButtonMorph(335468288)
	Receiver's instance variables: 
		bounds: 	(769.0@436.0) corner: (869.0@466.0)
		owner: 	a PanelMorph(1071747072)
		submorphs: 	an Array(an AlignmentMorph(502232320))
		fullBounds: 	nil
		color: 	(Color r: 0.2903225806451613 g: 0.2883675464320626 b: 0.2883675464320626...etc...
		extension: 	a MorphExtension (169478144) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a SpMorphicButtonAdapter
		label: 	'Ok'
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	#state
		actionSelector: 	#action
		font: 	nil
		getLabelSelector: 	#label
		getMenuSelector: 	#menu:
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		getFontSelector: 	#font
		labelMorph: 	a LabelMorph(236987904)'Ok'
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	false


Array(SequenceableCollection)>>do:
	Receiver: an Array(a PluggableButtonMorph(857193472) a PluggableButtonMorph(335468288))
	Arguments and temporary variables: 
		aBlock: 	[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [...etc...
		index: 	2
	Receiver's instance variables: 
an Array(a PluggableButtonMorph(857193472) a PluggableButtonMorph(335468288))

PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(335468288)
	Arguments and temporary variables: 
		evt: 	[(843@453) mouseUp 188910 nil]
		all: 	an Array(a PluggableButtonMorph(857193472) a PluggableButtonMorph(33546828...etc...
	Receiver's instance variables: 
		bounds: 	(769.0@436.0) corner: (869.0@466.0)
		owner: 	a PanelMorph(1071747072)
		submorphs: 	an Array(an AlignmentMorph(502232320))
		fullBounds: 	nil
		color: 	(Color r: 0.2903225806451613 g: 0.2883675464320626 b: 0.2883675464320626...etc...
		extension: 	a MorphExtension (169478144) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a SpMorphicButtonAdapter
		label: 	'Ok'
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	#state
		actionSelector: 	#action
		font: 	nil
		getLabelSelector: 	#label
		getMenuSelector: 	#menu:
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		getFontSelector: 	#font
		labelMorph: 	a LabelMorph(236987904)'Ok'
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	false


PluggableButtonMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableButtonMorph(335468288)
	Arguments and temporary variables: 
		anEvent: 	[(843@453) mouseUp 188910 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(769.0@436.0) corner: (869.0@466.0)
		owner: 	a PanelMorph(1071747072)
		submorphs: 	an Array(an AlignmentMorph(502232320))
		fullBounds: 	nil
		color: 	(Color r: 0.2903225806451613 g: 0.2883675464320626 b: 0.2883675464320626...etc...
		extension: 	a MorphExtension (169478144) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a SpMorphicButtonAdapter
		label: 	'Ok'
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	#state
		actionSelector: 	#action
		font: 	nil
		getLabelSelector: 	#label
		getMenuSelector: 	#menu:
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		getFontSelector: 	#font
		labelMorph: 	a LabelMorph(236987904)'Ok'
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	false


MouseButtonEvent>>sentTo:
	Receiver: [(843@453) mouseUp 188910 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableButtonMorph(335468288)
	Receiver's instance variables: 
		timeStamp: 	188910
		source: 	a HandMorph(986102528)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(843@453)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableButtonMorph(Morph)>>handleEvent:
	Receiver: a PluggableButtonMorph(335468288)
	Arguments and temporary variables: 
		anEvent: 	[(843@453) mouseUp 188910 nil]
	Receiver's instance variables: 
		bounds: 	(769.0@436.0) corner: (869.0@466.0)
		owner: 	a PanelMorph(1071747072)
		submorphs: 	an Array(an AlignmentMorph(502232320))
		fullBounds: 	nil
		color: 	(Color r: 0.2903225806451613 g: 0.2883675464320626 b: 0.2883675464320626...etc...
		extension: 	a MorphExtension (169478144) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a SpMorphicButtonAdapter
		label: 	'Ok'
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	#state
		actionSelector: 	#action
		font: 	nil
		getLabelSelector: 	#label
		getMenuSelector: 	#menu:
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		getFontSelector: 	#font
		labelMorph: 	a LabelMorph(236987904)'Ok'
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	false


PluggableButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a PluggableButtonMorph(335468288)
	Arguments and temporary variables: 
		anEvent: 	[(843@453) mouseUp 188910 nil]
	Receiver's instance variables: 
		bounds: 	(769.0@436.0) corner: (869.0@466.0)
		owner: 	a PanelMorph(1071747072)
		submorphs: 	an Array(an AlignmentMorph(502232320))
		fullBounds: 	nil
		color: 	(Color r: 0.2903225806451613 g: 0.2883675464320626 b: 0.2883675464320626...etc...
		extension: 	a MorphExtension (169478144) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a SpMorphicButtonAdapter
		label: 	'Ok'
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	#state
		actionSelector: 	#action
		font: 	nil
		getLabelSelector: 	#label
		getMenuSelector: 	#menu:
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		getFontSelector: 	#font
		labelMorph: 	a LabelMorph(236987904)'Ok'
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	false


[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(986102528)
	Arguments and temporary variables: 
		anEvent: 	[(843@453) mouseUp 188910 nil]
		focusHolder: 	a PluggableButtonMorph(335468288)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(603310592) [world]
		transformedEvent: 	[(843@453) mouseUp 188910 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(843@453) corner: (859@469)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	#()
		fullBounds: 	(843@453) corner: (859@469)
		color: 	Color blue
		extension: 	a MorphExtension (1065441536)
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(335468288)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(843@453) mouseUp 188910 nil]
		targetOffset: 	(74.0@17.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		lastKeyScanCode: 	nil
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		result := focusHolder handleFocusEvent: transformedEvent.
	]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
			ActiveWorld := priorWorld.
			ex pass ]
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	a CompiledBlock: [
		result := focusHolder handleFocusEvent: transform...etc...
		numArgs: 	0
		receiver: 	a HandMorph(986102528)


WorldMorph>>becomeActiveDuring:
	Receiver: a WorldMorph(603310592) [world]
	Arguments and temporary variables: 
		aBlock: 	[
		result := focusHolder handleFocusEvent: transformedEvent.
	]
		priorWorld: 	a WorldMorph(603310592) [world]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1512@851)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(1021235712) a TaskbarMorph(882262784) a SpDi...etc...
		fullBounds: 	(0@0) corner: (1512@851)
		color: 	(Color r: 0.29521016617790813 g: 0.29521016617790813 b: 0.29521016617790...etc...
		extension: 	a MorphExtension (219690240) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(986102528)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(843@453) mouseUp 188910 nil]
		focusHolder: 	a PluggableButtonMorph(335468288)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(603310592) [world]
		transformedEvent: 	[(843@453) mouseUp 188910 nil]
	Receiver's instance variables: 
		bounds: 	(843@453) corner: (859@469)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	#()
		fullBounds: 	(843@453) corner: (859@469)
		color: 	Color blue
		extension: 	a MorphExtension (1065441536)
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(335468288)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(843@453) mouseUp 188910 nil]
		targetOffset: 	(74.0@17.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		lastKeyScanCode: 	nil
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(986102528)
	Arguments and temporary variables: 
		anEvent: 	[(843@453) mouseUp 188910 nil]
		focusHolder: 	a PluggableButtonMorph(335468288)
		aBlock: 	[self mouseFocus: nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(843@453) corner: (859@469)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	#()
		fullBounds: 	(843@453) corner: (859@469)
		color: 	Color blue
		extension: 	a MorphExtension (1065441536)
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(335468288)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(843@453) mouseUp 188910 nil]
		targetOffset: 	(74.0@17.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		lastKeyScanCode: 	nil
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(986102528)
	Arguments and temporary variables: 
		anEvent: 	[(843@453) mouseUp 188910 nil]
	Receiver's instance variables: 
		bounds: 	(843@453) corner: (859@469)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	#()
		fullBounds: 	(843@453) corner: (859@469)
		color: 	Color blue
		extension: 	a MorphExtension (1065441536)
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(335468288)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(843@453) mouseUp 188910 nil]
		targetOffset: 	(74.0@17.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		lastKeyScanCode: 	nil
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>handleEvent:
	Receiver: a HandMorph(986102528)
	Arguments and temporary variables: 
		anEvent: 	[(843@453) mouseUp 188910 nil]
		evt: 	[(843@453) mouseUp 188910 nil]
	Receiver's instance variables: 
		bounds: 	(843@453) corner: (859@469)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	#()
		fullBounds: 	(843@453) corner: (859@469)
		color: 	Color blue
		extension: 	a MorphExtension (1065441536)
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(335468288)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(843@453) mouseUp 188910 nil]
		targetOffset: 	(74.0@17.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		lastKeyScanCode: 	nil
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
	Receiver: an OSWindowMorphicEventHandler
	Arguments and temporary variables: 
		anEvent: 	[(843@453) mouseUp 188910 nil]
	Receiver's instance variables: 
		morphicWorld: 	a WorldMorph(603310592) [world]


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(603310592) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(986102528))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	184678
		lastStepMessage: 	nil
		alarms: 	a Heap()
		lastAlarmTime: 	188889
		activeHand: 	a HandMorph(986102528)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1512@851)


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(603310592) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1512@851)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(1021235712) a TaskbarMorph(882262784) a SpDi...etc...
		fullBounds: 	(0@0) corner: (1512@851)
		color: 	(Color r: 0.29521016617790813 g: 0.29521016617790813 b: 0.29521016617790...etc...
		extension: 	a MorphExtension (219690240) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(603310592) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(986102528))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	184678
		lastStepMessage: 	nil
		alarms: 	a Heap()
		lastAlarmTime: 	188889
		activeHand: 	a HandMorph(986102528)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1512@851)


WorldMorph>>doOneCycleNow
	Receiver: a WorldMorph(603310592) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1512@851)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(1021235712) a TaskbarMorph(882262784) a SpDi...etc...
		fullBounds: 	(0@0) corner: (1512@851)
		color: 	(Color r: 0.29521016617790813 g: 0.29521016617790813 b: 0.29521016617790...etc...
		extension: 	a MorphExtension (219690240) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(603310592) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1512@851)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(1021235712) a TaskbarMorph(882262784) a SpDi...etc...
		fullBounds: 	(0@0) corner: (1512@851)
		color: 	(Color r: 0.29521016617790813 g: 0.29521016617790813 b: 0.29521016617790...etc...
		extension: 	a MorphExtension (219690240) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 
		extraWorldsToDraw: 	#()
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65547
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->nil #CursorOwnerWorld->a WorldMorph(60...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		announcer: 	nil
		displayScaleFactor: 	1


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extr...etc...
	Arguments and temporary variables: 
		aBlock: 	[
		self doInterCycleWait
	]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	WorldMorph class>>doOneCycle
		startpc: 	a CompiledBlock: [
		| extraWorldsToDraw |
		extraWorldsToDraw := Extr...etc...
		numArgs: 	0
		receiver: 	WorldMorph


WorldState class>>doDrawCycleWith:
	Receiver: WorldState
	Arguments and temporary variables: 
		aBlock: 	[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex cr...etc...
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#activeHand->WorldState>>#activeHand #activeHand...etc...
		format: 	65547
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldState}
		name: 	#WorldState
		classPool: 	a Dictionary(#CanSurrenderToOS->nil #DebugShowDamage->false #Deferre...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'


WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65547
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->nil #CursorOwnerWorld->a WorldMorph(60...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		announcer: 	nil
		displayScaleFactor: 	1


MorphicRenderLoop>>doOneCycle
	Receiver: a MorphicRenderLoop
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
a MorphicRenderLoop

MorphicRenderLoop>>doOneCycleWhile:
	Receiver: a MorphicRenderLoop
	Arguments and temporary variables: 
		aBlock: 	[ true ]
	Receiver's instance variables: 
a MorphicRenderLoop

[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		activeTranscript: 	nil



--- The full stack ---
IceTipLocalRepositoryPanel(Object)>>assert:description:
IceTipLocalRepositoryPanel>>validate
IceTipRegisterRepositoryDialog>>doAccept
[ self doAccept ] in IceTipRegisterRepositoryDialog(IceTipOptionDialog)>>initializeDialogWindow:
FullBlockClosure(BlockClosure)>>cull:
SpDialogWindowPresenter>>triggerOkAction
[ :presenter | 
			presenter triggerOkAction.
			presenter close ] in SpAbstractPresenter>>initializeDialogWindow:
FullBlockClosure(BlockClosure)>>cull:
[ aBlock cull: self ] in SpDialogWindowPresenter>>addButton:do:
SpButtonPresenter>>performAction
SpMorphicButtonAdapter>>action
PluggableButtonMorph>>performAction:
[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in PluggableButtonMorph>>mouseUp:
Array(SequenceableCollection)>>do:
PluggableButtonMorph>>mouseUp:
PluggableButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableButtonMorph(Morph)>>handleEvent:
PluggableButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
AssertionFailure: Project location does not seems to be a valid git repository.
26 September 2022 7:25:35.311349 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
StackToRegisterMappingCogit * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
v9.0.18 - Commit: 7249c170 - Date: 2022-09-02 14:31:12 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

IceTipLocalRepositoryPanel(Object)>>assert:description:
	Receiver: an IceTipLocalRepositoryPanel
	Arguments and temporary variables: 
		aBlock: 	false
		aStringOrBlock: 	'Project location does not seems to be a valid git repository.'...etc...
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	an IceTipRegisterRepositoryDialog
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		projectLocation: 	an IceTipDirectoryPresenter
		remoteLabel: 	nil
		remoteInputText: 	nil
		repository: 	nil


IceTipLocalRepositoryPanel>>validate
	Receiver: an IceTipLocalRepositoryPanel
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	an IceTipRegisterRepositoryDialog
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		projectLocation: 	an IceTipDirectoryPresenter
		remoteLabel: 	nil
		remoteInputText: 	nil
		repository: 	nil


IceTipRegisterRepositoryDialog>>doAccept
	Receiver: an IceTipRegisterRepositoryDialog
	Arguments and temporary variables: 
		newRepository: 	nil
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		owner: 	a SpDialogWindowPresenter
		adapter: 	a SpMorphicPanedAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a SpNullApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpPanedLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		typeList: 	a SpTablePresenter
		type: 	an IceTipLocalRepositoryPanel
		contentPanel: 	an IceTipLocalRepositoryPanel
		types: 	an OrderedCollection(an IceTipNewRepositoryPanel an IceTipLocalRepositor...etc...
		repository: 	nil
		acceptBlock: 	nil


[ self doAccept ] in IceTipRegisterRepositoryDialog(IceTipOptionDialog)>>initializeDialogWindow:
	Receiver: an IceTipRegisterRepositoryDialog
	Arguments and temporary variables: 
		aWindowPresenter: 	a SpDialogWindowPresenter
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		owner: 	a SpDialogWindowPresenter
		adapter: 	a SpMorphicPanedAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a SpNullApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpPanedLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		typeList: 	a SpTablePresenter
		type: 	an IceTipLocalRepositoryPanel
		contentPanel: 	an IceTipLocalRepositoryPanel
		types: 	an OrderedCollection(an IceTipNewRepositoryPanel an IceTipLocalRepositor...etc...
		repository: 	nil
		acceptBlock: 	nil


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ self doAccept ]
	Arguments and temporary variables: 
		anArg: 	a SpDialogWindowPresenter
	Receiver's instance variables: 
		outerContext: 	IceTipRegisterRepositoryDialog(IceTipOptionDialog)>>initializeDia...etc...
		startpc: 	a CompiledBlock: [ self doAccept ]
		numArgs: 	0
		receiver: 	an IceTipRegisterRepositoryDialog


SpDialogWindowPresenter>>triggerOkAction
	Receiver: a SpDialogWindowPresenter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicDialogWindowAdapter a SpDialogWindow(3...etc...
		announcer: 	an Announcer
		owner: 	nil
		adapter: 	a SpMorphicDialogWindowAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a SpNullApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ Form(16x16x32) ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ true ]
		titleHolder: 	an ObservableValueHolder[ 'Import from existing clone' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ nil ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		presenter: 	an ObservableValueHolder[ an IceTipRegisterRepositoryDialog ]
		initialPosition: 	an ObservableValueHolder[ nil ]
		initialExtent: 	an ObservableValueHolder[ (600@300) ]
		isResizeable: 	an ObservableValueHolder[ true ]
		menu: 	an ObservableValueHolder[ nil ]
		centered: 	an ObservableValueHolder[ false ]
		isClosed: 	an ObservableValueHolder[ false ]
		toolbar: 	an ObservableValueHolder[ nil ]
		statusbar: 	an ObservableValueHolder[ nil ]
		window: 	an ObservableValueHolder[ a SpDialogWindow(308885760) named: Import fro...etc...
		decorations: 	an ObservableValueHolder[ true ]
		buttons: 	an OrderedCollection(a SpButtonPresenter a SpButtonPresenter)
		okAction: 	[ self doAccept ]
		cancelAction: 	[ 
		cancelled := true.
		self close ]
		cancelled: 	true
		defaultButton: 	nil


[ :presenter | 
			presenter triggerOkAction.
			presenter close ] in SpAbstractPresenter>>initializeDialogWindow:
	Receiver: an IceTipRegisterRepositoryDialog
	Arguments and temporary variables: 
		aDialogWindowPresenter: 	a SpDialogWindowPresenter
		presenter: 	a SpDialogWindowPresenter
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		owner: 	a SpDialogWindowPresenter
		adapter: 	a SpMorphicPanedAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a SpNullApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpPanedLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		typeList: 	a SpTablePresenter
		type: 	an IceTipLocalRepositoryPanel
		contentPanel: 	an IceTipLocalRepositoryPanel
		types: 	an OrderedCollection(an IceTipNewRepositoryPanel an IceTipLocalRepositor...etc...
		repository: 	nil
		acceptBlock: 	nil


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ :presenter | 
			presenter triggerOkAction.
			presenter close ]
	Arguments and temporary variables: 
		anArg: 	a SpDialogWindowPresenter
	Receiver's instance variables: 
		outerContext: 	IceTipRegisterRepositoryDialog(SpAbstractPresenter)>>initializeDi...etc...
		startpc: 	a CompiledBlock: [ :presenter | 
			presenter triggerOkAction.
			pres...etc...
		numArgs: 	1
		receiver: 	an IceTipRegisterRepositoryDialog


[ aBlock cull: self ] in SpDialogWindowPresenter>>addButton:do:
	Receiver: a SpDialogWindowPresenter
	Arguments and temporary variables: 
		aString: 	'Ok'
		aBlock: 	[ :presenter | 
			presenter triggerOkAction.
			presenter close ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicDialogWindowAdapter a SpDialogWindow(3...etc...
		announcer: 	an Announcer
		owner: 	nil
		adapter: 	a SpMorphicDialogWindowAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a SpNullApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ Form(16x16x32) ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ true ]
		titleHolder: 	an ObservableValueHolder[ 'Import from existing clone' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ nil ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		presenter: 	an ObservableValueHolder[ an IceTipRegisterRepositoryDialog ]
		initialPosition: 	an ObservableValueHolder[ nil ]
		initialExtent: 	an ObservableValueHolder[ (600@300) ]
		isResizeable: 	an ObservableValueHolder[ true ]
		menu: 	an ObservableValueHolder[ nil ]
		centered: 	an ObservableValueHolder[ false ]
		isClosed: 	an ObservableValueHolder[ false ]
		toolbar: 	an ObservableValueHolder[ nil ]
		statusbar: 	an ObservableValueHolder[ nil ]
		window: 	an ObservableValueHolder[ a SpDialogWindow(308885760) named: Import fro...etc...
		decorations: 	an ObservableValueHolder[ true ]
		buttons: 	an OrderedCollection(a SpButtonPresenter a SpButtonPresenter)
		okAction: 	[ self doAccept ]
		cancelAction: 	[ 
		cancelled := true.
		self close ]
		cancelled: 	true
		defaultButton: 	nil


SpButtonPresenter>>performAction
	Receiver: a SpButtonPresenter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicButtonAdapter)
		announcer: 	an Announcer
		owner: 	a SpButtonBarPresenter
		adapter: 	a SpMorphicButtonAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Button' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		icon: 	an ObservableValueHolder[ nil ]
		label: 	an ObservableValueHolder[ 'Ok' ]
		action: 	an ObservableValueHolder[ [ aBlock cull: self ] ]
		actionPerformed: 	an ObservableValueHolder[ nil ]
		askBeforeChanging: 	an ObservableValueHolder[ false ]
		font: 	an ObservableValueHolder[ nil ]
		shortcut: 	an ObservableValueHolder[ nil ]
		state: 	an ObservableValueHolder[ false ]
		contextMenu: 	an ObservableValueHolder[ nil ]


SpMorphicButtonAdapter>>action
	Receiver: a SpMorphicButtonAdapter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a PluggableButtonMorph(335468288))
		announcer: 	nil
		model: 	a SpButtonPresenter
		widget: 	a PluggableButtonMorph(335468288)
		selector: 	nil
		owner: 	a SpButtonPresenter
		subMenuWidget: 	nil
		styleName: 	nil


PluggableButtonMorph>>performAction:
	Receiver: a PluggableButtonMorph(335468288)
	Arguments and temporary variables: 
		event: 	[(843@453) mouseUp 188910 nil]
	Receiver's instance variables: 
		bounds: 	(769.0@436.0) corner: (869.0@466.0)
		owner: 	a PanelMorph(1071747072)
		submorphs: 	an Array(an AlignmentMorph(502232320))
		fullBounds: 	nil
		color: 	(Color r: 0.2903225806451613 g: 0.2883675464320626 b: 0.2883675464320626...etc...
		extension: 	a MorphExtension (169478144) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a SpMorphicButtonAdapter
		label: 	'Ok'
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	#state
		actionSelector: 	#action
		font: 	nil
		getLabelSelector: 	#label
		getMenuSelector: 	#menu:
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		getFontSelector: 	#font
		labelMorph: 	a LabelMorph(236987904)'Ok'
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	false


[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(335468288)
	Arguments and temporary variables: 
		evt: 	[(843@453) mouseUp 188910 nil]
		all: 	an Array(a PluggableButtonMorph(857193472) a PluggableButtonMorph(33546828...etc...
		m: 	a PluggableButtonMorph(335468288)
	Receiver's instance variables: 
		bounds: 	(769.0@436.0) corner: (869.0@466.0)
		owner: 	a PanelMorph(1071747072)
		submorphs: 	an Array(an AlignmentMorph(502232320))
		fullBounds: 	nil
		color: 	(Color r: 0.2903225806451613 g: 0.2883675464320626 b: 0.2883675464320626...etc...
		extension: 	a MorphExtension (169478144) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a SpMorphicButtonAdapter
		label: 	'Ok'
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	#state
		actionSelector: 	#action
		font: 	nil
		getLabelSelector: 	#label
		getMenuSelector: 	#menu:
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		getFontSelector: 	#font
		labelMorph: 	a LabelMorph(236987904)'Ok'
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	false


Array(SequenceableCollection)>>do:
	Receiver: an Array(a PluggableButtonMorph(857193472) a PluggableButtonMorph(335468288))
	Arguments and temporary variables: 
		aBlock: 	[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [...etc...
		index: 	2
	Receiver's instance variables: 
an Array(a PluggableButtonMorph(857193472) a PluggableButtonMorph(335468288))

PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(335468288)
	Arguments and temporary variables: 
		evt: 	[(843@453) mouseUp 188910 nil]
		all: 	an Array(a PluggableButtonMorph(857193472) a PluggableButtonMorph(33546828...etc...
	Receiver's instance variables: 
		bounds: 	(769.0@436.0) corner: (869.0@466.0)
		owner: 	a PanelMorph(1071747072)
		submorphs: 	an Array(an AlignmentMorph(502232320))
		fullBounds: 	nil
		color: 	(Color r: 0.2903225806451613 g: 0.2883675464320626 b: 0.2883675464320626...etc...
		extension: 	a MorphExtension (169478144) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a SpMorphicButtonAdapter
		label: 	'Ok'
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	#state
		actionSelector: 	#action
		font: 	nil
		getLabelSelector: 	#label
		getMenuSelector: 	#menu:
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		getFontSelector: 	#font
		labelMorph: 	a LabelMorph(236987904)'Ok'
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	false


PluggableButtonMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableButtonMorph(335468288)
	Arguments and temporary variables: 
		anEvent: 	[(843@453) mouseUp 188910 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(769.0@436.0) corner: (869.0@466.0)
		owner: 	a PanelMorph(1071747072)
		submorphs: 	an Array(an AlignmentMorph(502232320))
		fullBounds: 	nil
		color: 	(Color r: 0.2903225806451613 g: 0.2883675464320626 b: 0.2883675464320626...etc...
		extension: 	a MorphExtension (169478144) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a SpMorphicButtonAdapter
		label: 	'Ok'
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	#state
		actionSelector: 	#action
		font: 	nil
		getLabelSelector: 	#label
		getMenuSelector: 	#menu:
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		getFontSelector: 	#font
		labelMorph: 	a LabelMorph(236987904)'Ok'
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	false


MouseButtonEvent>>sentTo:
	Receiver: [(843@453) mouseUp 188910 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableButtonMorph(335468288)
	Receiver's instance variables: 
		timeStamp: 	188910
		source: 	a HandMorph(986102528)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(843@453)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableButtonMorph(Morph)>>handleEvent:
	Receiver: a PluggableButtonMorph(335468288)
	Arguments and temporary variables: 
		anEvent: 	[(843@453) mouseUp 188910 nil]
	Receiver's instance variables: 
		bounds: 	(769.0@436.0) corner: (869.0@466.0)
		owner: 	a PanelMorph(1071747072)
		submorphs: 	an Array(an AlignmentMorph(502232320))
		fullBounds: 	nil
		color: 	(Color r: 0.2903225806451613 g: 0.2883675464320626 b: 0.2883675464320626...etc...
		extension: 	a MorphExtension (169478144) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a SpMorphicButtonAdapter
		label: 	'Ok'
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	#state
		actionSelector: 	#action
		font: 	nil
		getLabelSelector: 	#label
		getMenuSelector: 	#menu:
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		getFontSelector: 	#font
		labelMorph: 	a LabelMorph(236987904)'Ok'
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	false


PluggableButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a PluggableButtonMorph(335468288)
	Arguments and temporary variables: 
		anEvent: 	[(843@453) mouseUp 188910 nil]
	Receiver's instance variables: 
		bounds: 	(769.0@436.0) corner: (869.0@466.0)
		owner: 	a PanelMorph(1071747072)
		submorphs: 	an Array(an AlignmentMorph(502232320))
		fullBounds: 	nil
		color: 	(Color r: 0.2903225806451613 g: 0.2883675464320626 b: 0.2883675464320626...etc...
		extension: 	a MorphExtension (169478144) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a SpMorphicButtonAdapter
		label: 	'Ok'
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	#state
		actionSelector: 	#action
		font: 	nil
		getLabelSelector: 	#label
		getMenuSelector: 	#menu:
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		getFontSelector: 	#font
		labelMorph: 	a LabelMorph(236987904)'Ok'
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	false


[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(986102528)
	Arguments and temporary variables: 
		anEvent: 	[(843@453) mouseUp 188910 nil]
		focusHolder: 	a PluggableButtonMorph(335468288)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(603310592) [world]
		transformedEvent: 	[(843@453) mouseUp 188910 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(843@453) corner: (859@469)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	#()
		fullBounds: 	(843@453) corner: (859@469)
		color: 	Color blue
		extension: 	a MorphExtension (1065441536)
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(335468288)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(843@453) mouseUp 188910 nil]
		targetOffset: 	(74.0@17.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		lastKeyScanCode: 	nil
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		result := focusHolder handleFocusEvent: transformedEvent.
	]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
			ActiveWorld := priorWorld.
			ex pass ]
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	a CompiledBlock: [
		result := focusHolder handleFocusEvent: transform...etc...
		numArgs: 	0
		receiver: 	a HandMorph(986102528)


WorldMorph>>becomeActiveDuring:
	Receiver: a WorldMorph(603310592) [world]
	Arguments and temporary variables: 
		aBlock: 	[
		result := focusHolder handleFocusEvent: transformedEvent.
	]
		priorWorld: 	a WorldMorph(603310592) [world]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1512@851)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(1021235712) a TaskbarMorph(882262784) a SpDi...etc...
		fullBounds: 	(0@0) corner: (1512@851)
		color: 	(Color r: 0.29521016617790813 g: 0.29521016617790813 b: 0.29521016617790...etc...
		extension: 	a MorphExtension (219690240) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(986102528)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(843@453) mouseUp 188910 nil]
		focusHolder: 	a PluggableButtonMorph(335468288)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(603310592) [world]
		transformedEvent: 	[(843@453) mouseUp 188910 nil]
	Receiver's instance variables: 
		bounds: 	(843@453) corner: (859@469)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	#()
		fullBounds: 	(843@453) corner: (859@469)
		color: 	Color blue
		extension: 	a MorphExtension (1065441536)
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(335468288)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(843@453) mouseUp 188910 nil]
		targetOffset: 	(74.0@17.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		lastKeyScanCode: 	nil
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(986102528)
	Arguments and temporary variables: 
		anEvent: 	[(843@453) mouseUp 188910 nil]
		focusHolder: 	a PluggableButtonMorph(335468288)
		aBlock: 	[self mouseFocus: nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(843@453) corner: (859@469)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	#()
		fullBounds: 	(843@453) corner: (859@469)
		color: 	Color blue
		extension: 	a MorphExtension (1065441536)
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(335468288)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(843@453) mouseUp 188910 nil]
		targetOffset: 	(74.0@17.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		lastKeyScanCode: 	nil
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(986102528)
	Arguments and temporary variables: 
		anEvent: 	[(843@453) mouseUp 188910 nil]
	Receiver's instance variables: 
		bounds: 	(843@453) corner: (859@469)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	#()
		fullBounds: 	(843@453) corner: (859@469)
		color: 	Color blue
		extension: 	a MorphExtension (1065441536)
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(335468288)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(843@453) mouseUp 188910 nil]
		targetOffset: 	(74.0@17.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		lastKeyScanCode: 	nil
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>handleEvent:
	Receiver: a HandMorph(986102528)
	Arguments and temporary variables: 
		anEvent: 	[(843@453) mouseUp 188910 nil]
		evt: 	[(843@453) mouseUp 188910 nil]
	Receiver's instance variables: 
		bounds: 	(843@453) corner: (859@469)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	#()
		fullBounds: 	(843@453) corner: (859@469)
		color: 	Color blue
		extension: 	a MorphExtension (1065441536)
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(335468288)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(843@453) mouseUp 188910 nil]
		targetOffset: 	(74.0@17.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		lastKeyScanCode: 	nil
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
	Receiver: an OSWindowMorphicEventHandler
	Arguments and temporary variables: 
		anEvent: 	[(843@453) mouseUp 188910 nil]
	Receiver's instance variables: 
		morphicWorld: 	a WorldMorph(603310592) [world]


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(603310592) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(986102528))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	184678
		lastStepMessage: 	nil
		alarms: 	a Heap()
		lastAlarmTime: 	188889
		activeHand: 	a HandMorph(986102528)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1512@851)


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(603310592) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1512@851)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(1021235712) a TaskbarMorph(882262784) a SpDi...etc...
		fullBounds: 	(0@0) corner: (1512@851)
		color: 	(Color r: 0.29521016617790813 g: 0.29521016617790813 b: 0.29521016617790...etc...
		extension: 	a MorphExtension (219690240) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(603310592) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(986102528))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	184678
		lastStepMessage: 	nil
		alarms: 	a Heap()
		lastAlarmTime: 	188889
		activeHand: 	a HandMorph(986102528)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1512@851)


WorldMorph>>doOneCycleNow
	Receiver: a WorldMorph(603310592) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1512@851)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(1021235712) a TaskbarMorph(882262784) a SpDi...etc...
		fullBounds: 	(0@0) corner: (1512@851)
		color: 	(Color r: 0.29521016617790813 g: 0.29521016617790813 b: 0.29521016617790...etc...
		extension: 	a MorphExtension (219690240) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(603310592) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1512@851)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(1021235712) a TaskbarMorph(882262784) a SpDi...etc...
		fullBounds: 	(0@0) corner: (1512@851)
		color: 	(Color r: 0.29521016617790813 g: 0.29521016617790813 b: 0.29521016617790...etc...
		extension: 	a MorphExtension (219690240) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 
		extraWorldsToDraw: 	#()
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65547
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->nil #CursorOwnerWorld->a WorldMorph(60...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		announcer: 	nil
		displayScaleFactor: 	1


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extr...etc...
	Arguments and temporary variables: 
		aBlock: 	[
		self doInterCycleWait
	]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	WorldMorph class>>doOneCycle
		startpc: 	a CompiledBlock: [
		| extraWorldsToDraw |
		extraWorldsToDraw := Extr...etc...
		numArgs: 	0
		receiver: 	WorldMorph


WorldState class>>doDrawCycleWith:
	Receiver: WorldState
	Arguments and temporary variables: 
		aBlock: 	[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex cr...etc...
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#activeHand->WorldState>>#activeHand #activeHand...etc...
		format: 	65547
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldState}
		name: 	#WorldState
		classPool: 	a Dictionary(#CanSurrenderToOS->nil #DebugShowDamage->false #Deferre...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'


WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65547
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->nil #CursorOwnerWorld->a WorldMorph(60...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		announcer: 	nil
		displayScaleFactor: 	1


MorphicRenderLoop>>doOneCycle
	Receiver: a MorphicRenderLoop
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
a MorphicRenderLoop

MorphicRenderLoop>>doOneCycleWhile:
	Receiver: a MorphicRenderLoop
	Arguments and temporary variables: 
		aBlock: 	[ true ]
	Receiver's instance variables: 
a MorphicRenderLoop

[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		activeTranscript: 	nil



--- The full stack ---
IceTipLocalRepositoryPanel(Object)>>assert:description:
IceTipLocalRepositoryPanel>>validate
IceTipRegisterRepositoryDialog>>doAccept
[ self doAccept ] in IceTipRegisterRepositoryDialog(IceTipOptionDialog)>>initializeDialogWindow:
FullBlockClosure(BlockClosure)>>cull:
SpDialogWindowPresenter>>triggerOkAction
[ :presenter | 
			presenter triggerOkAction.
			presenter close ] in SpAbstractPresenter>>initializeDialogWindow:
FullBlockClosure(BlockClosure)>>cull:
[ aBlock cull: self ] in SpDialogWindowPresenter>>addButton:do:
SpButtonPresenter>>performAction
SpMorphicButtonAdapter>>action
PluggableButtonMorph>>performAction:
[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in PluggableButtonMorph>>mouseUp:
Array(SequenceableCollection)>>do:
PluggableButtonMorph>>mouseUp:
PluggableButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableButtonMorph(Morph)>>handleEvent:
PluggableButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
AssertionFailure: Project location does not seems to be a valid git repository.
26 September 2022 7:26:06.688621 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
StackToRegisterMappingCogit * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
v9.0.18 - Commit: 7249c170 - Date: 2022-09-02 14:31:12 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

IceTipLocalRepositoryPanel(Object)>>assert:description:
	Receiver: an IceTipLocalRepositoryPanel
	Arguments and temporary variables: 
		aBlock: 	false
		aStringOrBlock: 	'Project location does not seems to be a valid git repository.'...etc...
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	an IceTipRegisterRepositoryDialog
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		projectLocation: 	an IceTipDirectoryPresenter
		remoteLabel: 	nil
		remoteInputText: 	nil
		repository: 	nil


IceTipLocalRepositoryPanel>>validate
	Receiver: an IceTipLocalRepositoryPanel
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	an IceTipRegisterRepositoryDialog
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		projectLocation: 	an IceTipDirectoryPresenter
		remoteLabel: 	nil
		remoteInputText: 	nil
		repository: 	nil


IceTipRegisterRepositoryDialog>>doAccept
	Receiver: an IceTipRegisterRepositoryDialog
	Arguments and temporary variables: 
		newRepository: 	nil
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		owner: 	a SpDialogWindowPresenter
		adapter: 	a SpMorphicPanedAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a SpNullApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpPanedLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		typeList: 	a SpTablePresenter
		type: 	an IceTipLocalRepositoryPanel
		contentPanel: 	an IceTipLocalRepositoryPanel
		types: 	an OrderedCollection(an IceTipNewRepositoryPanel an IceTipLocalRepositor...etc...
		repository: 	nil
		acceptBlock: 	nil


[ self doAccept ] in IceTipRegisterRepositoryDialog(IceTipOptionDialog)>>initializeDialogWindow:
	Receiver: an IceTipRegisterRepositoryDialog
	Arguments and temporary variables: 
		aWindowPresenter: 	a SpDialogWindowPresenter
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		owner: 	a SpDialogWindowPresenter
		adapter: 	a SpMorphicPanedAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a SpNullApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpPanedLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		typeList: 	a SpTablePresenter
		type: 	an IceTipLocalRepositoryPanel
		contentPanel: 	an IceTipLocalRepositoryPanel
		types: 	an OrderedCollection(an IceTipNewRepositoryPanel an IceTipLocalRepositor...etc...
		repository: 	nil
		acceptBlock: 	nil


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ self doAccept ]
	Arguments and temporary variables: 
		anArg: 	a SpDialogWindowPresenter
	Receiver's instance variables: 
		outerContext: 	IceTipRegisterRepositoryDialog(IceTipOptionDialog)>>initializeDia...etc...
		startpc: 	a CompiledBlock: [ self doAccept ]
		numArgs: 	0
		receiver: 	an IceTipRegisterRepositoryDialog


SpDialogWindowPresenter>>triggerOkAction
	Receiver: a SpDialogWindowPresenter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicDialogWindowAdapter a SpDialogWindow(3...etc...
		announcer: 	an Announcer
		owner: 	nil
		adapter: 	a SpMorphicDialogWindowAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a SpNullApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ Form(16x16x32) ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ true ]
		titleHolder: 	an ObservableValueHolder[ 'Import from existing clone' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ nil ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		presenter: 	an ObservableValueHolder[ an IceTipRegisterRepositoryDialog ]
		initialPosition: 	an ObservableValueHolder[ nil ]
		initialExtent: 	an ObservableValueHolder[ (600@300) ]
		isResizeable: 	an ObservableValueHolder[ true ]
		menu: 	an ObservableValueHolder[ nil ]
		centered: 	an ObservableValueHolder[ false ]
		isClosed: 	an ObservableValueHolder[ false ]
		toolbar: 	an ObservableValueHolder[ nil ]
		statusbar: 	an ObservableValueHolder[ nil ]
		window: 	an ObservableValueHolder[ a SpDialogWindow(308885760) named: Import fro...etc...
		decorations: 	an ObservableValueHolder[ true ]
		buttons: 	an OrderedCollection(a SpButtonPresenter a SpButtonPresenter)
		okAction: 	[ self doAccept ]
		cancelAction: 	[ 
		cancelled := true.
		self close ]
		cancelled: 	true
		defaultButton: 	nil


[ :presenter | 
			presenter triggerOkAction.
			presenter close ] in SpAbstractPresenter>>initializeDialogWindow:
	Receiver: an IceTipRegisterRepositoryDialog
	Arguments and temporary variables: 
		aDialogWindowPresenter: 	a SpDialogWindowPresenter
		presenter: 	a SpDialogWindowPresenter
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		owner: 	a SpDialogWindowPresenter
		adapter: 	a SpMorphicPanedAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a SpNullApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpPanedLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		typeList: 	a SpTablePresenter
		type: 	an IceTipLocalRepositoryPanel
		contentPanel: 	an IceTipLocalRepositoryPanel
		types: 	an OrderedCollection(an IceTipNewRepositoryPanel an IceTipLocalRepositor...etc...
		repository: 	nil
		acceptBlock: 	nil


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ :presenter | 
			presenter triggerOkAction.
			presenter close ]
	Arguments and temporary variables: 
		anArg: 	a SpDialogWindowPresenter
	Receiver's instance variables: 
		outerContext: 	IceTipRegisterRepositoryDialog(SpAbstractPresenter)>>initializeDi...etc...
		startpc: 	a CompiledBlock: [ :presenter | 
			presenter triggerOkAction.
			pres...etc...
		numArgs: 	1
		receiver: 	an IceTipRegisterRepositoryDialog


[ aBlock cull: self ] in SpDialogWindowPresenter>>addButton:do:
	Receiver: a SpDialogWindowPresenter
	Arguments and temporary variables: 
		aString: 	'Ok'
		aBlock: 	[ :presenter | 
			presenter triggerOkAction.
			presenter close ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicDialogWindowAdapter a SpDialogWindow(3...etc...
		announcer: 	an Announcer
		owner: 	nil
		adapter: 	a SpMorphicDialogWindowAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a SpNullApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ Form(16x16x32) ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ true ]
		titleHolder: 	an ObservableValueHolder[ 'Import from existing clone' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ nil ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		presenter: 	an ObservableValueHolder[ an IceTipRegisterRepositoryDialog ]
		initialPosition: 	an ObservableValueHolder[ nil ]
		initialExtent: 	an ObservableValueHolder[ (600@300) ]
		isResizeable: 	an ObservableValueHolder[ true ]
		menu: 	an ObservableValueHolder[ nil ]
		centered: 	an ObservableValueHolder[ false ]
		isClosed: 	an ObservableValueHolder[ false ]
		toolbar: 	an ObservableValueHolder[ nil ]
		statusbar: 	an ObservableValueHolder[ nil ]
		window: 	an ObservableValueHolder[ a SpDialogWindow(308885760) named: Import fro...etc...
		decorations: 	an ObservableValueHolder[ true ]
		buttons: 	an OrderedCollection(a SpButtonPresenter a SpButtonPresenter)
		okAction: 	[ self doAccept ]
		cancelAction: 	[ 
		cancelled := true.
		self close ]
		cancelled: 	true
		defaultButton: 	nil


SpButtonPresenter>>performAction
	Receiver: a SpButtonPresenter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicButtonAdapter)
		announcer: 	an Announcer
		owner: 	a SpButtonBarPresenter
		adapter: 	a SpMorphicButtonAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Button' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		icon: 	an ObservableValueHolder[ nil ]
		label: 	an ObservableValueHolder[ 'Ok' ]
		action: 	an ObservableValueHolder[ [ aBlock cull: self ] ]
		actionPerformed: 	an ObservableValueHolder[ nil ]
		askBeforeChanging: 	an ObservableValueHolder[ false ]
		font: 	an ObservableValueHolder[ nil ]
		shortcut: 	an ObservableValueHolder[ nil ]
		state: 	an ObservableValueHolder[ false ]
		contextMenu: 	an ObservableValueHolder[ nil ]


SpMorphicButtonAdapter>>action
	Receiver: a SpMorphicButtonAdapter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a PluggableButtonMorph(335468288))
		announcer: 	nil
		model: 	a SpButtonPresenter
		widget: 	a PluggableButtonMorph(335468288)
		selector: 	nil
		owner: 	a SpButtonPresenter
		subMenuWidget: 	nil
		styleName: 	nil


PluggableButtonMorph>>performAction:
	Receiver: a PluggableButtonMorph(335468288)
	Arguments and temporary variables: 
		event: 	[(823@441) mouseUp 220343 nil]
	Receiver's instance variables: 
		bounds: 	(769.0@436.0) corner: (869.0@466.0)
		owner: 	a PanelMorph(1071747072)
		submorphs: 	an Array(an AlignmentMorph(502232320))
		fullBounds: 	nil
		color: 	(Color r: 0.2903225806451613 g: 0.2883675464320626 b: 0.2883675464320626...etc...
		extension: 	a MorphExtension (169478144) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a SpMorphicButtonAdapter
		label: 	'Ok'
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	#state
		actionSelector: 	#action
		font: 	nil
		getLabelSelector: 	#label
		getMenuSelector: 	#menu:
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		getFontSelector: 	#font
		labelMorph: 	a LabelMorph(236987904)'Ok'
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	false


[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(335468288)
	Arguments and temporary variables: 
		evt: 	[(823@441) mouseUp 220343 nil]
		all: 	an Array(a PluggableButtonMorph(857193472) a PluggableButtonMorph(33546828...etc...
		m: 	a PluggableButtonMorph(335468288)
	Receiver's instance variables: 
		bounds: 	(769.0@436.0) corner: (869.0@466.0)
		owner: 	a PanelMorph(1071747072)
		submorphs: 	an Array(an AlignmentMorph(502232320))
		fullBounds: 	nil
		color: 	(Color r: 0.2903225806451613 g: 0.2883675464320626 b: 0.2883675464320626...etc...
		extension: 	a MorphExtension (169478144) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a SpMorphicButtonAdapter
		label: 	'Ok'
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	#state
		actionSelector: 	#action
		font: 	nil
		getLabelSelector: 	#label
		getMenuSelector: 	#menu:
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		getFontSelector: 	#font
		labelMorph: 	a LabelMorph(236987904)'Ok'
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	false


Array(SequenceableCollection)>>do:
	Receiver: an Array(a PluggableButtonMorph(857193472) a PluggableButtonMorph(335468288))
	Arguments and temporary variables: 
		aBlock: 	[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [...etc...
		index: 	2
	Receiver's instance variables: 
an Array(a PluggableButtonMorph(857193472) a PluggableButtonMorph(335468288))

PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(335468288)
	Arguments and temporary variables: 
		evt: 	[(823@441) mouseUp 220343 nil]
		all: 	an Array(a PluggableButtonMorph(857193472) a PluggableButtonMorph(33546828...etc...
	Receiver's instance variables: 
		bounds: 	(769.0@436.0) corner: (869.0@466.0)
		owner: 	a PanelMorph(1071747072)
		submorphs: 	an Array(an AlignmentMorph(502232320))
		fullBounds: 	nil
		color: 	(Color r: 0.2903225806451613 g: 0.2883675464320626 b: 0.2883675464320626...etc...
		extension: 	a MorphExtension (169478144) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a SpMorphicButtonAdapter
		label: 	'Ok'
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	#state
		actionSelector: 	#action
		font: 	nil
		getLabelSelector: 	#label
		getMenuSelector: 	#menu:
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		getFontSelector: 	#font
		labelMorph: 	a LabelMorph(236987904)'Ok'
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	false


PluggableButtonMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableButtonMorph(335468288)
	Arguments and temporary variables: 
		anEvent: 	[(823@441) mouseUp 220343 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(769.0@436.0) corner: (869.0@466.0)
		owner: 	a PanelMorph(1071747072)
		submorphs: 	an Array(an AlignmentMorph(502232320))
		fullBounds: 	nil
		color: 	(Color r: 0.2903225806451613 g: 0.2883675464320626 b: 0.2883675464320626...etc...
		extension: 	a MorphExtension (169478144) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a SpMorphicButtonAdapter
		label: 	'Ok'
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	#state
		actionSelector: 	#action
		font: 	nil
		getLabelSelector: 	#label
		getMenuSelector: 	#menu:
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		getFontSelector: 	#font
		labelMorph: 	a LabelMorph(236987904)'Ok'
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	false


MouseButtonEvent>>sentTo:
	Receiver: [(823@441) mouseUp 220343 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableButtonMorph(335468288)
	Receiver's instance variables: 
		timeStamp: 	220343
		source: 	a HandMorph(986102528)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(823@441)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableButtonMorph(Morph)>>handleEvent:
	Receiver: a PluggableButtonMorph(335468288)
	Arguments and temporary variables: 
		anEvent: 	[(823@441) mouseUp 220343 nil]
	Receiver's instance variables: 
		bounds: 	(769.0@436.0) corner: (869.0@466.0)
		owner: 	a PanelMorph(1071747072)
		submorphs: 	an Array(an AlignmentMorph(502232320))
		fullBounds: 	nil
		color: 	(Color r: 0.2903225806451613 g: 0.2883675464320626 b: 0.2883675464320626...etc...
		extension: 	a MorphExtension (169478144) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a SpMorphicButtonAdapter
		label: 	'Ok'
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	#state
		actionSelector: 	#action
		font: 	nil
		getLabelSelector: 	#label
		getMenuSelector: 	#menu:
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		getFontSelector: 	#font
		labelMorph: 	a LabelMorph(236987904)'Ok'
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	false


PluggableButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a PluggableButtonMorph(335468288)
	Arguments and temporary variables: 
		anEvent: 	[(823@441) mouseUp 220343 nil]
	Receiver's instance variables: 
		bounds: 	(769.0@436.0) corner: (869.0@466.0)
		owner: 	a PanelMorph(1071747072)
		submorphs: 	an Array(an AlignmentMorph(502232320))
		fullBounds: 	nil
		color: 	(Color r: 0.2903225806451613 g: 0.2883675464320626 b: 0.2883675464320626...etc...
		extension: 	a MorphExtension (169478144) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a SpMorphicButtonAdapter
		label: 	'Ok'
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	#state
		actionSelector: 	#action
		font: 	nil
		getLabelSelector: 	#label
		getMenuSelector: 	#menu:
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		getFontSelector: 	#font
		labelMorph: 	a LabelMorph(236987904)'Ok'
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	false


[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(986102528)
	Arguments and temporary variables: 
		anEvent: 	[(823@441) mouseUp 220343 nil]
		focusHolder: 	a PluggableButtonMorph(335468288)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(603310592) [world]
		transformedEvent: 	[(823@441) mouseUp 220343 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(823@441) corner: (839@457)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	#()
		fullBounds: 	(823@441) corner: (839@457)
		color: 	Color blue
		extension: 	a MorphExtension (1065441536)
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(335468288)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(823@441) mouseUp 220343 nil]
		targetOffset: 	(54.0@5.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		lastKeyScanCode: 	nil
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		result := focusHolder handleFocusEvent: transformedEvent.
	]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
			ActiveWorld := priorWorld.
			ex pass ]
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	a CompiledBlock: [
		result := focusHolder handleFocusEvent: transform...etc...
		numArgs: 	0
		receiver: 	a HandMorph(986102528)


WorldMorph>>becomeActiveDuring:
	Receiver: a WorldMorph(603310592) [world]
	Arguments and temporary variables: 
		aBlock: 	[
		result := focusHolder handleFocusEvent: transformedEvent.
	]
		priorWorld: 	a WorldMorph(603310592) [world]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1512@851)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(1021235712) a TaskbarMorph(882262784) a SpDi...etc...
		fullBounds: 	(0@0) corner: (1512@851)
		color: 	(Color r: 0.29521016617790813 g: 0.29521016617790813 b: 0.29521016617790...etc...
		extension: 	a MorphExtension (219690240) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(986102528)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(823@441) mouseUp 220343 nil]
		focusHolder: 	a PluggableButtonMorph(335468288)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(603310592) [world]
		transformedEvent: 	[(823@441) mouseUp 220343 nil]
	Receiver's instance variables: 
		bounds: 	(823@441) corner: (839@457)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	#()
		fullBounds: 	(823@441) corner: (839@457)
		color: 	Color blue
		extension: 	a MorphExtension (1065441536)
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(335468288)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(823@441) mouseUp 220343 nil]
		targetOffset: 	(54.0@5.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		lastKeyScanCode: 	nil
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(986102528)
	Arguments and temporary variables: 
		anEvent: 	[(823@441) mouseUp 220343 nil]
		focusHolder: 	a PluggableButtonMorph(335468288)
		aBlock: 	[self mouseFocus: nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(823@441) corner: (839@457)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	#()
		fullBounds: 	(823@441) corner: (839@457)
		color: 	Color blue
		extension: 	a MorphExtension (1065441536)
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(335468288)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(823@441) mouseUp 220343 nil]
		targetOffset: 	(54.0@5.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		lastKeyScanCode: 	nil
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(986102528)
	Arguments and temporary variables: 
		anEvent: 	[(823@441) mouseUp 220343 nil]
	Receiver's instance variables: 
		bounds: 	(823@441) corner: (839@457)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	#()
		fullBounds: 	(823@441) corner: (839@457)
		color: 	Color blue
		extension: 	a MorphExtension (1065441536)
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(335468288)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(823@441) mouseUp 220343 nil]
		targetOffset: 	(54.0@5.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		lastKeyScanCode: 	nil
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>handleEvent:
	Receiver: a HandMorph(986102528)
	Arguments and temporary variables: 
		anEvent: 	[(823@441) mouseUp 220343 nil]
		evt: 	[(823@441) mouseUp 220343 nil]
	Receiver's instance variables: 
		bounds: 	(823@441) corner: (839@457)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	#()
		fullBounds: 	(823@441) corner: (839@457)
		color: 	Color blue
		extension: 	a MorphExtension (1065441536)
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(335468288)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(823@441) mouseUp 220343 nil]
		targetOffset: 	(54.0@5.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		lastKeyScanCode: 	nil
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
	Receiver: an OSWindowMorphicEventHandler
	Arguments and temporary variables: 
		anEvent: 	[(823@441) mouseUp 220343 nil]
	Receiver's instance variables: 
		morphicWorld: 	a WorldMorph(603310592) [world]


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(603310592) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(986102528))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	184678
		lastStepMessage: 	nil
		alarms: 	a Heap()
		lastAlarmTime: 	220330
		activeHand: 	a HandMorph(986102528)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1512@851)


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(603310592) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1512@851)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(1021235712) a TaskbarMorph(882262784) a SpDi...etc...
		fullBounds: 	(0@0) corner: (1512@851)
		color: 	(Color r: 0.29521016617790813 g: 0.29521016617790813 b: 0.29521016617790...etc...
		extension: 	a MorphExtension (219690240) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(603310592) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(986102528))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	184678
		lastStepMessage: 	nil
		alarms: 	a Heap()
		lastAlarmTime: 	220330
		activeHand: 	a HandMorph(986102528)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1512@851)


WorldMorph>>doOneCycleNow
	Receiver: a WorldMorph(603310592) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1512@851)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(1021235712) a TaskbarMorph(882262784) a SpDi...etc...
		fullBounds: 	(0@0) corner: (1512@851)
		color: 	(Color r: 0.29521016617790813 g: 0.29521016617790813 b: 0.29521016617790...etc...
		extension: 	a MorphExtension (219690240) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(603310592) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1512@851)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(1021235712) a TaskbarMorph(882262784) a SpDi...etc...
		fullBounds: 	(0@0) corner: (1512@851)
		color: 	(Color r: 0.29521016617790813 g: 0.29521016617790813 b: 0.29521016617790...etc...
		extension: 	a MorphExtension (219690240) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 
		extraWorldsToDraw: 	#()
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65547
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->nil #CursorOwnerWorld->a WorldMorph(60...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		announcer: 	nil
		displayScaleFactor: 	1


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extr...etc...
	Arguments and temporary variables: 
		aBlock: 	[
		self doInterCycleWait
	]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	WorldMorph class>>doOneCycle
		startpc: 	a CompiledBlock: [
		| extraWorldsToDraw |
		extraWorldsToDraw := Extr...etc...
		numArgs: 	0
		receiver: 	WorldMorph


WorldState class>>doDrawCycleWith:
	Receiver: WorldState
	Arguments and temporary variables: 
		aBlock: 	[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex cr...etc...
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#activeHand->WorldState>>#activeHand #activeHand...etc...
		format: 	65547
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldState}
		name: 	#WorldState
		classPool: 	a Dictionary(#CanSurrenderToOS->nil #DebugShowDamage->false #Deferre...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'


WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65547
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->nil #CursorOwnerWorld->a WorldMorph(60...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		announcer: 	nil
		displayScaleFactor: 	1


MorphicRenderLoop>>doOneCycle
	Receiver: a MorphicRenderLoop
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
a MorphicRenderLoop

MorphicRenderLoop>>doOneCycleWhile:
	Receiver: a MorphicRenderLoop
	Arguments and temporary variables: 
		aBlock: 	[ true ]
	Receiver's instance variables: 
a MorphicRenderLoop

[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		activeTranscript: 	nil



--- The full stack ---
IceTipLocalRepositoryPanel(Object)>>assert:description:
IceTipLocalRepositoryPanel>>validate
IceTipRegisterRepositoryDialog>>doAccept
[ self doAccept ] in IceTipRegisterRepositoryDialog(IceTipOptionDialog)>>initializeDialogWindow:
FullBlockClosure(BlockClosure)>>cull:
SpDialogWindowPresenter>>triggerOkAction
[ :presenter | 
			presenter triggerOkAction.
			presenter close ] in SpAbstractPresenter>>initializeDialogWindow:
FullBlockClosure(BlockClosure)>>cull:
[ aBlock cull: self ] in SpDialogWindowPresenter>>addButton:do:
SpButtonPresenter>>performAction
SpMorphicButtonAdapter>>action
PluggableButtonMorph>>performAction:
[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in PluggableButtonMorph>>mouseUp:
Array(SequenceableCollection)>>do:
PluggableButtonMorph>>mouseUp:
PluggableButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableButtonMorph(Morph)>>handleEvent:
PluggableButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
AssertionFailure: Project location does not seems to be a valid git repository.
26 September 2022 7:26:06.715152 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
StackToRegisterMappingCogit * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
v9.0.18 - Commit: 7249c170 - Date: 2022-09-02 14:31:12 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

IceTipLocalRepositoryPanel(Object)>>assert:description:
	Receiver: an IceTipLocalRepositoryPanel
	Arguments and temporary variables: 
		aBlock: 	false
		aStringOrBlock: 	'Project location does not seems to be a valid git repository.'...etc...
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	an IceTipRegisterRepositoryDialog
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		projectLocation: 	an IceTipDirectoryPresenter
		remoteLabel: 	nil
		remoteInputText: 	nil
		repository: 	nil


IceTipLocalRepositoryPanel>>validate
	Receiver: an IceTipLocalRepositoryPanel
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	an IceTipRegisterRepositoryDialog
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		projectLocation: 	an IceTipDirectoryPresenter
		remoteLabel: 	nil
		remoteInputText: 	nil
		repository: 	nil


IceTipRegisterRepositoryDialog>>doAccept
	Receiver: an IceTipRegisterRepositoryDialog
	Arguments and temporary variables: 
		newRepository: 	nil
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		owner: 	a SpDialogWindowPresenter
		adapter: 	a SpMorphicPanedAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a SpNullApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpPanedLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		typeList: 	a SpTablePresenter
		type: 	an IceTipLocalRepositoryPanel
		contentPanel: 	an IceTipLocalRepositoryPanel
		types: 	an OrderedCollection(an IceTipNewRepositoryPanel an IceTipLocalRepositor...etc...
		repository: 	nil
		acceptBlock: 	nil


[ self doAccept ] in IceTipRegisterRepositoryDialog(IceTipOptionDialog)>>initializeDialogWindow:
	Receiver: an IceTipRegisterRepositoryDialog
	Arguments and temporary variables: 
		aWindowPresenter: 	a SpDialogWindowPresenter
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		owner: 	a SpDialogWindowPresenter
		adapter: 	a SpMorphicPanedAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a SpNullApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpPanedLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		typeList: 	a SpTablePresenter
		type: 	an IceTipLocalRepositoryPanel
		contentPanel: 	an IceTipLocalRepositoryPanel
		types: 	an OrderedCollection(an IceTipNewRepositoryPanel an IceTipLocalRepositor...etc...
		repository: 	nil
		acceptBlock: 	nil


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ self doAccept ]
	Arguments and temporary variables: 
		anArg: 	a SpDialogWindowPresenter
	Receiver's instance variables: 
		outerContext: 	IceTipRegisterRepositoryDialog(IceTipOptionDialog)>>initializeDia...etc...
		startpc: 	a CompiledBlock: [ self doAccept ]
		numArgs: 	0
		receiver: 	an IceTipRegisterRepositoryDialog


SpDialogWindowPresenter>>triggerOkAction
	Receiver: a SpDialogWindowPresenter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicDialogWindowAdapter a SpDialogWindow(3...etc...
		announcer: 	an Announcer
		owner: 	nil
		adapter: 	a SpMorphicDialogWindowAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a SpNullApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ Form(16x16x32) ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ true ]
		titleHolder: 	an ObservableValueHolder[ 'Import from existing clone' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ nil ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		presenter: 	an ObservableValueHolder[ an IceTipRegisterRepositoryDialog ]
		initialPosition: 	an ObservableValueHolder[ nil ]
		initialExtent: 	an ObservableValueHolder[ (600@300) ]
		isResizeable: 	an ObservableValueHolder[ true ]
		menu: 	an ObservableValueHolder[ nil ]
		centered: 	an ObservableValueHolder[ false ]
		isClosed: 	an ObservableValueHolder[ false ]
		toolbar: 	an ObservableValueHolder[ nil ]
		statusbar: 	an ObservableValueHolder[ nil ]
		window: 	an ObservableValueHolder[ a SpDialogWindow(308885760) named: Import fro...etc...
		decorations: 	an ObservableValueHolder[ true ]
		buttons: 	an OrderedCollection(a SpButtonPresenter a SpButtonPresenter)
		okAction: 	[ self doAccept ]
		cancelAction: 	[ 
		cancelled := true.
		self close ]
		cancelled: 	true
		defaultButton: 	nil


[ :presenter | 
			presenter triggerOkAction.
			presenter close ] in SpAbstractPresenter>>initializeDialogWindow:
	Receiver: an IceTipRegisterRepositoryDialog
	Arguments and temporary variables: 
		aDialogWindowPresenter: 	a SpDialogWindowPresenter
		presenter: 	a SpDialogWindowPresenter
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		owner: 	a SpDialogWindowPresenter
		adapter: 	a SpMorphicPanedAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a SpNullApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpPanedLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		typeList: 	a SpTablePresenter
		type: 	an IceTipLocalRepositoryPanel
		contentPanel: 	an IceTipLocalRepositoryPanel
		types: 	an OrderedCollection(an IceTipNewRepositoryPanel an IceTipLocalRepositor...etc...
		repository: 	nil
		acceptBlock: 	nil


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ :presenter | 
			presenter triggerOkAction.
			presenter close ]
	Arguments and temporary variables: 
		anArg: 	a SpDialogWindowPresenter
	Receiver's instance variables: 
		outerContext: 	IceTipRegisterRepositoryDialog(SpAbstractPresenter)>>initializeDi...etc...
		startpc: 	a CompiledBlock: [ :presenter | 
			presenter triggerOkAction.
			pres...etc...
		numArgs: 	1
		receiver: 	an IceTipRegisterRepositoryDialog


[ aBlock cull: self ] in SpDialogWindowPresenter>>addButton:do:
	Receiver: a SpDialogWindowPresenter
	Arguments and temporary variables: 
		aString: 	'Ok'
		aBlock: 	[ :presenter | 
			presenter triggerOkAction.
			presenter close ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicDialogWindowAdapter a SpDialogWindow(3...etc...
		announcer: 	an Announcer
		owner: 	nil
		adapter: 	a SpMorphicDialogWindowAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a SpNullApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ Form(16x16x32) ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ true ]
		titleHolder: 	an ObservableValueHolder[ 'Import from existing clone' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ nil ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		presenter: 	an ObservableValueHolder[ an IceTipRegisterRepositoryDialog ]
		initialPosition: 	an ObservableValueHolder[ nil ]
		initialExtent: 	an ObservableValueHolder[ (600@300) ]
		isResizeable: 	an ObservableValueHolder[ true ]
		menu: 	an ObservableValueHolder[ nil ]
		centered: 	an ObservableValueHolder[ false ]
		isClosed: 	an ObservableValueHolder[ false ]
		toolbar: 	an ObservableValueHolder[ nil ]
		statusbar: 	an ObservableValueHolder[ nil ]
		window: 	an ObservableValueHolder[ a SpDialogWindow(308885760) named: Import fro...etc...
		decorations: 	an ObservableValueHolder[ true ]
		buttons: 	an OrderedCollection(a SpButtonPresenter a SpButtonPresenter)
		okAction: 	[ self doAccept ]
		cancelAction: 	[ 
		cancelled := true.
		self close ]
		cancelled: 	true
		defaultButton: 	nil


SpButtonPresenter>>performAction
	Receiver: a SpButtonPresenter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicButtonAdapter)
		announcer: 	an Announcer
		owner: 	a SpButtonBarPresenter
		adapter: 	a SpMorphicButtonAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Button' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		icon: 	an ObservableValueHolder[ nil ]
		label: 	an ObservableValueHolder[ 'Ok' ]
		action: 	an ObservableValueHolder[ [ aBlock cull: self ] ]
		actionPerformed: 	an ObservableValueHolder[ nil ]
		askBeforeChanging: 	an ObservableValueHolder[ false ]
		font: 	an ObservableValueHolder[ nil ]
		shortcut: 	an ObservableValueHolder[ nil ]
		state: 	an ObservableValueHolder[ false ]
		contextMenu: 	an ObservableValueHolder[ nil ]


SpMorphicButtonAdapter>>action
	Receiver: a SpMorphicButtonAdapter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a PluggableButtonMorph(335468288))
		announcer: 	nil
		model: 	a SpButtonPresenter
		widget: 	a PluggableButtonMorph(335468288)
		selector: 	nil
		owner: 	a SpButtonPresenter
		subMenuWidget: 	nil
		styleName: 	nil


PluggableButtonMorph>>performAction:
	Receiver: a PluggableButtonMorph(335468288)
	Arguments and temporary variables: 
		event: 	[(823@441) mouseUp 220343 nil]
	Receiver's instance variables: 
		bounds: 	(769.0@436.0) corner: (869.0@466.0)
		owner: 	a PanelMorph(1071747072)
		submorphs: 	an Array(an AlignmentMorph(502232320))
		fullBounds: 	nil
		color: 	(Color r: 0.2903225806451613 g: 0.2883675464320626 b: 0.2883675464320626...etc...
		extension: 	a MorphExtension (169478144) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a SpMorphicButtonAdapter
		label: 	'Ok'
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	#state
		actionSelector: 	#action
		font: 	nil
		getLabelSelector: 	#label
		getMenuSelector: 	#menu:
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		getFontSelector: 	#font
		labelMorph: 	a LabelMorph(236987904)'Ok'
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	false


[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(335468288)
	Arguments and temporary variables: 
		evt: 	[(823@441) mouseUp 220343 nil]
		all: 	an Array(a PluggableButtonMorph(857193472) a PluggableButtonMorph(33546828...etc...
		m: 	a PluggableButtonMorph(335468288)
	Receiver's instance variables: 
		bounds: 	(769.0@436.0) corner: (869.0@466.0)
		owner: 	a PanelMorph(1071747072)
		submorphs: 	an Array(an AlignmentMorph(502232320))
		fullBounds: 	nil
		color: 	(Color r: 0.2903225806451613 g: 0.2883675464320626 b: 0.2883675464320626...etc...
		extension: 	a MorphExtension (169478144) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a SpMorphicButtonAdapter
		label: 	'Ok'
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	#state
		actionSelector: 	#action
		font: 	nil
		getLabelSelector: 	#label
		getMenuSelector: 	#menu:
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		getFontSelector: 	#font
		labelMorph: 	a LabelMorph(236987904)'Ok'
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	false


Array(SequenceableCollection)>>do:
	Receiver: an Array(a PluggableButtonMorph(857193472) a PluggableButtonMorph(335468288))
	Arguments and temporary variables: 
		aBlock: 	[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [...etc...
		index: 	2
	Receiver's instance variables: 
an Array(a PluggableButtonMorph(857193472) a PluggableButtonMorph(335468288))

PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(335468288)
	Arguments and temporary variables: 
		evt: 	[(823@441) mouseUp 220343 nil]
		all: 	an Array(a PluggableButtonMorph(857193472) a PluggableButtonMorph(33546828...etc...
	Receiver's instance variables: 
		bounds: 	(769.0@436.0) corner: (869.0@466.0)
		owner: 	a PanelMorph(1071747072)
		submorphs: 	an Array(an AlignmentMorph(502232320))
		fullBounds: 	nil
		color: 	(Color r: 0.2903225806451613 g: 0.2883675464320626 b: 0.2883675464320626...etc...
		extension: 	a MorphExtension (169478144) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a SpMorphicButtonAdapter
		label: 	'Ok'
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	#state
		actionSelector: 	#action
		font: 	nil
		getLabelSelector: 	#label
		getMenuSelector: 	#menu:
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		getFontSelector: 	#font
		labelMorph: 	a LabelMorph(236987904)'Ok'
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	false


PluggableButtonMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableButtonMorph(335468288)
	Arguments and temporary variables: 
		anEvent: 	[(823@441) mouseUp 220343 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(769.0@436.0) corner: (869.0@466.0)
		owner: 	a PanelMorph(1071747072)
		submorphs: 	an Array(an AlignmentMorph(502232320))
		fullBounds: 	nil
		color: 	(Color r: 0.2903225806451613 g: 0.2883675464320626 b: 0.2883675464320626...etc...
		extension: 	a MorphExtension (169478144) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a SpMorphicButtonAdapter
		label: 	'Ok'
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	#state
		actionSelector: 	#action
		font: 	nil
		getLabelSelector: 	#label
		getMenuSelector: 	#menu:
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		getFontSelector: 	#font
		labelMorph: 	a LabelMorph(236987904)'Ok'
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	false


MouseButtonEvent>>sentTo:
	Receiver: [(823@441) mouseUp 220343 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableButtonMorph(335468288)
	Receiver's instance variables: 
		timeStamp: 	220343
		source: 	a HandMorph(986102528)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(823@441)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableButtonMorph(Morph)>>handleEvent:
	Receiver: a PluggableButtonMorph(335468288)
	Arguments and temporary variables: 
		anEvent: 	[(823@441) mouseUp 220343 nil]
	Receiver's instance variables: 
		bounds: 	(769.0@436.0) corner: (869.0@466.0)
		owner: 	a PanelMorph(1071747072)
		submorphs: 	an Array(an AlignmentMorph(502232320))
		fullBounds: 	nil
		color: 	(Color r: 0.2903225806451613 g: 0.2883675464320626 b: 0.2883675464320626...etc...
		extension: 	a MorphExtension (169478144) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a SpMorphicButtonAdapter
		label: 	'Ok'
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	#state
		actionSelector: 	#action
		font: 	nil
		getLabelSelector: 	#label
		getMenuSelector: 	#menu:
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		getFontSelector: 	#font
		labelMorph: 	a LabelMorph(236987904)'Ok'
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	false


PluggableButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a PluggableButtonMorph(335468288)
	Arguments and temporary variables: 
		anEvent: 	[(823@441) mouseUp 220343 nil]
	Receiver's instance variables: 
		bounds: 	(769.0@436.0) corner: (869.0@466.0)
		owner: 	a PanelMorph(1071747072)
		submorphs: 	an Array(an AlignmentMorph(502232320))
		fullBounds: 	nil
		color: 	(Color r: 0.2903225806451613 g: 0.2883675464320626 b: 0.2883675464320626...etc...
		extension: 	a MorphExtension (169478144) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a SpMorphicButtonAdapter
		label: 	'Ok'
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	#state
		actionSelector: 	#action
		font: 	nil
		getLabelSelector: 	#label
		getMenuSelector: 	#menu:
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		getFontSelector: 	#font
		labelMorph: 	a LabelMorph(236987904)'Ok'
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	false


[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(986102528)
	Arguments and temporary variables: 
		anEvent: 	[(823@441) mouseUp 220343 nil]
		focusHolder: 	a PluggableButtonMorph(335468288)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(603310592) [world]
		transformedEvent: 	[(823@441) mouseUp 220343 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(823@441) corner: (839@457)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	#()
		fullBounds: 	(823@441) corner: (839@457)
		color: 	Color blue
		extension: 	a MorphExtension (1065441536)
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(335468288)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(823@441) mouseUp 220343 nil]
		targetOffset: 	(54.0@5.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		lastKeyScanCode: 	nil
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		result := focusHolder handleFocusEvent: transformedEvent.
	]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
			ActiveWorld := priorWorld.
			ex pass ]
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	a CompiledBlock: [
		result := focusHolder handleFocusEvent: transform...etc...
		numArgs: 	0
		receiver: 	a HandMorph(986102528)


WorldMorph>>becomeActiveDuring:
	Receiver: a WorldMorph(603310592) [world]
	Arguments and temporary variables: 
		aBlock: 	[
		result := focusHolder handleFocusEvent: transformedEvent.
	]
		priorWorld: 	a WorldMorph(603310592) [world]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1512@851)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(1021235712) a TaskbarMorph(882262784) a SpDi...etc...
		fullBounds: 	(0@0) corner: (1512@851)
		color: 	(Color r: 0.29521016617790813 g: 0.29521016617790813 b: 0.29521016617790...etc...
		extension: 	a MorphExtension (219690240) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(986102528)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(823@441) mouseUp 220343 nil]
		focusHolder: 	a PluggableButtonMorph(335468288)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(603310592) [world]
		transformedEvent: 	[(823@441) mouseUp 220343 nil]
	Receiver's instance variables: 
		bounds: 	(823@441) corner: (839@457)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	#()
		fullBounds: 	(823@441) corner: (839@457)
		color: 	Color blue
		extension: 	a MorphExtension (1065441536)
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(335468288)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(823@441) mouseUp 220343 nil]
		targetOffset: 	(54.0@5.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		lastKeyScanCode: 	nil
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(986102528)
	Arguments and temporary variables: 
		anEvent: 	[(823@441) mouseUp 220343 nil]
		focusHolder: 	a PluggableButtonMorph(335468288)
		aBlock: 	[self mouseFocus: nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(823@441) corner: (839@457)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	#()
		fullBounds: 	(823@441) corner: (839@457)
		color: 	Color blue
		extension: 	a MorphExtension (1065441536)
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(335468288)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(823@441) mouseUp 220343 nil]
		targetOffset: 	(54.0@5.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		lastKeyScanCode: 	nil
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(986102528)
	Arguments and temporary variables: 
		anEvent: 	[(823@441) mouseUp 220343 nil]
	Receiver's instance variables: 
		bounds: 	(823@441) corner: (839@457)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	#()
		fullBounds: 	(823@441) corner: (839@457)
		color: 	Color blue
		extension: 	a MorphExtension (1065441536)
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(335468288)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(823@441) mouseUp 220343 nil]
		targetOffset: 	(54.0@5.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		lastKeyScanCode: 	nil
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>handleEvent:
	Receiver: a HandMorph(986102528)
	Arguments and temporary variables: 
		anEvent: 	[(823@441) mouseUp 220343 nil]
		evt: 	[(823@441) mouseUp 220343 nil]
	Receiver's instance variables: 
		bounds: 	(823@441) corner: (839@457)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	#()
		fullBounds: 	(823@441) corner: (839@457)
		color: 	Color blue
		extension: 	a MorphExtension (1065441536)
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(335468288)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(823@441) mouseUp 220343 nil]
		targetOffset: 	(54.0@5.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		lastKeyScanCode: 	nil
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
	Receiver: an OSWindowMorphicEventHandler
	Arguments and temporary variables: 
		anEvent: 	[(823@441) mouseUp 220343 nil]
	Receiver's instance variables: 
		morphicWorld: 	a WorldMorph(603310592) [world]


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(603310592) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(986102528))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	184678
		lastStepMessage: 	nil
		alarms: 	a Heap()
		lastAlarmTime: 	220330
		activeHand: 	a HandMorph(986102528)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1512@851)


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(603310592) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1512@851)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(1021235712) a TaskbarMorph(882262784) a SpDi...etc...
		fullBounds: 	(0@0) corner: (1512@851)
		color: 	(Color r: 0.29521016617790813 g: 0.29521016617790813 b: 0.29521016617790...etc...
		extension: 	a MorphExtension (219690240) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(603310592) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(986102528))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	184678
		lastStepMessage: 	nil
		alarms: 	a Heap()
		lastAlarmTime: 	220330
		activeHand: 	a HandMorph(986102528)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1512@851)


WorldMorph>>doOneCycleNow
	Receiver: a WorldMorph(603310592) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1512@851)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(1021235712) a TaskbarMorph(882262784) a SpDi...etc...
		fullBounds: 	(0@0) corner: (1512@851)
		color: 	(Color r: 0.29521016617790813 g: 0.29521016617790813 b: 0.29521016617790...etc...
		extension: 	a MorphExtension (219690240) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(603310592) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1512@851)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(1021235712) a TaskbarMorph(882262784) a SpDi...etc...
		fullBounds: 	(0@0) corner: (1512@851)
		color: 	(Color r: 0.29521016617790813 g: 0.29521016617790813 b: 0.29521016617790...etc...
		extension: 	a MorphExtension (219690240) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 
		extraWorldsToDraw: 	#()
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65547
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->nil #CursorOwnerWorld->a WorldMorph(60...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		announcer: 	nil
		displayScaleFactor: 	1


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extr...etc...
	Arguments and temporary variables: 
		aBlock: 	[
		self doInterCycleWait
	]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	WorldMorph class>>doOneCycle
		startpc: 	a CompiledBlock: [
		| extraWorldsToDraw |
		extraWorldsToDraw := Extr...etc...
		numArgs: 	0
		receiver: 	WorldMorph


WorldState class>>doDrawCycleWith:
	Receiver: WorldState
	Arguments and temporary variables: 
		aBlock: 	[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex cr...etc...
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#activeHand->WorldState>>#activeHand #activeHand...etc...
		format: 	65547
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldState}
		name: 	#WorldState
		classPool: 	a Dictionary(#CanSurrenderToOS->nil #DebugShowDamage->false #Deferre...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'


WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65547
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->nil #CursorOwnerWorld->a WorldMorph(60...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		announcer: 	nil
		displayScaleFactor: 	1


MorphicRenderLoop>>doOneCycle
	Receiver: a MorphicRenderLoop
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
a MorphicRenderLoop

MorphicRenderLoop>>doOneCycleWhile:
	Receiver: a MorphicRenderLoop
	Arguments and temporary variables: 
		aBlock: 	[ true ]
	Receiver's instance variables: 
a MorphicRenderLoop

[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		activeTranscript: 	nil



--- The full stack ---
IceTipLocalRepositoryPanel(Object)>>assert:description:
IceTipLocalRepositoryPanel>>validate
IceTipRegisterRepositoryDialog>>doAccept
[ self doAccept ] in IceTipRegisterRepositoryDialog(IceTipOptionDialog)>>initializeDialogWindow:
FullBlockClosure(BlockClosure)>>cull:
SpDialogWindowPresenter>>triggerOkAction
[ :presenter | 
			presenter triggerOkAction.
			presenter close ] in SpAbstractPresenter>>initializeDialogWindow:
FullBlockClosure(BlockClosure)>>cull:
[ aBlock cull: self ] in SpDialogWindowPresenter>>addButton:do:
SpButtonPresenter>>performAction
SpMorphicButtonAdapter>>action
PluggableButtonMorph>>performAction:
[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in PluggableButtonMorph>>mouseUp:
Array(SequenceableCollection)>>do:
PluggableButtonMorph>>mouseUp:
PluggableButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableButtonMorph(Morph)>>handleEvent:
PluggableButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
[delaySemaphore wait] in Delay>>wait
3 October 2022 3:30:21.828452 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
StackToRegisterMappingCogit * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
v9.0.18 - Commit: 7249c170 - Date: 2022-09-02 14:31:12 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

[delaySemaphore wait] in Delay>>wait
	Receiver: a Delay(16 msecs)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		delaySemaphore: 	a Semaphore()
		beingWaitedOn: 	false
		millisecondDelayDuration: 	16
		ticker: 	a DelayMicrosecondTicker
		resumptionTick: 	3842256621801451


FullBlockClosure(BlockClosure)>>ifCurtailed:
	Receiver: [delaySemaphore wait]
	Arguments and temporary variables: 
		aBlock: 	[self unschedule]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	Delay>>wait
		startpc: 	a CompiledBlock: [delaySemaphore wait]
		numArgs: 	0
		receiver: 	a Delay(16 msecs)


Delay>>wait
	Receiver: a Delay(16 msecs)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		delaySemaphore: 	a Semaphore()
		beingWaitedOn: 	false
		millisecondDelayDuration: 	16
		ticker: 	a DelayMicrosecondTicker
		resumptionTick: 	3842256621801451


WorldState class>>doInterCycleWait
	Receiver: WorldState
	Arguments and temporary variables: 
		waitTime: 	16
		newCycleTime: 	2930746
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#activeHand->WorldState>>#activeHand #activeHand...etc...
		format: 	65547
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldState}
		name: 	#WorldState
		classPool: 	a Dictionary(#CanSurrenderToOS->nil #DebugShowDamage->false #Deferre...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'


[
		self doInterCycleWait
	] in WorldState class>>doDrawCycleWith:
	Receiver: WorldState
	Arguments and temporary variables: 
		aBlock: 	[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex cr...etc...
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#activeHand->WorldState>>#activeHand #activeHand...etc...
		format: 	65547
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldState}
		name: 	#WorldState
		classPool: 	a Dictionary(#CanSurrenderToOS->nil #DebugShowDamage->false #Deferre...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extr...etc...
	Arguments and temporary variables: 
		aBlock: 	[
		self doInterCycleWait
	]
		complete: 	true
		returnValue: 	a WorldMorph(603310592) [world]
	Receiver's instance variables: 
		outerContext: 	WorldMorph class>>doOneCycle
		startpc: 	a CompiledBlock: [
		| extraWorldsToDraw |
		extraWorldsToDraw := Extr...etc...
		numArgs: 	0
		receiver: 	WorldMorph


WorldState class>>doDrawCycleWith:
	Receiver: WorldState
	Arguments and temporary variables: 
		aBlock: 	[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex cr...etc...
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#activeHand->WorldState>>#activeHand #activeHand...etc...
		format: 	65547
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldState}
		name: 	#WorldState
		classPool: 	a Dictionary(#CanSurrenderToOS->nil #DebugShowDamage->false #Deferre...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'


WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65547
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->nil #CursorOwnerWorld->a WorldMorph(60...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		announcer: 	nil
		displayScaleFactor: 	1


MorphicRenderLoop>>doOneCycle
	Receiver: a MorphicRenderLoop
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
a MorphicRenderLoop

MorphicRenderLoop>>doOneCycleWhile:
	Receiver: a MorphicRenderLoop
	Arguments and temporary variables: 
		aBlock: 	[ true ]
	Receiver's instance variables: 
a MorphicRenderLoop

[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		activeTranscript: 	Transcript


[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
	Receiver: [
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	a CompiledBlock: [
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	...etc...
		numArgs: 	0
		receiver: 	a MorphicUIManager



--- The full stack ---
[delaySemaphore wait] in Delay>>wait
FullBlockClosure(BlockClosure)>>ifCurtailed:
Delay>>wait
WorldState class>>doInterCycleWait
[
		self doInterCycleWait
	] in WorldState class>>doDrawCycleWith:
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
I am an Oups NULL debugging exception
3 October 2022 3:30:21.844124 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
StackToRegisterMappingCogit * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
v9.0.18 - Commit: 7249c170 - Date: 2022-09-02 14:31:12 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

[delaySemaphore wait] in Delay>>wait
	Receiver: a Delay(16 msecs)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		delaySemaphore: 	a Semaphore()
		beingWaitedOn: 	false
		millisecondDelayDuration: 	16
		ticker: 	a DelayMicrosecondTicker
		resumptionTick: 	3842256621801451


FullBlockClosure(BlockClosure)>>ifCurtailed:
	Receiver: [delaySemaphore wait]
	Arguments and temporary variables: 
		aBlock: 	[self unschedule]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	Delay>>wait
		startpc: 	a CompiledBlock: [delaySemaphore wait]
		numArgs: 	0
		receiver: 	a Delay(16 msecs)


Delay>>wait
	Receiver: a Delay(16 msecs)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		delaySemaphore: 	a Semaphore()
		beingWaitedOn: 	false
		millisecondDelayDuration: 	16
		ticker: 	a DelayMicrosecondTicker
		resumptionTick: 	3842256621801451


WorldState class>>doInterCycleWait
	Receiver: WorldState
	Arguments and temporary variables: 
		waitTime: 	16
		newCycleTime: 	2930746
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#activeHand->WorldState>>#activeHand #activeHand...etc...
		format: 	65547
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldState}
		name: 	#WorldState
		classPool: 	a Dictionary(#CanSurrenderToOS->nil #DebugShowDamage->false #Deferre...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'


[
		self doInterCycleWait
	] in WorldState class>>doDrawCycleWith:
	Receiver: WorldState
	Arguments and temporary variables: 
		aBlock: 	[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex cr...etc...
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#activeHand->WorldState>>#activeHand #activeHand...etc...
		format: 	65547
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldState}
		name: 	#WorldState
		classPool: 	a Dictionary(#CanSurrenderToOS->nil #DebugShowDamage->false #Deferre...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extr...etc...
	Arguments and temporary variables: 
		aBlock: 	[
		self doInterCycleWait
	]
		complete: 	true
		returnValue: 	a WorldMorph(603310592) [world]
	Receiver's instance variables: 
		outerContext: 	WorldMorph class>>doOneCycle
		startpc: 	a CompiledBlock: [
		| extraWorldsToDraw |
		extraWorldsToDraw := Extr...etc...
		numArgs: 	0
		receiver: 	WorldMorph


WorldState class>>doDrawCycleWith:
	Receiver: WorldState
	Arguments and temporary variables: 
		aBlock: 	[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex cr...etc...
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#activeHand->WorldState>>#activeHand #activeHand...etc...
		format: 	65547
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldState}
		name: 	#WorldState
		classPool: 	a Dictionary(#CanSurrenderToOS->nil #DebugShowDamage->false #Deferre...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'


WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65547
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->nil #CursorOwnerWorld->a WorldMorph(60...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		announcer: 	nil
		displayScaleFactor: 	1


MorphicRenderLoop>>doOneCycle
	Receiver: a MorphicRenderLoop
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
a MorphicRenderLoop

MorphicRenderLoop>>doOneCycleWhile:
	Receiver: a MorphicRenderLoop
	Arguments and temporary variables: 
		aBlock: 	[ true ]
	Receiver's instance variables: 
a MorphicRenderLoop

[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		activeTranscript: 	Transcript


[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
	Receiver: [
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	a CompiledBlock: [
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	...etc...
		numArgs: 	0
		receiver: 	a MorphicUIManager



--- The full stack ---
[delaySemaphore wait] in Delay>>wait
FullBlockClosure(BlockClosure)>>ifCurtailed:
Delay>>wait
WorldState class>>doInterCycleWait
[
		self doInterCycleWait
	] in WorldState class>>doDrawCycleWith:
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
[delaySemaphore wait] in Delay>>wait
3 October 2022 3:30:26.471161 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
StackToRegisterMappingCogit * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
v9.0.18 - Commit: 7249c170 - Date: 2022-09-02 14:31:12 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

[delaySemaphore wait] in Delay>>wait
	Receiver: a Delay(16 msecs)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		delaySemaphore: 	a Semaphore()
		beingWaitedOn: 	false
		millisecondDelayDuration: 	16
		ticker: 	a DelayMicrosecondTicker
		resumptionTick: 	3842256626451260


FullBlockClosure(BlockClosure)>>ifCurtailed:
	Receiver: [delaySemaphore wait]
	Arguments and temporary variables: 
		aBlock: 	[self unschedule]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	Delay>>wait
		startpc: 	a CompiledBlock: [delaySemaphore wait]
		numArgs: 	0
		receiver: 	a Delay(16 msecs)


Delay>>wait
	Receiver: a Delay(16 msecs)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		delaySemaphore: 	a Semaphore()
		beingWaitedOn: 	false
		millisecondDelayDuration: 	16
		ticker: 	a DelayMicrosecondTicker
		resumptionTick: 	3842256626451260


WorldState class>>doInterCycleWait
	Receiver: WorldState
	Arguments and temporary variables: 
		waitTime: 	16
		newCycleTime: 	2935396
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#activeHand->WorldState>>#activeHand #activeHand...etc...
		format: 	65547
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldState}
		name: 	#WorldState
		classPool: 	a Dictionary(#CanSurrenderToOS->nil #DebugShowDamage->false #Deferre...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'


[
		self doInterCycleWait
	] in WorldState class>>doDrawCycleWith:
	Receiver: WorldState
	Arguments and temporary variables: 
		aBlock: 	[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex cr...etc...
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#activeHand->WorldState>>#activeHand #activeHand...etc...
		format: 	65547
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldState}
		name: 	#WorldState
		classPool: 	a Dictionary(#CanSurrenderToOS->nil #DebugShowDamage->false #Deferre...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extr...etc...
	Arguments and temporary variables: 
		aBlock: 	[
		self doInterCycleWait
	]
		complete: 	true
		returnValue: 	a WorldMorph(603310592) [world]
	Receiver's instance variables: 
		outerContext: 	WorldMorph class>>doOneCycle
		startpc: 	a CompiledBlock: [
		| extraWorldsToDraw |
		extraWorldsToDraw := Extr...etc...
		numArgs: 	0
		receiver: 	WorldMorph


WorldState class>>doDrawCycleWith:
	Receiver: WorldState
	Arguments and temporary variables: 
		aBlock: 	[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex cr...etc...
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#activeHand->WorldState>>#activeHand #activeHand...etc...
		format: 	65547
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldState}
		name: 	#WorldState
		classPool: 	a Dictionary(#CanSurrenderToOS->nil #DebugShowDamage->false #Deferre...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'


WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65547
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->nil #CursorOwnerWorld->a WorldMorph(60...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		announcer: 	nil
		displayScaleFactor: 	1


MorphicRenderLoop>>doOneCycle
	Receiver: a MorphicRenderLoop
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
a MorphicRenderLoop

MorphicRenderLoop>>doOneCycleWhile:
	Receiver: a MorphicRenderLoop
	Arguments and temporary variables: 
		aBlock: 	[ true ]
	Receiver's instance variables: 
a MorphicRenderLoop

[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		activeTranscript: 	nil


[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
	Receiver: [
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	a CompiledBlock: [
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	...etc...
		numArgs: 	0
		receiver: 	a MorphicUIManager



--- The full stack ---
[delaySemaphore wait] in Delay>>wait
FullBlockClosure(BlockClosure)>>ifCurtailed:
Delay>>wait
WorldState class>>doInterCycleWait
[
		self doInterCycleWait
	] in WorldState class>>doDrawCycleWith:
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
I am an Oups NULL debugging exception
3 October 2022 3:30:26.483322 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
StackToRegisterMappingCogit * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
v9.0.18 - Commit: 7249c170 - Date: 2022-09-02 14:31:12 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

[delaySemaphore wait] in Delay>>wait
	Receiver: a Delay(16 msecs)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		delaySemaphore: 	a Semaphore()
		beingWaitedOn: 	false
		millisecondDelayDuration: 	16
		ticker: 	a DelayMicrosecondTicker
		resumptionTick: 	3842256626451260


FullBlockClosure(BlockClosure)>>ifCurtailed:
	Receiver: [delaySemaphore wait]
	Arguments and temporary variables: 
		aBlock: 	[self unschedule]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	Delay>>wait
		startpc: 	a CompiledBlock: [delaySemaphore wait]
		numArgs: 	0
		receiver: 	a Delay(16 msecs)


Delay>>wait
	Receiver: a Delay(16 msecs)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		delaySemaphore: 	a Semaphore()
		beingWaitedOn: 	false
		millisecondDelayDuration: 	16
		ticker: 	a DelayMicrosecondTicker
		resumptionTick: 	3842256626451260


WorldState class>>doInterCycleWait
	Receiver: WorldState
	Arguments and temporary variables: 
		waitTime: 	16
		newCycleTime: 	2935396
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#activeHand->WorldState>>#activeHand #activeHand...etc...
		format: 	65547
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldState}
		name: 	#WorldState
		classPool: 	a Dictionary(#CanSurrenderToOS->nil #DebugShowDamage->false #Deferre...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'


[
		self doInterCycleWait
	] in WorldState class>>doDrawCycleWith:
	Receiver: WorldState
	Arguments and temporary variables: 
		aBlock: 	[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex cr...etc...
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#activeHand->WorldState>>#activeHand #activeHand...etc...
		format: 	65547
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldState}
		name: 	#WorldState
		classPool: 	a Dictionary(#CanSurrenderToOS->nil #DebugShowDamage->false #Deferre...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extr...etc...
	Arguments and temporary variables: 
		aBlock: 	[
		self doInterCycleWait
	]
		complete: 	true
		returnValue: 	a WorldMorph(603310592) [world]
	Receiver's instance variables: 
		outerContext: 	WorldMorph class>>doOneCycle
		startpc: 	a CompiledBlock: [
		| extraWorldsToDraw |
		extraWorldsToDraw := Extr...etc...
		numArgs: 	0
		receiver: 	WorldMorph


WorldState class>>doDrawCycleWith:
	Receiver: WorldState
	Arguments and temporary variables: 
		aBlock: 	[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex cr...etc...
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#activeHand->WorldState>>#activeHand #activeHand...etc...
		format: 	65547
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldState}
		name: 	#WorldState
		classPool: 	a Dictionary(#CanSurrenderToOS->nil #DebugShowDamage->false #Deferre...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'


WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65547
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->nil #CursorOwnerWorld->a WorldMorph(60...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		announcer: 	nil
		displayScaleFactor: 	1


MorphicRenderLoop>>doOneCycle
	Receiver: a MorphicRenderLoop
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
a MorphicRenderLoop

MorphicRenderLoop>>doOneCycleWhile:
	Receiver: a MorphicRenderLoop
	Arguments and temporary variables: 
		aBlock: 	[ true ]
	Receiver's instance variables: 
a MorphicRenderLoop

[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		activeTranscript: 	nil


[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
	Receiver: [
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	a CompiledBlock: [
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	...etc...
		numArgs: 	0
		receiver: 	a MorphicUIManager



--- The full stack ---
[delaySemaphore wait] in Delay>>wait
FullBlockClosure(BlockClosure)>>ifCurtailed:
Delay>>wait
WorldState class>>doInterCycleWait
[
		self doInterCycleWait
	] in WorldState class>>doDrawCycleWith:
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of BlockClosure class did not understand #repeatUntil:
3 October 2022 4:01:26.82221 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
StackToRegisterMappingCogit * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
v9.0.18 - Commit: 7249c170 - Date: 2022-09-02 14:31:12 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

BlockClosure class(Object)>>doesNotUnderstand: #repeatUntil:
	Receiver: BlockClosure
	Arguments and temporary variables: 
		aMessage: 	repeatUntil: 3
		exception: 	Instance of BlockClosure class did not understand #repeatUntil:
		resumeValue: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(size 154)
		format: 	196611
		layout: 	a VariableLayout
		organization: 	a ClassOrganization
		subclasses: 	{FullBlockClosure}
		name: 	#BlockClosure
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Methods'


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ BlockClosure repeatUntil: 3
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ BlockClosure repeatUntil: 3
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'BlockClosure repeatUntil: 3.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#c1->[ x := x + 1 ] #c2->[ x := x + 1 ] )
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (67 to: 94) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'c1 := Counter create.
c2 := Counter create.

c...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#c1->[ x := x + 1 ] #c2->[ x := x + 1 ] )
		aString: 	'BlockClosure repeatUntil: 3.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (67 to: 94) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'c1 := Counter create.
c2 := Counter create.

c...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aString: 	'BlockClosure repeatUntil: 3.'
		aBlock: 	[ :result | ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | ]
		selection: 	'BlockClosure repeatUntil: 3.'
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand>>execute
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodeDoItCommand
		iconProvider: 	nil
		iconName: 	#smallDoIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(791653120)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(791653120)
		secondArg: 	a RubEditingArea(791653120)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(791653120)
		secondArg: 	a RubEditingArea(791653120)
		thirdArg: 	[keyDown '<Cmd-d>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(791653120)
		category: 	a KMCategory
		morph: 	a RubEditingArea(791653120)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				i...etc...
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#MacOSX->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCm...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListen...etc...
		index: 	13
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				if...etc...
	Receiver's instance variables: 
		tally: 	31
		array: 	an Array(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecut...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#MacOSX->a KMStorage #all->a KMStorage )


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(791653120)
		category: 	a KMCategory
		morph: 	a RubEditingArea(791653120)


[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		aTarget: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(a KMCategoryBinding(#RubTextEditor) a KMCategoryBinding(#MorphFo...etc...
		morph: 	a RubEditingArea(791653120)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(a KMCategoryBinding(nil) a KMCategoryBinding(#RubTextEditor) a KMCate...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
		...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a KMCategoryBinding(nil) a KMCategoryBinding(#RubTextEditor) a ...etc...
		firstIndex: 	1
		lastIndex: 	4



--- The full stack ---
BlockClosure class(Object)>>doesNotUnderstand: #repeatUntil:
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of BlockClosure class did not understand #repeatUntil:
3 October 2022 4:01:26.857497 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
StackToRegisterMappingCogit * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
v9.0.18 - Commit: 7249c170 - Date: 2022-09-02 14:31:12 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

BlockClosure class(Object)>>doesNotUnderstand: #repeatUntil:
	Receiver: BlockClosure
	Arguments and temporary variables: 
		aMessage: 	repeatUntil: 3
		exception: 	Instance of BlockClosure class did not understand #repeatUntil:
		resumeValue: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(size 154)
		format: 	196611
		layout: 	a VariableLayout
		organization: 	a ClassOrganization
		subclasses: 	{FullBlockClosure}
		name: 	#BlockClosure
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Methods'


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ BlockClosure repeatUntil: 3
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ BlockClosure repeatUntil: 3
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'BlockClosure repeatUntil: 3.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#c1->[ x := x + 1 ] #c2->[ x := x + 1 ] )
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (67 to: 94) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'c1 := Counter create.
c2 := Counter create.

c...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#c1->[ x := x + 1 ] #c2->[ x := x + 1 ] )
		aString: 	'BlockClosure repeatUntil: 3.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (67 to: 94) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'c1 := Counter create.
c2 := Counter create.

c...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aString: 	'BlockClosure repeatUntil: 3.'
		aBlock: 	[ :result | ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | ]
		selection: 	'BlockClosure repeatUntil: 3.'
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand>>execute
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodeDoItCommand
		iconProvider: 	nil
		iconName: 	#smallDoIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(791653120)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(791653120)
		secondArg: 	a RubEditingArea(791653120)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(791653120)
		secondArg: 	a RubEditingArea(791653120)
		thirdArg: 	[keyDown '<Cmd-d>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(791653120)
		category: 	a KMCategory
		morph: 	a RubEditingArea(791653120)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				i...etc...
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#MacOSX->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCm...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListen...etc...
		index: 	13
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				if...etc...
	Receiver's instance variables: 
		tally: 	31
		array: 	an Array(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecut...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#MacOSX->a KMStorage #all->a KMStorage )


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(791653120)
		category: 	a KMCategory
		morph: 	a RubEditingArea(791653120)


[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		aTarget: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(a KMCategoryBinding(#RubTextEditor) a KMCategoryBinding(#MorphFo...etc...
		morph: 	a RubEditingArea(791653120)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(a KMCategoryBinding(nil) a KMCategoryBinding(#RubTextEditor) a KMCate...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
		...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a KMCategoryBinding(nil) a KMCategoryBinding(#RubTextEditor) a ...etc...
		firstIndex: 	1
		lastIndex: 	4



--- The full stack ---
BlockClosure class(Object)>>doesNotUnderstand: #repeatUntil:
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of BlockClosure class did not understand #repeatUntil:
3 October 2022 4:01:56.189316 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
StackToRegisterMappingCogit * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
v9.0.18 - Commit: 7249c170 - Date: 2022-09-02 14:31:12 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

BlockClosure class(Object)>>doesNotUnderstand: #repeatUntil:
	Receiver: BlockClosure
	Arguments and temporary variables: 
		aMessage: 	repeatUntil: 3
		exception: 	Instance of BlockClosure class did not understand #repeatUntil:
		resumeValue: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(size 154)
		format: 	196611
		layout: 	a VariableLayout
		organization: 	a ClassOrganization
		subclasses: 	{FullBlockClosure}
		name: 	#BlockClosure
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Methods'


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ BlockClosure repeatUntil: 3
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ BlockClosure repeatUntil: 3
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'BlockClosure repeatUntil: 3.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#bc->BlockClosure #c1->[ x := x + 1 ] #c2->[ x := x +...etc...
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (98 to: 125) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'c1 := Counter create.
c2 := Counter create.

c...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#bc->BlockClosure #c1->[ x := x + 1 ] #c2->[ x := x +...etc...
		aString: 	'BlockClosure repeatUntil: 3.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (98 to: 125) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'c1 := Counter create.
c2 := Counter create.

c...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aString: 	'BlockClosure repeatUntil: 3.'
		aBlock: 	[ :result | ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | ]
		selection: 	'BlockClosure repeatUntil: 3.'
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand>>execute
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodeDoItCommand
		iconProvider: 	nil
		iconName: 	#smallDoIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(791653120)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(791653120)
		secondArg: 	a RubEditingArea(791653120)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(791653120)
		secondArg: 	a RubEditingArea(791653120)
		thirdArg: 	[keyDown '<Cmd-d>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(791653120)
		category: 	a KMCategory
		morph: 	a RubEditingArea(791653120)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				i...etc...
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#MacOSX->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCm...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListen...etc...
		index: 	13
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				if...etc...
	Receiver's instance variables: 
		tally: 	31
		array: 	an Array(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecut...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#MacOSX->a KMStorage #all->a KMStorage )


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(791653120)
		category: 	a KMCategory
		morph: 	a RubEditingArea(791653120)


[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		aTarget: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(a KMCategoryBinding(#RubTextEditor) a KMCategoryBinding(#MorphFo...etc...
		morph: 	a RubEditingArea(791653120)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(a KMCategoryBinding(nil) a KMCategoryBinding(#RubTextEditor) a KMCate...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
		...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a KMCategoryBinding(nil) a KMCategoryBinding(#RubTextEditor) a ...etc...
		firstIndex: 	1
		lastIndex: 	4



--- The full stack ---
BlockClosure class(Object)>>doesNotUnderstand: #repeatUntil:
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of BlockClosure class did not understand #repeatUntil:
3 October 2022 4:01:56.210121 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
StackToRegisterMappingCogit * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
v9.0.18 - Commit: 7249c170 - Date: 2022-09-02 14:31:12 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

BlockClosure class(Object)>>doesNotUnderstand: #repeatUntil:
	Receiver: BlockClosure
	Arguments and temporary variables: 
		aMessage: 	repeatUntil: 3
		exception: 	Instance of BlockClosure class did not understand #repeatUntil:
		resumeValue: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(size 154)
		format: 	196611
		layout: 	a VariableLayout
		organization: 	a ClassOrganization
		subclasses: 	{FullBlockClosure}
		name: 	#BlockClosure
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Methods'


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ BlockClosure repeatUntil: 3
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ BlockClosure repeatUntil: 3
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'BlockClosure repeatUntil: 3.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#bc->BlockClosure #c1->[ x := x + 1 ] #c2->[ x := x +...etc...
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (98 to: 125) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'c1 := Counter create.
c2 := Counter create.

c...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#bc->BlockClosure #c1->[ x := x + 1 ] #c2->[ x := x +...etc...
		aString: 	'BlockClosure repeatUntil: 3.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (98 to: 125) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'c1 := Counter create.
c2 := Counter create.

c...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aString: 	'BlockClosure repeatUntil: 3.'
		aBlock: 	[ :result | ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | ]
		selection: 	'BlockClosure repeatUntil: 3.'
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand>>execute
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodeDoItCommand
		iconProvider: 	nil
		iconName: 	#smallDoIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(791653120)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(791653120)
		secondArg: 	a RubEditingArea(791653120)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(791653120)
		secondArg: 	a RubEditingArea(791653120)
		thirdArg: 	[keyDown '<Cmd-d>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(791653120)
		category: 	a KMCategory
		morph: 	a RubEditingArea(791653120)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				i...etc...
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#MacOSX->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCm...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListen...etc...
		index: 	13
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				if...etc...
	Receiver's instance variables: 
		tally: 	31
		array: 	an Array(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecut...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#MacOSX->a KMStorage #all->a KMStorage )


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(791653120)
		category: 	a KMCategory
		morph: 	a RubEditingArea(791653120)


[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		aTarget: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(a KMCategoryBinding(#RubTextEditor) a KMCategoryBinding(#MorphFo...etc...
		morph: 	a RubEditingArea(791653120)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(a KMCategoryBinding(nil) a KMCategoryBinding(#RubTextEditor) a KMCate...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
		...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a KMCategoryBinding(nil) a KMCategoryBinding(#RubTextEditor) a ...etc...
		firstIndex: 	1
		lastIndex: 	4



--- The full stack ---
BlockClosure class(Object)>>doesNotUnderstand: #repeatUntil:
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of SmallInteger did not understand #ifTrue:ifFalse:
3 October 2022 4:03:17.431161 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
StackToRegisterMappingCogit * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
v9.0.18 - Commit: 7249c170 - Date: 2022-09-02 14:31:12 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

SmallInteger(Object)>>doesNotUnderstand: #ifTrue:ifFalse:
	Receiver: 5
	Arguments and temporary variables: 
		aMessage: 	ifTrue: DoItIn: arg1

	^ (arg1 readVariableNamed: 'condition') value
...etc...
		exception: 	Instance of SmallInteger did not understand #ifTrue:ifFalse:
		resumeValue: 	nil
	Receiver's instance variables: 
5

FullBlockClosure(BlockClosure)>>DoItIn:
	Receiver: [ p := p + 1 ]
	Arguments and temporary variables: 
		arg1: 	FullBlockClosure(BlockClosure)>>repeatUntil:
	Receiver's instance variables: 
		outerContext: 	UndefinedObject>>DoIt
		startpc: 	a CompiledBlock: [ p := p + 1 ]
		numArgs: 	0
		receiver: 	nil


SmallInteger(ProtoObject)>>mustBeBooleanDeOptimizeIn:
	Receiver: 5
	Arguments and temporary variables: 
		context: 	FullBlockClosure(BlockClosure)>>repeatUntil:
		ret: 	nil
		cache: 	an IdentityDictionary(BlockClosure>>#repeatUntil:->an IdentityDictionary...etc...
		method: 	BlockClosure>>#DoItIn:
	Receiver's instance variables: 
5

SmallInteger(ProtoObject)>>mustBeBoolean
	Receiver: 5
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
5

FullBlockClosure(BlockClosure)>>repeatUntil:
	Receiver: [ p := p + 1 ]
	Arguments and temporary variables: 
		condition: 	5
	Receiver's instance variables: 
		outerContext: 	UndefinedObject>>DoIt
		startpc: 	a CompiledBlock: [ p := p + 1 ]
		numArgs: 	0
		receiver: 	nil


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ [ p := p + 1 ] repeatUntil: 5
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ [ p := p + 1 ] repeatUntil: 5
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'[ p := p + 1 ] repeatUntil: 5.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#bc->BlockClosure #c1->[ x := x + 1 ] #c2->[ x := x +...etc...
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (75 to: 104) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'c1 := Counter create.
c2 := Counter create.

c...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#bc->BlockClosure #c1->[ x := x + 1 ] #c2->[ x := x +...etc...
		aString: 	'[ p := p + 1 ] repeatUntil: 5.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (75 to: 104) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'c1 := Counter create.
c2 := Counter create.

c...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aString: 	'[ p := p + 1 ] repeatUntil: 5.'
		aBlock: 	[ :result | ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | ]
		selection: 	'[ p := p + 1 ] repeatUntil: 5.'
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand>>execute
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodeDoItCommand
		iconProvider: 	nil
		iconName: 	#smallDoIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(791653120)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(791653120)
		secondArg: 	a RubEditingArea(791653120)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(791653120)
		secondArg: 	a RubEditingArea(791653120)
		thirdArg: 	[keyDown '<Cmd-d>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(791653120)
		category: 	a KMCategory
		morph: 	a RubEditingArea(791653120)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				i...etc...
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#MacOSX->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCm...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListen...etc...
		index: 	13
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				if...etc...
	Receiver's instance variables: 
		tally: 	31
		array: 	an Array(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecut...etc...



--- The full stack ---
SmallInteger(Object)>>doesNotUnderstand: #ifTrue:ifFalse:
FullBlockClosure(BlockClosure)>>DoItIn:
SmallInteger(ProtoObject)>>mustBeBooleanDeOptimizeIn:
SmallInteger(ProtoObject)>>mustBeBoolean
FullBlockClosure(BlockClosure)>>repeatUntil:
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of SmallInteger did not understand #ifTrue:ifFalse:
3 October 2022 4:03:17.455164 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
StackToRegisterMappingCogit * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
v9.0.18 - Commit: 7249c170 - Date: 2022-09-02 14:31:12 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

SmallInteger(Object)>>doesNotUnderstand: #ifTrue:ifFalse:
	Receiver: 5
	Arguments and temporary variables: 
		aMessage: 	ifTrue: DoItIn: arg1

	^ (arg1 readVariableNamed: 'condition') value
...etc...
		exception: 	Instance of SmallInteger did not understand #ifTrue:ifFalse:
		resumeValue: 	nil
	Receiver's instance variables: 
5

FullBlockClosure(BlockClosure)>>DoItIn:
	Receiver: [ p := p + 1 ]
	Arguments and temporary variables: 
		arg1: 	FullBlockClosure(BlockClosure)>>repeatUntil:
	Receiver's instance variables: 
		outerContext: 	UndefinedObject>>DoIt
		startpc: 	a CompiledBlock: [ p := p + 1 ]
		numArgs: 	0
		receiver: 	nil


SmallInteger(ProtoObject)>>mustBeBooleanDeOptimizeIn:
	Receiver: 5
	Arguments and temporary variables: 
		context: 	FullBlockClosure(BlockClosure)>>repeatUntil:
		ret: 	nil
		cache: 	an IdentityDictionary(BlockClosure>>#repeatUntil:->an IdentityDictionary...etc...
		method: 	BlockClosure>>#DoItIn:
	Receiver's instance variables: 
5

SmallInteger(ProtoObject)>>mustBeBoolean
	Receiver: 5
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
5

FullBlockClosure(BlockClosure)>>repeatUntil:
	Receiver: [ p := p + 1 ]
	Arguments and temporary variables: 
		condition: 	5
	Receiver's instance variables: 
		outerContext: 	UndefinedObject>>DoIt
		startpc: 	a CompiledBlock: [ p := p + 1 ]
		numArgs: 	0
		receiver: 	nil


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ [ p := p + 1 ] repeatUntil: 5
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ [ p := p + 1 ] repeatUntil: 5
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'[ p := p + 1 ] repeatUntil: 5.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#bc->BlockClosure #c1->[ x := x + 1 ] #c2->[ x := x +...etc...
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (75 to: 104) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'c1 := Counter create.
c2 := Counter create.

c...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#bc->BlockClosure #c1->[ x := x + 1 ] #c2->[ x := x +...etc...
		aString: 	'[ p := p + 1 ] repeatUntil: 5.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (75 to: 104) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'c1 := Counter create.
c2 := Counter create.

c...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aString: 	'[ p := p + 1 ] repeatUntil: 5.'
		aBlock: 	[ :result | ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | ]
		selection: 	'[ p := p + 1 ] repeatUntil: 5.'
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand>>execute
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodeDoItCommand
		iconProvider: 	nil
		iconName: 	#smallDoIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(791653120)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(791653120)
		secondArg: 	a RubEditingArea(791653120)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(791653120)
		secondArg: 	a RubEditingArea(791653120)
		thirdArg: 	[keyDown '<Cmd-d>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(791653120)
		category: 	a KMCategory
		morph: 	a RubEditingArea(791653120)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				i...etc...
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#MacOSX->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCm...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListen...etc...
		index: 	13
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				if...etc...
	Receiver's instance variables: 
		tally: 	31
		array: 	an Array(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecut...etc...



--- The full stack ---
SmallInteger(Object)>>doesNotUnderstand: #ifTrue:ifFalse:
FullBlockClosure(BlockClosure)>>DoItIn:
SmallInteger(ProtoObject)>>mustBeBooleanDeOptimizeIn:
SmallInteger(ProtoObject)>>mustBeBoolean
FullBlockClosure(BlockClosure)>>repeatUntil:
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of SmallInteger did not understand #ifTrue:ifFalse:
3 October 2022 4:03:43.221433 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
StackToRegisterMappingCogit * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
v9.0.18 - Commit: 7249c170 - Date: 2022-09-02 14:31:12 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

SmallInteger(Object)>>doesNotUnderstand: #ifTrue:ifFalse:
	Receiver: 5
	Arguments and temporary variables: 
		aMessage: 	ifTrue: DoItIn: arg1

	^ (arg1 readVariableNamed: 'condition') value
...etc...
		exception: 	Instance of SmallInteger did not understand #ifTrue:ifFalse:
		resumeValue: 	nil
	Receiver's instance variables: 
5

FullBlockClosure(BlockClosure)>>DoItIn:
	Receiver: [ p := p + 1 ]
	Arguments and temporary variables: 
		arg1: 	FullBlockClosure(BlockClosure)>>repeatUntil:
	Receiver's instance variables: 
		outerContext: 	UndefinedObject>>DoIt
		startpc: 	a CompiledBlock: [ p := p + 1 ]
		numArgs: 	0
		receiver: 	nil


SmallInteger(ProtoObject)>>mustBeBooleanDeOptimizeIn:
	Receiver: 5
	Arguments and temporary variables: 
		context: 	FullBlockClosure(BlockClosure)>>repeatUntil:
		ret: 	nil
		cache: 	an IdentityDictionary(BlockClosure>>#repeatUntil:->an IdentityDictionary...etc...
		method: 	BlockClosure>>#DoItIn:
	Receiver's instance variables: 
5

SmallInteger(ProtoObject)>>mustBeBoolean
	Receiver: 5
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
5

FullBlockClosure(BlockClosure)>>repeatUntil:
	Receiver: [ p := p + 1 ]
	Arguments and temporary variables: 
		condition: 	[ p := 5 ]
	Receiver's instance variables: 
		outerContext: 	UndefinedObject>>DoIt
		startpc: 	a CompiledBlock: [ p := p + 1 ]
		numArgs: 	0
		receiver: 	nil


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ [ p := p + 1 ] repeatUntil: [ p := 5 ]
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ [ p := p + 1 ] repeatUntil: [ p := 5 ]
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'[ p := p + 1 ] repeatUntil: [p := 5 ].'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#bc->BlockClosure #c1->[ x := x + 1 ] #c2->[ x := x +...etc...
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (75 to: 112) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'c1 := Counter create.
c2 := Counter create.

c...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#bc->BlockClosure #c1->[ x := x + 1 ] #c2->[ x := x +...etc...
		aString: 	'[ p := p + 1 ] repeatUntil: [p := 5 ].'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (75 to: 112) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'c1 := Counter create.
c2 := Counter create.

c...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aString: 	'[ p := p + 1 ] repeatUntil: [p := 5 ].'
		aBlock: 	[ :result | ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | ]
		selection: 	'[ p := p + 1 ] repeatUntil: [p := 5 ].'
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand>>execute
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodeDoItCommand
		iconProvider: 	nil
		iconName: 	#smallDoIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(791653120)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(791653120)
		secondArg: 	a RubEditingArea(791653120)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(791653120)
		secondArg: 	a RubEditingArea(791653120)
		thirdArg: 	[keyDown '<Cmd-d>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(791653120)
		category: 	a KMCategory
		morph: 	a RubEditingArea(791653120)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				i...etc...
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#MacOSX->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCm...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListen...etc...
		index: 	13
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				if...etc...
	Receiver's instance variables: 
		tally: 	31
		array: 	an Array(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecut...etc...



--- The full stack ---
SmallInteger(Object)>>doesNotUnderstand: #ifTrue:ifFalse:
FullBlockClosure(BlockClosure)>>DoItIn:
SmallInteger(ProtoObject)>>mustBeBooleanDeOptimizeIn:
SmallInteger(ProtoObject)>>mustBeBoolean
FullBlockClosure(BlockClosure)>>repeatUntil:
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of SmallInteger did not understand #ifTrue:ifFalse:
3 October 2022 4:03:43.24395 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
StackToRegisterMappingCogit * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
v9.0.18 - Commit: 7249c170 - Date: 2022-09-02 14:31:12 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

SmallInteger(Object)>>doesNotUnderstand: #ifTrue:ifFalse:
	Receiver: 5
	Arguments and temporary variables: 
		aMessage: 	ifTrue: DoItIn: arg1

	^ (arg1 readVariableNamed: 'condition') value
...etc...
		exception: 	Instance of SmallInteger did not understand #ifTrue:ifFalse:
		resumeValue: 	nil
	Receiver's instance variables: 
5

FullBlockClosure(BlockClosure)>>DoItIn:
	Receiver: [ p := p + 1 ]
	Arguments and temporary variables: 
		arg1: 	FullBlockClosure(BlockClosure)>>repeatUntil:
	Receiver's instance variables: 
		outerContext: 	UndefinedObject>>DoIt
		startpc: 	a CompiledBlock: [ p := p + 1 ]
		numArgs: 	0
		receiver: 	nil


SmallInteger(ProtoObject)>>mustBeBooleanDeOptimizeIn:
	Receiver: 5
	Arguments and temporary variables: 
		context: 	FullBlockClosure(BlockClosure)>>repeatUntil:
		ret: 	nil
		cache: 	an IdentityDictionary(BlockClosure>>#repeatUntil:->an IdentityDictionary...etc...
		method: 	BlockClosure>>#DoItIn:
	Receiver's instance variables: 
5

SmallInteger(ProtoObject)>>mustBeBoolean
	Receiver: 5
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
5

FullBlockClosure(BlockClosure)>>repeatUntil:
	Receiver: [ p := p + 1 ]
	Arguments and temporary variables: 
		condition: 	[ p := 5 ]
	Receiver's instance variables: 
		outerContext: 	UndefinedObject>>DoIt
		startpc: 	a CompiledBlock: [ p := p + 1 ]
		numArgs: 	0
		receiver: 	nil


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ [ p := p + 1 ] repeatUntil: [ p := 5 ]
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ [ p := p + 1 ] repeatUntil: [ p := 5 ]
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'[ p := p + 1 ] repeatUntil: [p := 5 ].'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#bc->BlockClosure #c1->[ x := x + 1 ] #c2->[ x := x +...etc...
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (75 to: 112) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'c1 := Counter create.
c2 := Counter create.

c...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#bc->BlockClosure #c1->[ x := x + 1 ] #c2->[ x := x +...etc...
		aString: 	'[ p := p + 1 ] repeatUntil: [p := 5 ].'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (75 to: 112) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'c1 := Counter create.
c2 := Counter create.

c...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aString: 	'[ p := p + 1 ] repeatUntil: [p := 5 ].'
		aBlock: 	[ :result | ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | ]
		selection: 	'[ p := p + 1 ] repeatUntil: [p := 5 ].'
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand>>execute
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodeDoItCommand
		iconProvider: 	nil
		iconName: 	#smallDoIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(791653120)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(791653120)
		secondArg: 	a RubEditingArea(791653120)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(791653120)
		secondArg: 	a RubEditingArea(791653120)
		thirdArg: 	[keyDown '<Cmd-d>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(791653120)
		category: 	a KMCategory
		morph: 	a RubEditingArea(791653120)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				i...etc...
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#MacOSX->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCm...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListen...etc...
		index: 	13
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				if...etc...
	Receiver's instance variables: 
		tally: 	31
		array: 	an Array(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecut...etc...



--- The full stack ---
SmallInteger(Object)>>doesNotUnderstand: #ifTrue:ifFalse:
FullBlockClosure(BlockClosure)>>DoItIn:
SmallInteger(ProtoObject)>>mustBeBooleanDeOptimizeIn:
SmallInteger(ProtoObject)>>mustBeBoolean
FullBlockClosure(BlockClosure)>>repeatUntil:
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of SmallInteger did not understand #ifTrue:ifFalse:
3 October 2022 4:04:34.418034 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
StackToRegisterMappingCogit * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
v9.0.18 - Commit: 7249c170 - Date: 2022-09-02 14:31:12 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

SmallInteger(Object)>>doesNotUnderstand: #ifTrue:ifFalse:
	Receiver: 5
	Arguments and temporary variables: 
		aMessage: 	ifTrue: DoItIn: arg1

	^ (arg1 readVariableNamed: 'condition') value
...etc...
		exception: 	Instance of SmallInteger did not understand #ifTrue:ifFalse:
		resumeValue: 	nil
	Receiver's instance variables: 
5

FullBlockClosure(BlockClosure)>>DoItIn:
	Receiver: [ p := p + 1 ]
	Arguments and temporary variables: 
		arg1: 	FullBlockClosure(BlockClosure)>>repeatUntil:
	Receiver's instance variables: 
		outerContext: 	UndefinedObject>>DoIt
		startpc: 	a CompiledBlock: [ p := p + 1 ]
		numArgs: 	0
		receiver: 	nil


SmallInteger(ProtoObject)>>mustBeBooleanDeOptimizeIn:
	Receiver: 5
	Arguments and temporary variables: 
		context: 	FullBlockClosure(BlockClosure)>>repeatUntil:
		ret: 	nil
		cache: 	an IdentityDictionary(BlockClosure>>#repeatUntil:->an IdentityDictionary...etc...
		method: 	BlockClosure>>#DoItIn:
	Receiver's instance variables: 
5

SmallInteger(ProtoObject)>>mustBeBoolean
	Receiver: 5
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
5

FullBlockClosure(BlockClosure)>>repeatUntil:
	Receiver: [ p := p + 1 ]
	Arguments and temporary variables: 
		condition: 	[ p := 5 ]
	Receiver's instance variables: 
		outerContext: 	UndefinedObject>>DoIt
		startpc: 	a CompiledBlock: [ p := p + 1 ]
		numArgs: 	0
		receiver: 	nil


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ [ p := p + 1 ] repeatUntil: [ p := 5 ]
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ [ p := p + 1 ] repeatUntil: [ p := 5 ]
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'[ p := p + 1 ] repeatUntil: [p := 5 ].'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#bc->BlockClosure #c1->[ x := x + 1 ] #c2->[ x := x +...etc...
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (75 to: 112) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'c1 := Counter create.
c2 := Counter create.

c...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#bc->BlockClosure #c1->[ x := x + 1 ] #c2->[ x := x +...etc...
		aString: 	'[ p := p + 1 ] repeatUntil: [p := 5 ].'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (75 to: 112) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'c1 := Counter create.
c2 := Counter create.

c...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aString: 	'[ p := p + 1 ] repeatUntil: [p := 5 ].'
		aBlock: 	[ :result | ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | ]
		selection: 	'[ p := p + 1 ] repeatUntil: [p := 5 ].'
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand>>execute
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodeDoItCommand
		iconProvider: 	nil
		iconName: 	#smallDoIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(791653120)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(791653120)
		secondArg: 	a RubEditingArea(791653120)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(791653120)
		secondArg: 	a RubEditingArea(791653120)
		thirdArg: 	[keyDown '<Cmd-d>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(791653120)
		category: 	a KMCategory
		morph: 	a RubEditingArea(791653120)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				i...etc...
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#MacOSX->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCm...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListen...etc...
		index: 	13
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				if...etc...
	Receiver's instance variables: 
		tally: 	31
		array: 	an Array(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecut...etc...



--- The full stack ---
SmallInteger(Object)>>doesNotUnderstand: #ifTrue:ifFalse:
FullBlockClosure(BlockClosure)>>DoItIn:
SmallInteger(ProtoObject)>>mustBeBooleanDeOptimizeIn:
SmallInteger(ProtoObject)>>mustBeBoolean
FullBlockClosure(BlockClosure)>>repeatUntil:
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of SmallInteger did not understand #ifTrue:ifFalse:
3 October 2022 4:04:34.439728 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
StackToRegisterMappingCogit * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
v9.0.18 - Commit: 7249c170 - Date: 2022-09-02 14:31:12 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

SmallInteger(Object)>>doesNotUnderstand: #ifTrue:ifFalse:
	Receiver: 5
	Arguments and temporary variables: 
		aMessage: 	ifTrue: DoItIn: arg1

	^ (arg1 readVariableNamed: 'condition') value
...etc...
		exception: 	Instance of SmallInteger did not understand #ifTrue:ifFalse:
		resumeValue: 	nil
	Receiver's instance variables: 
5

FullBlockClosure(BlockClosure)>>DoItIn:
	Receiver: [ p := p + 1 ]
	Arguments and temporary variables: 
		arg1: 	FullBlockClosure(BlockClosure)>>repeatUntil:
	Receiver's instance variables: 
		outerContext: 	UndefinedObject>>DoIt
		startpc: 	a CompiledBlock: [ p := p + 1 ]
		numArgs: 	0
		receiver: 	nil


SmallInteger(ProtoObject)>>mustBeBooleanDeOptimizeIn:
	Receiver: 5
	Arguments and temporary variables: 
		context: 	FullBlockClosure(BlockClosure)>>repeatUntil:
		ret: 	nil
		cache: 	an IdentityDictionary(BlockClosure>>#repeatUntil:->an IdentityDictionary...etc...
		method: 	BlockClosure>>#DoItIn:
	Receiver's instance variables: 
5

SmallInteger(ProtoObject)>>mustBeBoolean
	Receiver: 5
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
5

FullBlockClosure(BlockClosure)>>repeatUntil:
	Receiver: [ p := p + 1 ]
	Arguments and temporary variables: 
		condition: 	[ p := 5 ]
	Receiver's instance variables: 
		outerContext: 	UndefinedObject>>DoIt
		startpc: 	a CompiledBlock: [ p := p + 1 ]
		numArgs: 	0
		receiver: 	nil


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ [ p := p + 1 ] repeatUntil: [ p := 5 ]
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ [ p := p + 1 ] repeatUntil: [ p := 5 ]
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'[ p := p + 1 ] repeatUntil: [p := 5 ].'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#bc->BlockClosure #c1->[ x := x + 1 ] #c2->[ x := x +...etc...
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (75 to: 112) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'c1 := Counter create.
c2 := Counter create.

c...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#bc->BlockClosure #c1->[ x := x + 1 ] #c2->[ x := x +...etc...
		aString: 	'[ p := p + 1 ] repeatUntil: [p := 5 ].'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (75 to: 112) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'c1 := Counter create.
c2 := Counter create.

c...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aString: 	'[ p := p + 1 ] repeatUntil: [p := 5 ].'
		aBlock: 	[ :result | ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | ]
		selection: 	'[ p := p + 1 ] repeatUntil: [p := 5 ].'
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand>>execute
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodeDoItCommand
		iconProvider: 	nil
		iconName: 	#smallDoIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(791653120)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(791653120)
		secondArg: 	a RubEditingArea(791653120)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(791653120)
		secondArg: 	a RubEditingArea(791653120)
		thirdArg: 	[keyDown '<Cmd-d>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(791653120)
		category: 	a KMCategory
		morph: 	a RubEditingArea(791653120)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				i...etc...
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#MacOSX->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCm...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListen...etc...
		index: 	13
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				if...etc...
	Receiver's instance variables: 
		tally: 	31
		array: 	an Array(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecut...etc...



--- The full stack ---
SmallInteger(Object)>>doesNotUnderstand: #ifTrue:ifFalse:
FullBlockClosure(BlockClosure)>>DoItIn:
SmallInteger(ProtoObject)>>mustBeBooleanDeOptimizeIn:
SmallInteger(ProtoObject)>>mustBeBoolean
FullBlockClosure(BlockClosure)>>repeatUntil:
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of SmallInteger did not understand #ifTrue:ifFalse:
3 October 2022 4:05:08.879097 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
StackToRegisterMappingCogit * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
v9.0.18 - Commit: 7249c170 - Date: 2022-09-02 14:31:12 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

SmallInteger(Object)>>doesNotUnderstand: #ifTrue:ifFalse:
	Receiver: 5
	Arguments and temporary variables: 
		aMessage: 	ifTrue: DoItIn: arg1

	^ (arg1 readVariableNamed: 'condition') value
...etc...
		exception: 	Instance of SmallInteger did not understand #ifTrue:ifFalse:
		resumeValue: 	nil
	Receiver's instance variables: 
5

FullBlockClosure(BlockClosure)>>DoItIn:
	Receiver: [ p := p + 1 ]
	Arguments and temporary variables: 
		arg1: 	FullBlockClosure(BlockClosure)>>repeatUntil:
	Receiver's instance variables: 
		outerContext: 	UndefinedObject>>DoIt
		startpc: 	a CompiledBlock: [ p := p + 1 ]
		numArgs: 	0
		receiver: 	nil


SmallInteger(ProtoObject)>>mustBeBooleanDeOptimizeIn:
	Receiver: 5
	Arguments and temporary variables: 
		context: 	FullBlockClosure(BlockClosure)>>repeatUntil:
		ret: 	nil
		cache: 	an IdentityDictionary(BlockClosure>>#repeatUntil:->an IdentityDictionary...etc...
		method: 	BlockClosure>>#DoItIn:
	Receiver's instance variables: 
5

SmallInteger(ProtoObject)>>mustBeBoolean
	Receiver: 5
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
5

FullBlockClosure(BlockClosure)>>repeatUntil:
	Receiver: [ p := p + 1 ]
	Arguments and temporary variables: 
		condition: 	[ p := 5 ]
	Receiver's instance variables: 
		outerContext: 	UndefinedObject>>DoIt
		startpc: 	a CompiledBlock: [ p := p + 1 ]
		numArgs: 	0
		receiver: 	nil


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ [ p := p + 1 ] repeatUntil: [ p := 5 ]
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ [ p := p + 1 ] repeatUntil: [ p := 5 ]
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'[ p := p + 1 ] repeatUntil: [p := 5 ].'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#bc->BlockClosure #c1->[ x := x + 1 ] #c2->[ x := x +...etc...
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (75 to: 112) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'c1 := Counter create.
c2 := Counter create.

c...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#bc->BlockClosure #c1->[ x := x + 1 ] #c2->[ x := x +...etc...
		aString: 	'[ p := p + 1 ] repeatUntil: [p := 5 ].'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (75 to: 112) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'c1 := Counter create.
c2 := Counter create.

c...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aString: 	'[ p := p + 1 ] repeatUntil: [p := 5 ].'
		aBlock: 	[ :result | ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | ]
		selection: 	'[ p := p + 1 ] repeatUntil: [p := 5 ].'
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand>>execute
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodeDoItCommand
		iconProvider: 	nil
		iconName: 	#smallDoIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(791653120)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(791653120)
		secondArg: 	a RubEditingArea(791653120)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(791653120)
		secondArg: 	a RubEditingArea(791653120)
		thirdArg: 	[keyDown '<Cmd-d>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(791653120)
		category: 	a KMCategory
		morph: 	a RubEditingArea(791653120)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				i...etc...
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#MacOSX->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCm...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListen...etc...
		index: 	13
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				if...etc...
	Receiver's instance variables: 
		tally: 	31
		array: 	an Array(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecut...etc...



--- The full stack ---
SmallInteger(Object)>>doesNotUnderstand: #ifTrue:ifFalse:
FullBlockClosure(BlockClosure)>>DoItIn:
SmallInteger(ProtoObject)>>mustBeBooleanDeOptimizeIn:
SmallInteger(ProtoObject)>>mustBeBoolean
FullBlockClosure(BlockClosure)>>repeatUntil:
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of SmallInteger did not understand #ifTrue:ifFalse:
3 October 2022 4:05:08.901214 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
StackToRegisterMappingCogit * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
v9.0.18 - Commit: 7249c170 - Date: 2022-09-02 14:31:12 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

SmallInteger(Object)>>doesNotUnderstand: #ifTrue:ifFalse:
	Receiver: 5
	Arguments and temporary variables: 
		aMessage: 	ifTrue: DoItIn: arg1

	^ (arg1 readVariableNamed: 'condition') value
...etc...
		exception: 	Instance of SmallInteger did not understand #ifTrue:ifFalse:
		resumeValue: 	nil
	Receiver's instance variables: 
5

FullBlockClosure(BlockClosure)>>DoItIn:
	Receiver: [ p := p + 1 ]
	Arguments and temporary variables: 
		arg1: 	FullBlockClosure(BlockClosure)>>repeatUntil:
	Receiver's instance variables: 
		outerContext: 	UndefinedObject>>DoIt
		startpc: 	a CompiledBlock: [ p := p + 1 ]
		numArgs: 	0
		receiver: 	nil


SmallInteger(ProtoObject)>>mustBeBooleanDeOptimizeIn:
	Receiver: 5
	Arguments and temporary variables: 
		context: 	FullBlockClosure(BlockClosure)>>repeatUntil:
		ret: 	nil
		cache: 	an IdentityDictionary(BlockClosure>>#repeatUntil:->an IdentityDictionary...etc...
		method: 	BlockClosure>>#DoItIn:
	Receiver's instance variables: 
5

SmallInteger(ProtoObject)>>mustBeBoolean
	Receiver: 5
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
5

FullBlockClosure(BlockClosure)>>repeatUntil:
	Receiver: [ p := p + 1 ]
	Arguments and temporary variables: 
		condition: 	[ p := 5 ]
	Receiver's instance variables: 
		outerContext: 	UndefinedObject>>DoIt
		startpc: 	a CompiledBlock: [ p := p + 1 ]
		numArgs: 	0
		receiver: 	nil


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ [ p := p + 1 ] repeatUntil: [ p := 5 ]
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ [ p := p + 1 ] repeatUntil: [ p := 5 ]
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'[ p := p + 1 ] repeatUntil: [p := 5 ].'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#bc->BlockClosure #c1->[ x := x + 1 ] #c2->[ x := x +...etc...
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (75 to: 112) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'c1 := Counter create.
c2 := Counter create.

c...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#bc->BlockClosure #c1->[ x := x + 1 ] #c2->[ x := x +...etc...
		aString: 	'[ p := p + 1 ] repeatUntil: [p := 5 ].'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (75 to: 112) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'c1 := Counter create.
c2 := Counter create.

c...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aString: 	'[ p := p + 1 ] repeatUntil: [p := 5 ].'
		aBlock: 	[ :result | ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | ]
		selection: 	'[ p := p + 1 ] repeatUntil: [p := 5 ].'
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand>>execute
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodeDoItCommand
		iconProvider: 	nil
		iconName: 	#smallDoIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(791653120)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(791653120)
		secondArg: 	a RubEditingArea(791653120)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(791653120)
		secondArg: 	a RubEditingArea(791653120)
		thirdArg: 	[keyDown '<Cmd-d>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(791653120)
		category: 	a KMCategory
		morph: 	a RubEditingArea(791653120)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				i...etc...
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#MacOSX->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCm...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListen...etc...
		index: 	13
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				if...etc...
	Receiver's instance variables: 
		tally: 	31
		array: 	an Array(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecut...etc...



--- The full stack ---
SmallInteger(Object)>>doesNotUnderstand: #ifTrue:ifFalse:
FullBlockClosure(BlockClosure)>>DoItIn:
SmallInteger(ProtoObject)>>mustBeBooleanDeOptimizeIn:
SmallInteger(ProtoObject)>>mustBeBoolean
FullBlockClosure(BlockClosure)>>repeatUntil:
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of SmallInteger did not understand #ifFalse:ifTrue:
3 October 2022 4:06:28.404116 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
StackToRegisterMappingCogit * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
v9.0.18 - Commit: 7249c170 - Date: 2022-09-02 14:31:12 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

SmallInteger(Object)>>doesNotUnderstand: #ifFalse:ifTrue:
	Receiver: 5
	Arguments and temporary variables: 
		aMessage: 	ifFalse: DoItIn: arg1

	^ (arg1 readVariableNamed: 'condition') value...etc...
		exception: 	Instance of SmallInteger did not understand #ifFalse:ifTrue:
		resumeValue: 	nil
	Receiver's instance variables: 
5

FullBlockClosure(BlockClosure)>>DoItIn:
	Receiver: [ p := p + 1 ]
	Arguments and temporary variables: 
		arg1: 	FullBlockClosure(BlockClosure)>>repeatUntil:
	Receiver's instance variables: 
		outerContext: 	UndefinedObject>>DoIt
		startpc: 	a CompiledBlock: [ p := p + 1 ]
		numArgs: 	0
		receiver: 	nil


SmallInteger(ProtoObject)>>mustBeBooleanDeOptimizeIn:
	Receiver: 5
	Arguments and temporary variables: 
		context: 	FullBlockClosure(BlockClosure)>>repeatUntil:
		ret: 	nil
		cache: 	an IdentityDictionary(BlockClosure>>#repeatUntil:->an IdentityDictionary...etc...
		method: 	BlockClosure>>#DoItIn:
	Receiver's instance variables: 
5

SmallInteger(ProtoObject)>>mustBeBoolean
	Receiver: 5
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
5

FullBlockClosure(BlockClosure)>>repeatUntil:
	Receiver: [ p := p + 1 ]
	Arguments and temporary variables: 
		condition: 	[ p := 5 ]
	Receiver's instance variables: 
		outerContext: 	UndefinedObject>>DoIt
		startpc: 	a CompiledBlock: [ p := p + 1 ]
		numArgs: 	0
		receiver: 	nil


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ [ p := p + 1 ] repeatUntil: [ p := 5 ]
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ [ p := p + 1 ] repeatUntil: [ p := 5 ]
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'[ p := p + 1 ] repeatUntil: [p := 5 ].'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#bc->BlockClosure #c1->[ x := x + 1 ] #c2->[ x := x +...etc...
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (75 to: 112) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'c1 := Counter create.
c2 := Counter create.

c...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#bc->BlockClosure #c1->[ x := x + 1 ] #c2->[ x := x +...etc...
		aString: 	'[ p := p + 1 ] repeatUntil: [p := 5 ].'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (75 to: 112) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'c1 := Counter create.
c2 := Counter create.

c...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aString: 	'[ p := p + 1 ] repeatUntil: [p := 5 ].'
		aBlock: 	[ :result | ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | ]
		selection: 	'[ p := p + 1 ] repeatUntil: [p := 5 ].'
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand>>execute
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodeDoItCommand
		iconProvider: 	nil
		iconName: 	#smallDoIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(791653120)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(791653120)
		secondArg: 	a RubEditingArea(791653120)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(791653120)
		secondArg: 	a RubEditingArea(791653120)
		thirdArg: 	[keyDown '<Cmd-d>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(791653120)
		category: 	a KMCategory
		morph: 	a RubEditingArea(791653120)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				i...etc...
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#MacOSX->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCm...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListen...etc...
		index: 	13
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				if...etc...
	Receiver's instance variables: 
		tally: 	31
		array: 	an Array(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecut...etc...



--- The full stack ---
SmallInteger(Object)>>doesNotUnderstand: #ifFalse:ifTrue:
FullBlockClosure(BlockClosure)>>DoItIn:
SmallInteger(ProtoObject)>>mustBeBooleanDeOptimizeIn:
SmallInteger(ProtoObject)>>mustBeBoolean
FullBlockClosure(BlockClosure)>>repeatUntil:
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of SmallInteger did not understand #ifFalse:ifTrue:
3 October 2022 4:06:28.42468 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
StackToRegisterMappingCogit * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
v9.0.18 - Commit: 7249c170 - Date: 2022-09-02 14:31:12 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

SmallInteger(Object)>>doesNotUnderstand: #ifFalse:ifTrue:
	Receiver: 5
	Arguments and temporary variables: 
		aMessage: 	ifFalse: DoItIn: arg1

	^ (arg1 readVariableNamed: 'condition') value...etc...
		exception: 	Instance of SmallInteger did not understand #ifFalse:ifTrue:
		resumeValue: 	nil
	Receiver's instance variables: 
5

FullBlockClosure(BlockClosure)>>DoItIn:
	Receiver: [ p := p + 1 ]
	Arguments and temporary variables: 
		arg1: 	FullBlockClosure(BlockClosure)>>repeatUntil:
	Receiver's instance variables: 
		outerContext: 	UndefinedObject>>DoIt
		startpc: 	a CompiledBlock: [ p := p + 1 ]
		numArgs: 	0
		receiver: 	nil


SmallInteger(ProtoObject)>>mustBeBooleanDeOptimizeIn:
	Receiver: 5
	Arguments and temporary variables: 
		context: 	FullBlockClosure(BlockClosure)>>repeatUntil:
		ret: 	nil
		cache: 	an IdentityDictionary(BlockClosure>>#repeatUntil:->an IdentityDictionary...etc...
		method: 	BlockClosure>>#DoItIn:
	Receiver's instance variables: 
5

SmallInteger(ProtoObject)>>mustBeBoolean
	Receiver: 5
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
5

FullBlockClosure(BlockClosure)>>repeatUntil:
	Receiver: [ p := p + 1 ]
	Arguments and temporary variables: 
		condition: 	[ p := 5 ]
	Receiver's instance variables: 
		outerContext: 	UndefinedObject>>DoIt
		startpc: 	a CompiledBlock: [ p := p + 1 ]
		numArgs: 	0
		receiver: 	nil


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ [ p := p + 1 ] repeatUntil: [ p := 5 ]
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ [ p := p + 1 ] repeatUntil: [ p := 5 ]
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'[ p := p + 1 ] repeatUntil: [p := 5 ].'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#bc->BlockClosure #c1->[ x := x + 1 ] #c2->[ x := x +...etc...
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (75 to: 112) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'c1 := Counter create.
c2 := Counter create.

c...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#bc->BlockClosure #c1->[ x := x + 1 ] #c2->[ x := x +...etc...
		aString: 	'[ p := p + 1 ] repeatUntil: [p := 5 ].'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (75 to: 112) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'c1 := Counter create.
c2 := Counter create.

c...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aString: 	'[ p := p + 1 ] repeatUntil: [p := 5 ].'
		aBlock: 	[ :result | ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | ]
		selection: 	'[ p := p + 1 ] repeatUntil: [p := 5 ].'
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand>>execute
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodeDoItCommand
		iconProvider: 	nil
		iconName: 	#smallDoIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(791653120)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(791653120)
		secondArg: 	a RubEditingArea(791653120)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(791653120)
		secondArg: 	a RubEditingArea(791653120)
		thirdArg: 	[keyDown '<Cmd-d>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(791653120)
		category: 	a KMCategory
		morph: 	a RubEditingArea(791653120)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				i...etc...
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#MacOSX->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCm...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListen...etc...
		index: 	13
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				if...etc...
	Receiver's instance variables: 
		tally: 	31
		array: 	an Array(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecut...etc...



--- The full stack ---
SmallInteger(Object)>>doesNotUnderstand: #ifFalse:ifTrue:
FullBlockClosure(BlockClosure)>>DoItIn:
SmallInteger(ProtoObject)>>mustBeBooleanDeOptimizeIn:
SmallInteger(ProtoObject)>>mustBeBoolean
FullBlockClosure(BlockClosure)>>repeatUntil:
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of FullBlockClosure did not understand #instVarNames
3 October 2022 4:21:54.642712 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
StackToRegisterMappingCogit * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
v9.0.18 - Commit: 7249c170 - Date: 2022-09-02 14:31:12 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

FullBlockClosure(Object)>>doesNotUnderstand: #instVarNames
	Receiver: [ x := x + 1 ]
	Arguments and temporary variables: 
		aMessage: 	instVarNames
		exception: 	Instance of FullBlockClosure did not understand #instVarNames
		resumeValue: 	nil
	Receiver's instance variables: 
		outerContext: 	Counter class>>create
		startpc: 	a CompiledBlock: [ x := x + 1 ]
		numArgs: 	0
		receiver: 	Counter


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ c1 instVarNames
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ c1 instVarNames
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'c1 instVarNames.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#bc->BlockClosure #c1->[ x := x + 1 ] #c2->[ x := x +...etc...
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (148 to: 163) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'c1 := Counter create.
c2 := Counter create.

c...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#bc->BlockClosure #c1->[ x := x + 1 ] #c2->[ x := x +...etc...
		aString: 	'c1 instVarNames.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (148 to: 163) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'c1 := Counter create.
c2 := Counter create.

c...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aString: 	'c1 instVarNames.'
		aBlock: 	[ :result | 
		self printObject: result ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
		self printObject: result ]
		selection: 	'c1 instVarNames.'
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand>>execute
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Print it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodePrintItCommand
		iconProvider: 	nil
		iconName: 	#smallPrintIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(791653120)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(791653120)
		secondArg: 	a RubEditingArea(791653120)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(791653120)
		secondArg: 	a RubEditingArea(791653120)
		thirdArg: 	[keyDown '<Cmd-p>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(791653120)
		category: 	a KMCategory
		morph: 	a RubEditingArea(791653120)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				i...etc...
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#MacOSX->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCm...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListen...etc...
		index: 	11
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				if...etc...
	Receiver's instance variables: 
		tally: 	31
		array: 	an Array(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecut...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#MacOSX->a KMStorage #all->a KMStorage )


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(791653120)
		category: 	a KMCategory
		morph: 	a RubEditingArea(791653120)


[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		aTarget: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(a KMCategoryBinding(#RubTextEditor) a KMCategoryBinding(#MorphFo...etc...
		morph: 	a RubEditingArea(791653120)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(a KMCategoryBinding(nil) a KMCategoryBinding(#RubTextEditor) a KMCate...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
		...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a KMCategoryBinding(nil) a KMCategoryBinding(#RubTextEditor) a ...etc...
		firstIndex: 	1
		lastIndex: 	4



--- The full stack ---
FullBlockClosure(Object)>>doesNotUnderstand: #instVarNames
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of FullBlockClosure did not understand #instVarNames
3 October 2022 4:21:54.678013 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
StackToRegisterMappingCogit * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
v9.0.18 - Commit: 7249c170 - Date: 2022-09-02 14:31:12 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

FullBlockClosure(Object)>>doesNotUnderstand: #instVarNames
	Receiver: [ x := x + 1 ]
	Arguments and temporary variables: 
		aMessage: 	instVarNames
		exception: 	Instance of FullBlockClosure did not understand #instVarNames
		resumeValue: 	nil
	Receiver's instance variables: 
		outerContext: 	Counter class>>create
		startpc: 	a CompiledBlock: [ x := x + 1 ]
		numArgs: 	0
		receiver: 	Counter


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ c1 instVarNames
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ c1 instVarNames
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'c1 instVarNames.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#bc->BlockClosure #c1->[ x := x + 1 ] #c2->[ x := x +...etc...
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (148 to: 163) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'c1 := Counter create.
c2 := Counter create.

c...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#bc->BlockClosure #c1->[ x := x + 1 ] #c2->[ x := x +...etc...
		aString: 	'c1 instVarNames.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (148 to: 163) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'c1 := Counter create.
c2 := Counter create.

c...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aString: 	'c1 instVarNames.'
		aBlock: 	[ :result | 
		self printObject: result ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
		self printObject: result ]
		selection: 	'c1 instVarNames.'
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand>>execute
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Print it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodePrintItCommand
		iconProvider: 	nil
		iconName: 	#smallPrintIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(791653120)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(791653120)
		secondArg: 	a RubEditingArea(791653120)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(791653120)
		secondArg: 	a RubEditingArea(791653120)
		thirdArg: 	[keyDown '<Cmd-p>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(791653120)
		category: 	a KMCategory
		morph: 	a RubEditingArea(791653120)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				i...etc...
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#MacOSX->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCm...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListen...etc...
		index: 	11
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				if...etc...
	Receiver's instance variables: 
		tally: 	31
		array: 	an Array(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecut...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#MacOSX->a KMStorage #all->a KMStorage )


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(791653120)
		category: 	a KMCategory
		morph: 	a RubEditingArea(791653120)


[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		aTarget: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(a KMCategoryBinding(#RubTextEditor) a KMCategoryBinding(#MorphFo...etc...
		morph: 	a RubEditingArea(791653120)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(a KMCategoryBinding(nil) a KMCategoryBinding(#RubTextEditor) a KMCate...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
		...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a KMCategoryBinding(nil) a KMCategoryBinding(#RubTextEditor) a ...etc...
		firstIndex: 	1
		lastIndex: 	4



--- The full stack ---
FullBlockClosure(Object)>>doesNotUnderstand: #instVarNames
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of FullBlockClosure did not understand #instVarNames
3 October 2022 4:22:01.204159 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
StackToRegisterMappingCogit * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
v9.0.18 - Commit: 7249c170 - Date: 2022-09-02 14:31:12 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

FullBlockClosure(Object)>>doesNotUnderstand: #instVarNames
	Receiver: [ x := x + 1 ]
	Arguments and temporary variables: 
		aMessage: 	instVarNames
		exception: 	Instance of FullBlockClosure did not understand #instVarNames
		resumeValue: 	nil
	Receiver's instance variables: 
		outerContext: 	Counter class>>create
		startpc: 	a CompiledBlock: [ x := x + 1 ]
		numArgs: 	0
		receiver: 	Counter


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ c1 instVarNames
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ c1 instVarNames
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'c1 instVarNames.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#bc->BlockClosure #c1->[ x := x + 1 ] #c2->[ x := x +...etc...
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (148 to: 163) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'c1 := Counter create.
c2 := Counter create.

c...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#bc->BlockClosure #c1->[ x := x + 1 ] #c2->[ x := x +...etc...
		aString: 	'c1 instVarNames.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (148 to: 163) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'c1 := Counter create.
c2 := Counter create.

c...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aString: 	'c1 instVarNames.'
		aBlock: 	[ :result | 
		self printObject: result ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
		self printObject: result ]
		selection: 	'c1 instVarNames.'
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand>>execute
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Print it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodePrintItCommand
		iconProvider: 	nil
		iconName: 	#smallPrintIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(791653120)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(791653120)
		secondArg: 	a RubEditingArea(791653120)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(791653120)
		secondArg: 	a RubEditingArea(791653120)
		thirdArg: 	[keyDown '<Cmd-p>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(791653120)
		category: 	a KMCategory
		morph: 	a RubEditingArea(791653120)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				i...etc...
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#MacOSX->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCm...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListen...etc...
		index: 	11
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				if...etc...
	Receiver's instance variables: 
		tally: 	31
		array: 	an Array(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecut...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#MacOSX->a KMStorage #all->a KMStorage )


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(791653120)
		category: 	a KMCategory
		morph: 	a RubEditingArea(791653120)


[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		aTarget: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(a KMCategoryBinding(#RubTextEditor) a KMCategoryBinding(#MorphFo...etc...
		morph: 	a RubEditingArea(791653120)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(a KMCategoryBinding(nil) a KMCategoryBinding(#RubTextEditor) a KMCate...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
		...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a KMCategoryBinding(nil) a KMCategoryBinding(#RubTextEditor) a ...etc...
		firstIndex: 	1
		lastIndex: 	4



--- The full stack ---
FullBlockClosure(Object)>>doesNotUnderstand: #instVarNames
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of FullBlockClosure did not understand #instVarNames
3 October 2022 4:22:01.224131 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
StackToRegisterMappingCogit * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
v9.0.18 - Commit: 7249c170 - Date: 2022-09-02 14:31:12 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

FullBlockClosure(Object)>>doesNotUnderstand: #instVarNames
	Receiver: [ x := x + 1 ]
	Arguments and temporary variables: 
		aMessage: 	instVarNames
		exception: 	Instance of FullBlockClosure did not understand #instVarNames
		resumeValue: 	nil
	Receiver's instance variables: 
		outerContext: 	Counter class>>create
		startpc: 	a CompiledBlock: [ x := x + 1 ]
		numArgs: 	0
		receiver: 	Counter


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ c1 instVarNames
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ c1 instVarNames
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'c1 instVarNames.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#bc->BlockClosure #c1->[ x := x + 1 ] #c2->[ x := x +...etc...
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (148 to: 163) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'c1 := Counter create.
c2 := Counter create.

c...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#bc->BlockClosure #c1->[ x := x + 1 ] #c2->[ x := x +...etc...
		aString: 	'c1 instVarNames.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (148 to: 163) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'c1 := Counter create.
c2 := Counter create.

c...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aString: 	'c1 instVarNames.'
		aBlock: 	[ :result | 
		self printObject: result ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
		self printObject: result ]
		selection: 	'c1 instVarNames.'
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand>>execute
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Print it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodePrintItCommand
		iconProvider: 	nil
		iconName: 	#smallPrintIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(791653120)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(791653120)
		secondArg: 	a RubEditingArea(791653120)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(791653120)
		secondArg: 	a RubEditingArea(791653120)
		thirdArg: 	[keyDown '<Cmd-p>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(791653120)
		category: 	a KMCategory
		morph: 	a RubEditingArea(791653120)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				i...etc...
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#MacOSX->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCm...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListen...etc...
		index: 	11
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				if...etc...
	Receiver's instance variables: 
		tally: 	31
		array: 	an Array(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecut...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#MacOSX->a KMStorage #all->a KMStorage )


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(791653120)
		category: 	a KMCategory
		morph: 	a RubEditingArea(791653120)


[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		aTarget: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(a KMCategoryBinding(#RubTextEditor) a KMCategoryBinding(#MorphFo...etc...
		morph: 	a RubEditingArea(791653120)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(a KMCategoryBinding(nil) a KMCategoryBinding(#RubTextEditor) a KMCate...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
		...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a KMCategoryBinding(nil) a KMCategoryBinding(#RubTextEditor) a ...etc...
		firstIndex: 	1
		lastIndex: 	4



--- The full stack ---
FullBlockClosure(Object)>>doesNotUnderstand: #instVarNames
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of FullBlockClosure did not understand #classVarNames
3 October 2022 4:22:34.804339 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
StackToRegisterMappingCogit * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
v9.0.18 - Commit: 7249c170 - Date: 2022-09-02 14:31:12 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

FullBlockClosure(Object)>>doesNotUnderstand: #classVarNames
	Receiver: [ x := x + 1 ]
	Arguments and temporary variables: 
		aMessage: 	classVarNames
		exception: 	Instance of FullBlockClosure did not understand #classVarNames
		resumeValue: 	nil
	Receiver's instance variables: 
		outerContext: 	Counter class>>create
		startpc: 	a CompiledBlock: [ x := x + 1 ]
		numArgs: 	0
		receiver: 	Counter


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ c1 classVarNames
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ c1 classVarNames
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'c1 classVarNames.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#bc->BlockClosure #c1->[ x := x + 1 ] #c2->[ x := x +...etc...
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (148 to: 164) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'c1 := Counter create.
c2 := Counter create.

c...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#bc->BlockClosure #c1->[ x := x + 1 ] #c2->[ x := x +...etc...
		aString: 	'c1 classVarNames.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (148 to: 164) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'c1 := Counter create.
c2 := Counter create.

c...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aString: 	'c1 classVarNames.'
		aBlock: 	[ :result | 
		self printObject: result ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
		self printObject: result ]
		selection: 	'c1 classVarNames.'
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand>>execute
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Print it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodePrintItCommand
		iconProvider: 	nil
		iconName: 	#smallPrintIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(791653120)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(791653120)
		secondArg: 	a RubEditingArea(791653120)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(791653120)
		secondArg: 	a RubEditingArea(791653120)
		thirdArg: 	[keyDown '<Cmd-p>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(791653120)
		category: 	a KMCategory
		morph: 	a RubEditingArea(791653120)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				i...etc...
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#MacOSX->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCm...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListen...etc...
		index: 	11
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				if...etc...
	Receiver's instance variables: 
		tally: 	31
		array: 	an Array(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecut...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#MacOSX->a KMStorage #all->a KMStorage )


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(791653120)
		category: 	a KMCategory
		morph: 	a RubEditingArea(791653120)


[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		aTarget: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(a KMCategoryBinding(#RubTextEditor) a KMCategoryBinding(#MorphFo...etc...
		morph: 	a RubEditingArea(791653120)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(a KMCategoryBinding(nil) a KMCategoryBinding(#RubTextEditor) a KMCate...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
		...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a KMCategoryBinding(nil) a KMCategoryBinding(#RubTextEditor) a ...etc...
		firstIndex: 	1
		lastIndex: 	4



--- The full stack ---
FullBlockClosure(Object)>>doesNotUnderstand: #classVarNames
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of FullBlockClosure did not understand #classVarNames
3 October 2022 4:22:34.824766 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
StackToRegisterMappingCogit * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
v9.0.18 - Commit: 7249c170 - Date: 2022-09-02 14:31:12 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

FullBlockClosure(Object)>>doesNotUnderstand: #classVarNames
	Receiver: [ x := x + 1 ]
	Arguments and temporary variables: 
		aMessage: 	classVarNames
		exception: 	Instance of FullBlockClosure did not understand #classVarNames
		resumeValue: 	nil
	Receiver's instance variables: 
		outerContext: 	Counter class>>create
		startpc: 	a CompiledBlock: [ x := x + 1 ]
		numArgs: 	0
		receiver: 	Counter


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ c1 classVarNames
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ c1 classVarNames
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'c1 classVarNames.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#bc->BlockClosure #c1->[ x := x + 1 ] #c2->[ x := x +...etc...
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (148 to: 164) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'c1 := Counter create.
c2 := Counter create.

c...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#bc->BlockClosure #c1->[ x := x + 1 ] #c2->[ x := x +...etc...
		aString: 	'c1 classVarNames.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (148 to: 164) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'c1 := Counter create.
c2 := Counter create.

c...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aString: 	'c1 classVarNames.'
		aBlock: 	[ :result | 
		self printObject: result ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
		self printObject: result ]
		selection: 	'c1 classVarNames.'
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand>>execute
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Print it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodePrintItCommand
		iconProvider: 	nil
		iconName: 	#smallPrintIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(791653120)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(791653120)
		secondArg: 	a RubEditingArea(791653120)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(791653120)
		secondArg: 	a RubEditingArea(791653120)
		thirdArg: 	[keyDown '<Cmd-p>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(791653120)
		category: 	a KMCategory
		morph: 	a RubEditingArea(791653120)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				i...etc...
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#MacOSX->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCm...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListen...etc...
		index: 	11
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				if...etc...
	Receiver's instance variables: 
		tally: 	31
		array: 	an Array(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecut...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#MacOSX->a KMStorage #all->a KMStorage )


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(791653120)
		category: 	a KMCategory
		morph: 	a RubEditingArea(791653120)


[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		aTarget: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(a KMCategoryBinding(#RubTextEditor) a KMCategoryBinding(#MorphFo...etc...
		morph: 	a RubEditingArea(791653120)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(a KMCategoryBinding(nil) a KMCategoryBinding(#RubTextEditor) a KMCate...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
		...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a KMCategoryBinding(nil) a KMCategoryBinding(#RubTextEditor) a ...etc...
		firstIndex: 	1
		lastIndex: 	4



--- The full stack ---
FullBlockClosure(Object)>>doesNotUnderstand: #classVarNames
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of FullBlockClosure did not understand #classVarNames
3 October 2022 4:22:44.697013 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
StackToRegisterMappingCogit * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
v9.0.18 - Commit: 7249c170 - Date: 2022-09-02 14:31:12 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

FullBlockClosure(Object)>>doesNotUnderstand: #classVarNames
	Receiver: [ x := x + 1 ]
	Arguments and temporary variables: 
		aMessage: 	classVarNames
		exception: 	Instance of FullBlockClosure did not understand #classVarNames
		resumeValue: 	nil
	Receiver's instance variables: 
		outerContext: 	Counter class>>create
		startpc: 	a CompiledBlock: [ x := x + 1 ]
		numArgs: 	0
		receiver: 	Counter


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ c1 classVarNames
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ c1 classVarNames
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'c1 classVarNames.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#bc->BlockClosure #c1->[ x := x + 1 ] #c2->[ x := x +...etc...
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (148 to: 164) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'c1 := Counter create.
c2 := Counter create.

c...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#bc->BlockClosure #c1->[ x := x + 1 ] #c2->[ x := x +...etc...
		aString: 	'c1 classVarNames.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (148 to: 164) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'c1 := Counter create.
c2 := Counter create.

c...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aString: 	'c1 classVarNames.'
		aBlock: 	[ :result | ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | ]
		selection: 	'c1 classVarNames.'
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand>>execute
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodeDoItCommand
		iconProvider: 	nil
		iconName: 	#smallDoIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(791653120)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(791653120)
		secondArg: 	a RubEditingArea(791653120)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(791653120)
		secondArg: 	a RubEditingArea(791653120)
		thirdArg: 	[keyDown '<Cmd-d>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(791653120)
		category: 	a KMCategory
		morph: 	a RubEditingArea(791653120)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				i...etc...
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#MacOSX->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCm...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListen...etc...
		index: 	13
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				if...etc...
	Receiver's instance variables: 
		tally: 	31
		array: 	an Array(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecut...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#MacOSX->a KMStorage #all->a KMStorage )


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(791653120)
		category: 	a KMCategory
		morph: 	a RubEditingArea(791653120)


[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		aTarget: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(a KMCategoryBinding(#RubTextEditor) a KMCategoryBinding(#MorphFo...etc...
		morph: 	a RubEditingArea(791653120)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(a KMCategoryBinding(nil) a KMCategoryBinding(#RubTextEditor) a KMCate...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
		...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a KMCategoryBinding(nil) a KMCategoryBinding(#RubTextEditor) a ...etc...
		firstIndex: 	1
		lastIndex: 	4



--- The full stack ---
FullBlockClosure(Object)>>doesNotUnderstand: #classVarNames
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of FullBlockClosure did not understand #classVarNames
3 October 2022 4:22:44.720016 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
StackToRegisterMappingCogit * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
v9.0.18 - Commit: 7249c170 - Date: 2022-09-02 14:31:12 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

FullBlockClosure(Object)>>doesNotUnderstand: #classVarNames
	Receiver: [ x := x + 1 ]
	Arguments and temporary variables: 
		aMessage: 	classVarNames
		exception: 	Instance of FullBlockClosure did not understand #classVarNames
		resumeValue: 	nil
	Receiver's instance variables: 
		outerContext: 	Counter class>>create
		startpc: 	a CompiledBlock: [ x := x + 1 ]
		numArgs: 	0
		receiver: 	Counter


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ c1 classVarNames
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ c1 classVarNames
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'c1 classVarNames.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#bc->BlockClosure #c1->[ x := x + 1 ] #c2->[ x := x +...etc...
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (148 to: 164) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'c1 := Counter create.
c2 := Counter create.

c...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#bc->BlockClosure #c1->[ x := x + 1 ] #c2->[ x := x +...etc...
		aString: 	'c1 classVarNames.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (148 to: 164) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'c1 := Counter create.
c2 := Counter create.

c...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aString: 	'c1 classVarNames.'
		aBlock: 	[ :result | ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | ]
		selection: 	'c1 classVarNames.'
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand>>execute
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodeDoItCommand
		iconProvider: 	nil
		iconName: 	#smallDoIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(791653120)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(791653120)
		secondArg: 	a RubEditingArea(791653120)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(791653120)
		secondArg: 	a RubEditingArea(791653120)
		thirdArg: 	[keyDown '<Cmd-d>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(791653120)
		category: 	a KMCategory
		morph: 	a RubEditingArea(791653120)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				i...etc...
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#MacOSX->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCm...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListen...etc...
		index: 	13
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				if...etc...
	Receiver's instance variables: 
		tally: 	31
		array: 	an Array(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecut...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#MacOSX->a KMStorage #all->a KMStorage )


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(791653120)
		category: 	a KMCategory
		morph: 	a RubEditingArea(791653120)


[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		aTarget: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(a KMCategoryBinding(#RubTextEditor) a KMCategoryBinding(#MorphFo...etc...
		morph: 	a RubEditingArea(791653120)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(a KMCategoryBinding(nil) a KMCategoryBinding(#RubTextEditor) a KMCate...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
		...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a KMCategoryBinding(nil) a KMCategoryBinding(#RubTextEditor) a ...etc...
		firstIndex: 	1
		lastIndex: 	4



--- The full stack ---
FullBlockClosure(Object)>>doesNotUnderstand: #classVarNames
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of FullBlockClosure did not understand #instVarNames
3 October 2022 4:23:20.754752 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
StackToRegisterMappingCogit * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
v9.0.18 - Commit: 7249c170 - Date: 2022-09-02 14:31:12 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

FullBlockClosure(Object)>>doesNotUnderstand: #instVarNames
	Receiver: [ x := x + 1 ]
	Arguments and temporary variables: 
		aMessage: 	instVarNames
		exception: 	Instance of FullBlockClosure did not understand #instVarNames
		resumeValue: 	nil
	Receiver's instance variables: 
		outerContext: 	Counter class>>create
		startpc: 	a CompiledBlock: [ x := x + 1 ]
		numArgs: 	0
		receiver: 	Counter


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ c1 instVarNames
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ c1 instVarNames
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'c1 instVarNames.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#bc->BlockClosure #c1->[ x := x + 1 ] #c2->[ x := x +...etc...
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (148 to: 163) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'c1 := Counter create.
c2 := Counter create.

c...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#bc->BlockClosure #c1->[ x := x + 1 ] #c2->[ x := x +...etc...
		aString: 	'c1 instVarNames.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (148 to: 163) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'c1 := Counter create.
c2 := Counter create.

c...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aString: 	'c1 instVarNames.'
		aBlock: 	[ :result | 
		self printObject: result ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
		self printObject: result ]
		selection: 	'c1 instVarNames.'
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand>>execute
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Print it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodePrintItCommand
		iconProvider: 	nil
		iconName: 	#smallPrintIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(791653120)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(791653120)
		secondArg: 	a RubEditingArea(791653120)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(791653120)
		secondArg: 	a RubEditingArea(791653120)
		thirdArg: 	[keyDown '<Cmd-p>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(791653120)
		category: 	a KMCategory
		morph: 	a RubEditingArea(791653120)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				i...etc...
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#MacOSX->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCm...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListen...etc...
		index: 	11
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				if...etc...
	Receiver's instance variables: 
		tally: 	31
		array: 	an Array(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecut...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#MacOSX->a KMStorage #all->a KMStorage )


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(791653120)
		category: 	a KMCategory
		morph: 	a RubEditingArea(791653120)


[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		aTarget: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(a KMCategoryBinding(#RubTextEditor) a KMCategoryBinding(#MorphFo...etc...
		morph: 	a RubEditingArea(791653120)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(a KMCategoryBinding(nil) a KMCategoryBinding(#RubTextEditor) a KMCate...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
		...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a KMCategoryBinding(nil) a KMCategoryBinding(#RubTextEditor) a ...etc...
		firstIndex: 	1
		lastIndex: 	4



--- The full stack ---
FullBlockClosure(Object)>>doesNotUnderstand: #instVarNames
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of FullBlockClosure did not understand #instVarNames
3 October 2022 4:23:20.776133 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
StackToRegisterMappingCogit * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
v9.0.18 - Commit: 7249c170 - Date: 2022-09-02 14:31:12 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

FullBlockClosure(Object)>>doesNotUnderstand: #instVarNames
	Receiver: [ x := x + 1 ]
	Arguments and temporary variables: 
		aMessage: 	instVarNames
		exception: 	Instance of FullBlockClosure did not understand #instVarNames
		resumeValue: 	nil
	Receiver's instance variables: 
		outerContext: 	Counter class>>create
		startpc: 	a CompiledBlock: [ x := x + 1 ]
		numArgs: 	0
		receiver: 	Counter


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ c1 instVarNames
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ c1 instVarNames
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'c1 instVarNames.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#bc->BlockClosure #c1->[ x := x + 1 ] #c2->[ x := x +...etc...
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (148 to: 163) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'c1 := Counter create.
c2 := Counter create.

c...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#bc->BlockClosure #c1->[ x := x + 1 ] #c2->[ x := x +...etc...
		aString: 	'c1 instVarNames.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (148 to: 163) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'c1 := Counter create.
c2 := Counter create.

c...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aString: 	'c1 instVarNames.'
		aBlock: 	[ :result | 
		self printObject: result ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
		self printObject: result ]
		selection: 	'c1 instVarNames.'
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand>>execute
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Print it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodePrintItCommand
		iconProvider: 	nil
		iconName: 	#smallPrintIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(791653120)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(791653120)
		secondArg: 	a RubEditingArea(791653120)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(791653120)
		secondArg: 	a RubEditingArea(791653120)
		thirdArg: 	[keyDown '<Cmd-p>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(791653120)
		category: 	a KMCategory
		morph: 	a RubEditingArea(791653120)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				i...etc...
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#MacOSX->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCm...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListen...etc...
		index: 	11
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				if...etc...
	Receiver's instance variables: 
		tally: 	31
		array: 	an Array(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecut...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#MacOSX->a KMStorage #all->a KMStorage )


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(791653120)
		category: 	a KMCategory
		morph: 	a RubEditingArea(791653120)


[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		aTarget: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(a KMCategoryBinding(#RubTextEditor) a KMCategoryBinding(#MorphFo...etc...
		morph: 	a RubEditingArea(791653120)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(a KMCategoryBinding(nil) a KMCategoryBinding(#RubTextEditor) a KMCate...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
		...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a KMCategoryBinding(nil) a KMCategoryBinding(#RubTextEditor) a ...etc...
		firstIndex: 	1
		lastIndex: 	4



--- The full stack ---
FullBlockClosure(Object)>>doesNotUnderstand: #instVarNames
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of FullBlockClosure did not understand #exoInspect
3 October 2022 4:24:32.430149 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
StackToRegisterMappingCogit * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
v9.0.18 - Commit: 7249c170 - Date: 2022-09-02 14:31:12 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

FullBlockClosure(Object)>>doesNotUnderstand: #exoInspect
	Receiver: [ x := x + 1 ]
	Arguments and temporary variables: 
		aMessage: 	exoInspect
		exception: 	Instance of FullBlockClosure did not understand #exoInspect
		resumeValue: 	nil
	Receiver's instance variables: 
		outerContext: 	Counter class>>create
		startpc: 	a CompiledBlock: [ x := x + 1 ]
		numArgs: 	0
		receiver: 	Counter


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ c1 exoInspect
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ c1 exoInspect
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'c1 exoInspect.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#bc->BlockClosure #c1->[ x := x + 1 ] #c2->[ x := x +...etc...
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (148 to: 161) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'c1 := Counter create.
c2 := Counter create.

c...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#bc->BlockClosure #c1->[ x := x + 1 ] #c2->[ x := x +...etc...
		aString: 	'c1 exoInspect.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (148 to: 161) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'c1 := Counter create.
c2 := Counter create.

c...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aString: 	'c1 exoInspect.'
		aBlock: 	[ :result | ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | ]
		selection: 	'c1 exoInspect.'
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand>>execute
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodeDoItCommand
		iconProvider: 	nil
		iconName: 	#smallDoIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(791653120)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(791653120)
		secondArg: 	a RubEditingArea(791653120)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(791653120)
		secondArg: 	a RubEditingArea(791653120)
		thirdArg: 	[keyDown '<Cmd-d>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(791653120)
		category: 	a KMCategory
		morph: 	a RubEditingArea(791653120)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				i...etc...
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#MacOSX->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCm...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListen...etc...
		index: 	13
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				if...etc...
	Receiver's instance variables: 
		tally: 	31
		array: 	an Array(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecut...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#MacOSX->a KMStorage #all->a KMStorage )


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(791653120)
		category: 	a KMCategory
		morph: 	a RubEditingArea(791653120)


[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		aTarget: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(a KMCategoryBinding(#RubTextEditor) a KMCategoryBinding(#MorphFo...etc...
		morph: 	a RubEditingArea(791653120)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(a KMCategoryBinding(nil) a KMCategoryBinding(#RubTextEditor) a KMCate...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
		...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a KMCategoryBinding(nil) a KMCategoryBinding(#RubTextEditor) a ...etc...
		firstIndex: 	1
		lastIndex: 	4



--- The full stack ---
FullBlockClosure(Object)>>doesNotUnderstand: #exoInspect
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of FullBlockClosure did not understand #exoInspect
3 October 2022 4:24:32.449423 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
StackToRegisterMappingCogit * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
v9.0.18 - Commit: 7249c170 - Date: 2022-09-02 14:31:12 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

FullBlockClosure(Object)>>doesNotUnderstand: #exoInspect
	Receiver: [ x := x + 1 ]
	Arguments and temporary variables: 
		aMessage: 	exoInspect
		exception: 	Instance of FullBlockClosure did not understand #exoInspect
		resumeValue: 	nil
	Receiver's instance variables: 
		outerContext: 	Counter class>>create
		startpc: 	a CompiledBlock: [ x := x + 1 ]
		numArgs: 	0
		receiver: 	Counter


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ c1 exoInspect
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ c1 exoInspect
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'c1 exoInspect.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#bc->BlockClosure #c1->[ x := x + 1 ] #c2->[ x := x +...etc...
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (148 to: 161) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'c1 := Counter create.
c2 := Counter create.

c...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#bc->BlockClosure #c1->[ x := x + 1 ] #c2->[ x := x +...etc...
		aString: 	'c1 exoInspect.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (148 to: 161) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'c1 := Counter create.
c2 := Counter create.

c...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aString: 	'c1 exoInspect.'
		aBlock: 	[ :result | ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | ]
		selection: 	'c1 exoInspect.'
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand>>execute
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodeDoItCommand
		iconProvider: 	nil
		iconName: 	#smallDoIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(791653120)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(791653120)
		secondArg: 	a RubEditingArea(791653120)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(791653120)
		secondArg: 	a RubEditingArea(791653120)
		thirdArg: 	[keyDown '<Cmd-d>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(791653120)
		category: 	a KMCategory
		morph: 	a RubEditingArea(791653120)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				i...etc...
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#MacOSX->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCm...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListen...etc...
		index: 	13
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				if...etc...
	Receiver's instance variables: 
		tally: 	31
		array: 	an Array(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecut...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#MacOSX->a KMStorage #all->a KMStorage )


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(791653120)
		category: 	a KMCategory
		morph: 	a RubEditingArea(791653120)


[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		aTarget: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(a KMCategoryBinding(#RubTextEditor) a KMCategoryBinding(#MorphFo...etc...
		morph: 	a RubEditingArea(791653120)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(a KMCategoryBinding(nil) a KMCategoryBinding(#RubTextEditor) a KMCate...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
		...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a KMCategoryBinding(nil) a KMCategoryBinding(#RubTextEditor) a ...etc...
		firstIndex: 	1
		lastIndex: 	4



--- The full stack ---
FullBlockClosure(Object)>>doesNotUnderstand: #exoInspect
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of Pile class did not understand #initialize:
3 October 2022 4:25:42.457867 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
StackToRegisterMappingCogit * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
v9.0.18 - Commit: 7249c170 - Date: 2022-09-02 14:31:12 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

Pile class(Object)>>doesNotUnderstand: #initialize:
	Receiver: Pile
	Arguments and temporary variables: 
		aMessage: 	initialize: 4
		exception: 	Instance of Pile class did not understand #initialize:
		resumeValue: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#grow->Pile>>#grow #initialize:->Pile>>#initiali...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#Pile
		classPool: 	a Dictionary(#tailleDefaut->nil )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#HAI914I


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Pile new
		  initialize: 4;
		  push: 33;
		  exoInspect
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Pile new
		  initialize: 4;
		  push: 33;
		  exoInspect
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'Pile new initialize: 4; push: 33;exoInspect.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#bc->BlockClosure #c1->[ x := x + 1 ] #c2->[ x := x +...etc...
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (117 to: 160) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'c1 := Counter create.
c2 := Counter create.

c...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#bc->BlockClosure #c1->[ x := x + 1 ] #c2->[ x := x +...etc...
		aString: 	'Pile new initialize: 4; push: 33;exoInspect.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (117 to: 160) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'c1 := Counter create.
c2 := Counter create.

c...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aString: 	'Pile new initialize: 4; push: 33;exoInspect.'
		aBlock: 	[ :result | 
		self printObject: result ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
		self printObject: result ]
		selection: 	'Pile new initialize: 4; push: 33;exoInspect.'
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand>>execute
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Print it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodePrintItCommand
		iconProvider: 	nil
		iconName: 	#smallPrintIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(791653120)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(791653120)
		secondArg: 	a RubEditingArea(791653120)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(791653120)
		secondArg: 	a RubEditingArea(791653120)
		thirdArg: 	[keyDown '<Cmd-p>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(791653120)
		category: 	a KMCategory
		morph: 	a RubEditingArea(791653120)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				i...etc...
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#MacOSX->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCm...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListen...etc...
		index: 	11
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				if...etc...
	Receiver's instance variables: 
		tally: 	31
		array: 	an Array(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecut...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#MacOSX->a KMStorage #all->a KMStorage )


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(791653120)
		category: 	a KMCategory
		morph: 	a RubEditingArea(791653120)


[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		aTarget: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(a KMCategoryBinding(#RubTextEditor) a KMCategoryBinding(#MorphFo...etc...
		morph: 	a RubEditingArea(791653120)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(a KMCategoryBinding(nil) a KMCategoryBinding(#RubTextEditor) a KMCate...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
		...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a KMCategoryBinding(nil) a KMCategoryBinding(#RubTextEditor) a ...etc...
		firstIndex: 	1
		lastIndex: 	4



--- The full stack ---
Pile class(Object)>>doesNotUnderstand: #initialize:
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of Pile class did not understand #initialize:
3 October 2022 4:25:42.481365 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
StackToRegisterMappingCogit * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
v9.0.18 - Commit: 7249c170 - Date: 2022-09-02 14:31:12 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

Pile class(Object)>>doesNotUnderstand: #initialize:
	Receiver: Pile
	Arguments and temporary variables: 
		aMessage: 	initialize: 4
		exception: 	Instance of Pile class did not understand #initialize:
		resumeValue: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#grow->Pile>>#grow #initialize:->Pile>>#initiali...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#Pile
		classPool: 	a Dictionary(#tailleDefaut->nil )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#HAI914I


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Pile new
		  initialize: 4;
		  push: 33;
		  exoInspect
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Pile new
		  initialize: 4;
		  push: 33;
		  exoInspect
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'Pile new initialize: 4; push: 33;exoInspect.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#bc->BlockClosure #c1->[ x := x + 1 ] #c2->[ x := x +...etc...
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (117 to: 160) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'c1 := Counter create.
c2 := Counter create.

c...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#bc->BlockClosure #c1->[ x := x + 1 ] #c2->[ x := x +...etc...
		aString: 	'Pile new initialize: 4; push: 33;exoInspect.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (117 to: 160) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'c1 := Counter create.
c2 := Counter create.

c...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aString: 	'Pile new initialize: 4; push: 33;exoInspect.'
		aBlock: 	[ :result | 
		self printObject: result ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
		self printObject: result ]
		selection: 	'Pile new initialize: 4; push: 33;exoInspect.'
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand>>execute
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Print it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodePrintItCommand
		iconProvider: 	nil
		iconName: 	#smallPrintIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(791653120)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(791653120)
		secondArg: 	a RubEditingArea(791653120)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(791653120)
		secondArg: 	a RubEditingArea(791653120)
		thirdArg: 	[keyDown '<Cmd-p>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(791653120)
		category: 	a KMCategory
		morph: 	a RubEditingArea(791653120)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				i...etc...
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#MacOSX->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCm...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListen...etc...
		index: 	11
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				if...etc...
	Receiver's instance variables: 
		tally: 	31
		array: 	an Array(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecut...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#MacOSX->a KMStorage #all->a KMStorage )


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(791653120)
		category: 	a KMCategory
		morph: 	a RubEditingArea(791653120)


[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		aTarget: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(a KMCategoryBinding(#RubTextEditor) a KMCategoryBinding(#MorphFo...etc...
		morph: 	a RubEditingArea(791653120)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(a KMCategoryBinding(nil) a KMCategoryBinding(#RubTextEditor) a KMCate...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
		...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a KMCategoryBinding(nil) a KMCategoryBinding(#RubTextEditor) a ...etc...
		firstIndex: 	1
		lastIndex: 	4



--- The full stack ---
Pile class(Object)>>doesNotUnderstand: #initialize:
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of Pile class did not understand #initialize:
3 October 2022 4:26:03.39252 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
StackToRegisterMappingCogit * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
v9.0.18 - Commit: 7249c170 - Date: 2022-09-02 14:31:12 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

Pile class(Object)>>doesNotUnderstand: #initialize:
	Receiver: Pile
	Arguments and temporary variables: 
		aMessage: 	initialize: 4
		exception: 	Instance of Pile class did not understand #initialize:
		resumeValue: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#grow->Pile>>#grow #initialize:->Pile>>#initiali...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#Pile
		classPool: 	a Dictionary(#tailleDefaut->nil )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#HAI914I


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ p := Pile new initialize: 4
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ p := Pile new initialize: 4
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'p := Pile new initialize: 4.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#bc->BlockClosure #c1->[ x := x + 1 ] #c2->[ x := x +...etc...
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (117 to: 144) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'c1 := Counter create.
c2 := Counter create.

c...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#bc->BlockClosure #c1->[ x := x + 1 ] #c2->[ x := x +...etc...
		aString: 	'p := Pile new initialize: 4.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (117 to: 144) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'c1 := Counter create.
c2 := Counter create.

c...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aString: 	'p := Pile new initialize: 4.'
		aBlock: 	[ :result | ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | ]
		selection: 	'p := Pile new initialize: 4.'
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand>>execute
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodeDoItCommand
		iconProvider: 	nil
		iconName: 	#smallDoIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(791653120)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(791653120)
		secondArg: 	a RubEditingArea(791653120)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(791653120)
		secondArg: 	a RubEditingArea(791653120)
		thirdArg: 	[keyDown '<Cmd-d>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(791653120)
		category: 	a KMCategory
		morph: 	a RubEditingArea(791653120)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				i...etc...
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#MacOSX->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCm...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListen...etc...
		index: 	13
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				if...etc...
	Receiver's instance variables: 
		tally: 	31
		array: 	an Array(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecut...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#MacOSX->a KMStorage #all->a KMStorage )


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(791653120)
		category: 	a KMCategory
		morph: 	a RubEditingArea(791653120)


[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		aTarget: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(a KMCategoryBinding(#RubTextEditor) a KMCategoryBinding(#MorphFo...etc...
		morph: 	a RubEditingArea(791653120)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(a KMCategoryBinding(nil) a KMCategoryBinding(#RubTextEditor) a KMCate...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
		...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a KMCategoryBinding(nil) a KMCategoryBinding(#RubTextEditor) a ...etc...
		firstIndex: 	1
		lastIndex: 	4



--- The full stack ---
Pile class(Object)>>doesNotUnderstand: #initialize:
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of Pile class did not understand #initialize:
3 October 2022 4:26:03.413583 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
StackToRegisterMappingCogit * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
v9.0.18 - Commit: 7249c170 - Date: 2022-09-02 14:31:12 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

Pile class(Object)>>doesNotUnderstand: #initialize:
	Receiver: Pile
	Arguments and temporary variables: 
		aMessage: 	initialize: 4
		exception: 	Instance of Pile class did not understand #initialize:
		resumeValue: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#grow->Pile>>#grow #initialize:->Pile>>#initiali...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#Pile
		classPool: 	a Dictionary(#tailleDefaut->nil )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#HAI914I


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ p := Pile new initialize: 4
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ p := Pile new initialize: 4
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'p := Pile new initialize: 4.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#bc->BlockClosure #c1->[ x := x + 1 ] #c2->[ x := x +...etc...
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (117 to: 144) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'c1 := Counter create.
c2 := Counter create.

c...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#bc->BlockClosure #c1->[ x := x + 1 ] #c2->[ x := x +...etc...
		aString: 	'p := Pile new initialize: 4.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (117 to: 144) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'c1 := Counter create.
c2 := Counter create.

c...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aString: 	'p := Pile new initialize: 4.'
		aBlock: 	[ :result | ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | ]
		selection: 	'p := Pile new initialize: 4.'
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand>>execute
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodeDoItCommand
		iconProvider: 	nil
		iconName: 	#smallDoIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(791653120)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(791653120)
		secondArg: 	a RubEditingArea(791653120)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(791653120)
		secondArg: 	a RubEditingArea(791653120)
		thirdArg: 	[keyDown '<Cmd-d>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(791653120)
		category: 	a KMCategory
		morph: 	a RubEditingArea(791653120)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				i...etc...
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#MacOSX->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCm...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListen...etc...
		index: 	13
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				if...etc...
	Receiver's instance variables: 
		tally: 	31
		array: 	an Array(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecut...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#MacOSX->a KMStorage #all->a KMStorage )


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(791653120)
		category: 	a KMCategory
		morph: 	a RubEditingArea(791653120)


[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		aTarget: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(a KMCategoryBinding(#RubTextEditor) a KMCategoryBinding(#MorphFo...etc...
		morph: 	a RubEditingArea(791653120)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(a KMCategoryBinding(nil) a KMCategoryBinding(#RubTextEditor) a KMCate...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
		...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a KMCategoryBinding(nil) a KMCategoryBinding(#RubTextEditor) a ...etc...
		firstIndex: 	1
		lastIndex: 	4



--- The full stack ---
Pile class(Object)>>doesNotUnderstand: #initialize:
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of Pile class did not understand #initialize:
3 October 2022 4:26:40.71034 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
StackToRegisterMappingCogit * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
v9.0.18 - Commit: 7249c170 - Date: 2022-09-02 14:31:12 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

Pile class(Object)>>doesNotUnderstand: #initialize:
	Receiver: Pile
	Arguments and temporary variables: 
		aMessage: 	initialize: 4
		exception: 	Instance of Pile class did not understand #initialize:
		resumeValue: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#grow->Pile>>#grow #initialize:->Pile>>#initiali...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#Pile
		classPool: 	a Dictionary(#tailleDefaut->nil )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#HAI914I


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ p := Pile initialize: 4
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ p := Pile initialize: 4
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'p := Pile initialize: 4.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#bc->BlockClosure #c1->[ x := x + 1 ] #c2->[ x := x +...etc...
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (117 to: 140) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'c1 := Counter create.
c2 := Counter create.

c...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#bc->BlockClosure #c1->[ x := x + 1 ] #c2->[ x := x +...etc...
		aString: 	'p := Pile initialize: 4.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (117 to: 140) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'c1 := Counter create.
c2 := Counter create.

c...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aString: 	'p := Pile initialize: 4.'
		aBlock: 	[ :result | ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | ]
		selection: 	'p := Pile initialize: 4.'
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand>>execute
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodeDoItCommand
		iconProvider: 	nil
		iconName: 	#smallDoIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(791653120)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(791653120)
		secondArg: 	a RubEditingArea(791653120)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(791653120)
		secondArg: 	a RubEditingArea(791653120)
		thirdArg: 	[keyDown '<Cmd-d>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(791653120)
		category: 	a KMCategory
		morph: 	a RubEditingArea(791653120)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				i...etc...
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#MacOSX->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCm...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListen...etc...
		index: 	13
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				if...etc...
	Receiver's instance variables: 
		tally: 	31
		array: 	an Array(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecut...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#MacOSX->a KMStorage #all->a KMStorage )


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(791653120)
		category: 	a KMCategory
		morph: 	a RubEditingArea(791653120)


[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		aTarget: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(a KMCategoryBinding(#RubTextEditor) a KMCategoryBinding(#MorphFo...etc...
		morph: 	a RubEditingArea(791653120)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(a KMCategoryBinding(nil) a KMCategoryBinding(#RubTextEditor) a KMCate...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
		...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a KMCategoryBinding(nil) a KMCategoryBinding(#RubTextEditor) a ...etc...
		firstIndex: 	1
		lastIndex: 	4



--- The full stack ---
Pile class(Object)>>doesNotUnderstand: #initialize:
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of Pile class did not understand #initialize:
3 October 2022 4:26:40.731579 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
StackToRegisterMappingCogit * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
v9.0.18 - Commit: 7249c170 - Date: 2022-09-02 14:31:12 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

Pile class(Object)>>doesNotUnderstand: #initialize:
	Receiver: Pile
	Arguments and temporary variables: 
		aMessage: 	initialize: 4
		exception: 	Instance of Pile class did not understand #initialize:
		resumeValue: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#grow->Pile>>#grow #initialize:->Pile>>#initiali...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#Pile
		classPool: 	a Dictionary(#tailleDefaut->nil )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#HAI914I


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ p := Pile initialize: 4
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ p := Pile initialize: 4
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'p := Pile initialize: 4.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#bc->BlockClosure #c1->[ x := x + 1 ] #c2->[ x := x +...etc...
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (117 to: 140) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'c1 := Counter create.
c2 := Counter create.

c...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#bc->BlockClosure #c1->[ x := x + 1 ] #c2->[ x := x +...etc...
		aString: 	'p := Pile initialize: 4.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (117 to: 140) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'c1 := Counter create.
c2 := Counter create.

c...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aString: 	'p := Pile initialize: 4.'
		aBlock: 	[ :result | ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | ]
		selection: 	'p := Pile initialize: 4.'
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand>>execute
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodeDoItCommand
		iconProvider: 	nil
		iconName: 	#smallDoIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(791653120)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(791653120)
		secondArg: 	a RubEditingArea(791653120)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(791653120)
		secondArg: 	a RubEditingArea(791653120)
		thirdArg: 	[keyDown '<Cmd-d>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(791653120)
		category: 	a KMCategory
		morph: 	a RubEditingArea(791653120)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				i...etc...
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#MacOSX->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCm...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListen...etc...
		index: 	13
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				if...etc...
	Receiver's instance variables: 
		tally: 	31
		array: 	an Array(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecut...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#MacOSX->a KMStorage #all->a KMStorage )


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(791653120)
		category: 	a KMCategory
		morph: 	a RubEditingArea(791653120)


[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		aTarget: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(a KMCategoryBinding(#RubTextEditor) a KMCategoryBinding(#MorphFo...etc...
		morph: 	a RubEditingArea(791653120)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(a KMCategoryBinding(nil) a KMCategoryBinding(#RubTextEditor) a KMCate...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
		...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a KMCategoryBinding(nil) a KMCategoryBinding(#RubTextEditor) a ...etc...
		firstIndex: 	1
		lastIndex: 	4



--- The full stack ---
Pile class(Object)>>doesNotUnderstand: #initialize:
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of Pile class did not understand #initialize:
3 October 2022 4:27:41.632886 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
StackToRegisterMappingCogit * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
v9.0.18 - Commit: 7249c170 - Date: 2022-09-02 14:31:12 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

Pile class(Object)>>doesNotUnderstand: #initialize:
	Receiver: Pile
	Arguments and temporary variables: 
		aMessage: 	initialize: 5
		exception: 	Instance of Pile class did not understand #initialize:
		resumeValue: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#grow->Pile>>#grow #initialize:->Pile>>#initiali...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#Pile
		classPool: 	a Dictionary(#tailleDefaut->nil )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#HAI914I


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ p := Pile initialize: 5
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ p := Pile initialize: 5
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'p := Pile initialize: 5.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#bc->BlockClosure #c1->[ x := x + 1 ] #c2->[ x := x +...etc...
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (117 to: 140) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'c1 := Counter create.
c2 := Counter create.

c...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#bc->BlockClosure #c1->[ x := x + 1 ] #c2->[ x := x +...etc...
		aString: 	'p := Pile initialize: 5.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (117 to: 140) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'c1 := Counter create.
c2 := Counter create.

c...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aString: 	'p := Pile initialize: 5.'
		aBlock: 	[ :result | ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | ]
		selection: 	'p := Pile initialize: 5.'
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand>>execute
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodeDoItCommand
		iconProvider: 	nil
		iconName: 	#smallDoIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(791653120)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(791653120)
		secondArg: 	a RubEditingArea(791653120)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(791653120)
		secondArg: 	a RubEditingArea(791653120)
		thirdArg: 	[keyDown '<Cmd-d>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(791653120)
		category: 	a KMCategory
		morph: 	a RubEditingArea(791653120)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				i...etc...
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#MacOSX->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCm...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListen...etc...
		index: 	13
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				if...etc...
	Receiver's instance variables: 
		tally: 	31
		array: 	an Array(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecut...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#MacOSX->a KMStorage #all->a KMStorage )


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(791653120)
		category: 	a KMCategory
		morph: 	a RubEditingArea(791653120)


[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		aTarget: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(a KMCategoryBinding(#RubTextEditor) a KMCategoryBinding(#MorphFo...etc...
		morph: 	a RubEditingArea(791653120)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(a KMCategoryBinding(nil) a KMCategoryBinding(#RubTextEditor) a KMCate...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
		...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a KMCategoryBinding(nil) a KMCategoryBinding(#RubTextEditor) a ...etc...
		firstIndex: 	1
		lastIndex: 	4



--- The full stack ---
Pile class(Object)>>doesNotUnderstand: #initialize:
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of Pile class did not understand #initialize:
3 October 2022 4:27:41.653454 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
StackToRegisterMappingCogit * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
v9.0.18 - Commit: 7249c170 - Date: 2022-09-02 14:31:12 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

Pile class(Object)>>doesNotUnderstand: #initialize:
	Receiver: Pile
	Arguments and temporary variables: 
		aMessage: 	initialize: 5
		exception: 	Instance of Pile class did not understand #initialize:
		resumeValue: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#grow->Pile>>#grow #initialize:->Pile>>#initiali...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#Pile
		classPool: 	a Dictionary(#tailleDefaut->nil )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#HAI914I


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ p := Pile initialize: 5
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ p := Pile initialize: 5
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'p := Pile initialize: 5.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#bc->BlockClosure #c1->[ x := x + 1 ] #c2->[ x := x +...etc...
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (117 to: 140) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'c1 := Counter create.
c2 := Counter create.

c...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#bc->BlockClosure #c1->[ x := x + 1 ] #c2->[ x := x +...etc...
		aString: 	'p := Pile initialize: 5.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (117 to: 140) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'c1 := Counter create.
c2 := Counter create.

c...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aString: 	'p := Pile initialize: 5.'
		aBlock: 	[ :result | ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | ]
		selection: 	'p := Pile initialize: 5.'
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand>>execute
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodeDoItCommand
		iconProvider: 	nil
		iconName: 	#smallDoIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(791653120)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(791653120)
		secondArg: 	a RubEditingArea(791653120)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(791653120)
		secondArg: 	a RubEditingArea(791653120)
		thirdArg: 	[keyDown '<Cmd-d>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(791653120)
		category: 	a KMCategory
		morph: 	a RubEditingArea(791653120)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				i...etc...
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#MacOSX->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCm...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListen...etc...
		index: 	13
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				if...etc...
	Receiver's instance variables: 
		tally: 	31
		array: 	an Array(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecut...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#MacOSX->a KMStorage #all->a KMStorage )


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(791653120)
		category: 	a KMCategory
		morph: 	a RubEditingArea(791653120)


[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		aTarget: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(a KMCategoryBinding(#RubTextEditor) a KMCategoryBinding(#MorphFo...etc...
		morph: 	a RubEditingArea(791653120)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(a KMCategoryBinding(nil) a KMCategoryBinding(#RubTextEditor) a KMCate...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
		...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a KMCategoryBinding(nil) a KMCategoryBinding(#RubTextEditor) a ...etc...
		firstIndex: 	1
		lastIndex: 	4



--- The full stack ---
Pile class(Object)>>doesNotUnderstand: #initialize:
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of Pile did not understand #exoInspect
3 October 2022 4:28:54.616147 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
StackToRegisterMappingCogit * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
v9.0.18 - Commit: 7249c170 - Date: 2022-09-02 14:31:12 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

Pile(Object)>>doesNotUnderstand: #exoInspect
	Receiver: une Pile, de taille: 5 contenant: 1 objets : (33 nil nil nil nil )
	Arguments and temporary variables: 
		aMessage: 	exoInspect
		exception: 	Instance of Pile did not understand #exoInspect
		resumeValue: 	nil
	Receiver's instance variables: 
		contenu: 	#(33 nil nil nil nil)
		index: 	1
		capacite: 	5


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ p exoInspect
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ p exoInspect
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'p exoInspect.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#bc->BlockClosure #c1->[ x := x + 1 ] #c2->[ x := x +...etc...
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (147 to: 159) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'c1 := Counter create.
c2 := Counter create.

c...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#bc->BlockClosure #c1->[ x := x + 1 ] #c2->[ x := x +...etc...
		aString: 	'p exoInspect.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (147 to: 159) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'c1 := Counter create.
c2 := Counter create.

c...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aString: 	'p exoInspect.'
		aBlock: 	[ :result | 
		self printObject: result ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
		self printObject: result ]
		selection: 	'p exoInspect.'
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand>>execute
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Print it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodePrintItCommand
		iconProvider: 	nil
		iconName: 	#smallPrintIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(791653120)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(791653120)
		secondArg: 	a RubEditingArea(791653120)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(791653120)
		secondArg: 	a RubEditingArea(791653120)
		thirdArg: 	[keyDown '<Cmd-p>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(791653120)
		category: 	a KMCategory
		morph: 	a RubEditingArea(791653120)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				i...etc...
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#MacOSX->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCm...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListen...etc...
		index: 	11
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				if...etc...
	Receiver's instance variables: 
		tally: 	31
		array: 	an Array(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecut...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#MacOSX->a KMStorage #all->a KMStorage )


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(791653120)
		category: 	a KMCategory
		morph: 	a RubEditingArea(791653120)


[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		aTarget: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(a KMCategoryBinding(#RubTextEditor) a KMCategoryBinding(#MorphFo...etc...
		morph: 	a RubEditingArea(791653120)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(a KMCategoryBinding(nil) a KMCategoryBinding(#RubTextEditor) a KMCate...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
		...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a KMCategoryBinding(nil) a KMCategoryBinding(#RubTextEditor) a ...etc...
		firstIndex: 	1
		lastIndex: 	4



--- The full stack ---
Pile(Object)>>doesNotUnderstand: #exoInspect
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of Pile did not understand #exoInspect
3 October 2022 4:28:54.637231 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
StackToRegisterMappingCogit * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
v9.0.18 - Commit: 7249c170 - Date: 2022-09-02 14:31:12 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

Pile(Object)>>doesNotUnderstand: #exoInspect
	Receiver: une Pile, de taille: 5 contenant: 1 objets : (33 nil nil nil nil )
	Arguments and temporary variables: 
		aMessage: 	exoInspect
		exception: 	Instance of Pile did not understand #exoInspect
		resumeValue: 	nil
	Receiver's instance variables: 
		contenu: 	#(33 nil nil nil nil)
		index: 	1
		capacite: 	5


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ p exoInspect
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ p exoInspect
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'p exoInspect.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#bc->BlockClosure #c1->[ x := x + 1 ] #c2->[ x := x +...etc...
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (147 to: 159) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'c1 := Counter create.
c2 := Counter create.

c...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#bc->BlockClosure #c1->[ x := x + 1 ] #c2->[ x := x +...etc...
		aString: 	'p exoInspect.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (147 to: 159) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'c1 := Counter create.
c2 := Counter create.

c...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aString: 	'p exoInspect.'
		aBlock: 	[ :result | 
		self printObject: result ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
		self printObject: result ]
		selection: 	'p exoInspect.'
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand>>execute
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Print it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodePrintItCommand
		iconProvider: 	nil
		iconName: 	#smallPrintIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(791653120)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(791653120)
		secondArg: 	a RubEditingArea(791653120)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(791653120)
		secondArg: 	a RubEditingArea(791653120)
		thirdArg: 	[keyDown '<Cmd-p>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(791653120)
		category: 	a KMCategory
		morph: 	a RubEditingArea(791653120)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				i...etc...
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#MacOSX->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCm...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListen...etc...
		index: 	11
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				if...etc...
	Receiver's instance variables: 
		tally: 	31
		array: 	an Array(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecut...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#MacOSX->a KMStorage #all->a KMStorage )


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(791653120)
		category: 	a KMCategory
		morph: 	a RubEditingArea(791653120)


[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		aTarget: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(a KMCategoryBinding(#RubTextEditor) a KMCategoryBinding(#MorphFo...etc...
		morph: 	a RubEditingArea(791653120)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(a KMCategoryBinding(nil) a KMCategoryBinding(#RubTextEditor) a KMCate...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
		...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a KMCategoryBinding(nil) a KMCategoryBinding(#RubTextEditor) a ...etc...
		firstIndex: 	1
		lastIndex: 	4



--- The full stack ---
Pile(Object)>>doesNotUnderstand: #exoInspect
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of Pile did not understand #exoInspect
3 October 2022 4:29:02.015701 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
StackToRegisterMappingCogit * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
v9.0.18 - Commit: 7249c170 - Date: 2022-09-02 14:31:12 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

Pile(Object)>>doesNotUnderstand: #exoInspect
	Receiver: une Pile, de taille: 5 contenant: 1 objets : (33 nil nil nil nil )
	Arguments and temporary variables: 
		aMessage: 	exoInspect
		exception: 	Instance of Pile did not understand #exoInspect
		resumeValue: 	nil
	Receiver's instance variables: 
		contenu: 	#(33 nil nil nil nil)
		index: 	1
		capacite: 	5


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ p exoInspect
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ p exoInspect
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'p exoInspect.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#bc->BlockClosure #c1->[ x := x + 1 ] #c2->[ x := x +...etc...
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (147 to: 159) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'c1 := Counter create.
c2 := Counter create.

c...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#bc->BlockClosure #c1->[ x := x + 1 ] #c2->[ x := x +...etc...
		aString: 	'p exoInspect.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (147 to: 159) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'c1 := Counter create.
c2 := Counter create.

c...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aString: 	'p exoInspect.'
		aBlock: 	[ :result | ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | ]
		selection: 	'p exoInspect.'
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand>>execute
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodeDoItCommand
		iconProvider: 	nil
		iconName: 	#smallDoIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(791653120)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(791653120)
		secondArg: 	a RubEditingArea(791653120)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(791653120)
		secondArg: 	a RubEditingArea(791653120)
		thirdArg: 	[keyDown '<Cmd-d>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(791653120)
		category: 	a KMCategory
		morph: 	a RubEditingArea(791653120)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				i...etc...
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#MacOSX->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCm...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListen...etc...
		index: 	13
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				if...etc...
	Receiver's instance variables: 
		tally: 	31
		array: 	an Array(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecut...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#MacOSX->a KMStorage #all->a KMStorage )


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(791653120)
		category: 	a KMCategory
		morph: 	a RubEditingArea(791653120)


[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		aTarget: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(a KMCategoryBinding(#RubTextEditor) a KMCategoryBinding(#MorphFo...etc...
		morph: 	a RubEditingArea(791653120)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(a KMCategoryBinding(nil) a KMCategoryBinding(#RubTextEditor) a KMCate...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
		...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a KMCategoryBinding(nil) a KMCategoryBinding(#RubTextEditor) a ...etc...
		firstIndex: 	1
		lastIndex: 	4



--- The full stack ---
Pile(Object)>>doesNotUnderstand: #exoInspect
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of Pile did not understand #exoInspect
3 October 2022 4:29:02.038563 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
StackToRegisterMappingCogit * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
v9.0.18 - Commit: 7249c170 - Date: 2022-09-02 14:31:12 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

Pile(Object)>>doesNotUnderstand: #exoInspect
	Receiver: une Pile, de taille: 5 contenant: 1 objets : (33 nil nil nil nil )
	Arguments and temporary variables: 
		aMessage: 	exoInspect
		exception: 	Instance of Pile did not understand #exoInspect
		resumeValue: 	nil
	Receiver's instance variables: 
		contenu: 	#(33 nil nil nil nil)
		index: 	1
		capacite: 	5


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ p exoInspect
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ p exoInspect
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'p exoInspect.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#bc->BlockClosure #c1->[ x := x + 1 ] #c2->[ x := x +...etc...
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (147 to: 159) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'c1 := Counter create.
c2 := Counter create.

c...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#bc->BlockClosure #c1->[ x := x + 1 ] #c2->[ x := x +...etc...
		aString: 	'p exoInspect.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (147 to: 159) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'c1 := Counter create.
c2 := Counter create.

c...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aString: 	'p exoInspect.'
		aBlock: 	[ :result | ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | ]
		selection: 	'p exoInspect.'
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand>>execute
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodeDoItCommand
		iconProvider: 	nil
		iconName: 	#smallDoIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(791653120)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(791653120)
		secondArg: 	a RubEditingArea(791653120)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(791653120)
		secondArg: 	a RubEditingArea(791653120)
		thirdArg: 	[keyDown '<Cmd-d>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(791653120)
		category: 	a KMCategory
		morph: 	a RubEditingArea(791653120)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				i...etc...
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#MacOSX->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCm...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListen...etc...
		index: 	13
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				if...etc...
	Receiver's instance variables: 
		tally: 	31
		array: 	an Array(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecut...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#MacOSX->a KMStorage #all->a KMStorage )


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(791653120)
		category: 	a KMCategory
		morph: 	a RubEditingArea(791653120)


[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		aTarget: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(a KMCategoryBinding(#RubTextEditor) a KMCategoryBinding(#MorphFo...etc...
		morph: 	a RubEditingArea(791653120)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(a KMCategoryBinding(nil) a KMCategoryBinding(#RubTextEditor) a KMCate...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
		...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a KMCategoryBinding(nil) a KMCategoryBinding(#RubTextEditor) a ...etc...
		firstIndex: 	1
		lastIndex: 	4



--- The full stack ---
Pile(Object)>>doesNotUnderstand: #exoInspect
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of Pile did not understand #exoInspect
3 October 2022 4:29:30.952346 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
StackToRegisterMappingCogit * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
v9.0.18 - Commit: 7249c170 - Date: 2022-09-02 14:31:12 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

Pile(Object)>>doesNotUnderstand: #exoInspect
	Receiver: une Pile, de taille: 5 contenant: 1 objets : (33 nil nil nil nil )
	Arguments and temporary variables: 
		aMessage: 	exoInspect
		exception: 	Instance of Pile did not understand #exoInspect
		resumeValue: 	nil
	Receiver's instance variables: 
		contenu: 	#(33 nil nil nil nil)
		index: 	1
		capacite: 	5


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ p exoInspect
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ p exoInspect
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'p exoInspect.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#bc->BlockClosure #c1->[ x := x + 1 ] #c2->[ x := x +...etc...
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (147 to: 159) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'c1 := Counter create.
c2 := Counter create.

c...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#bc->BlockClosure #c1->[ x := x + 1 ] #c2->[ x := x +...etc...
		aString: 	'p exoInspect.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (147 to: 159) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'c1 := Counter create.
c2 := Counter create.

c...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aString: 	'p exoInspect.'
		aBlock: 	[ :result | 
		self printObject: result ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
		self printObject: result ]
		selection: 	'p exoInspect.'
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand>>execute
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Print it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodePrintItCommand
		iconProvider: 	nil
		iconName: 	#smallPrintIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(791653120)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(791653120)
		secondArg: 	a RubEditingArea(791653120)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(791653120)
		secondArg: 	a RubEditingArea(791653120)
		thirdArg: 	[keyDown '<Cmd-p>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(791653120)
		category: 	a KMCategory
		morph: 	a RubEditingArea(791653120)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				i...etc...
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#MacOSX->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCm...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListen...etc...
		index: 	11
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				if...etc...
	Receiver's instance variables: 
		tally: 	31
		array: 	an Array(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecut...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#MacOSX->a KMStorage #all->a KMStorage )


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(791653120)
		category: 	a KMCategory
		morph: 	a RubEditingArea(791653120)


[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		aTarget: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(a KMCategoryBinding(#RubTextEditor) a KMCategoryBinding(#MorphFo...etc...
		morph: 	a RubEditingArea(791653120)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(a KMCategoryBinding(nil) a KMCategoryBinding(#RubTextEditor) a KMCate...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
		...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a KMCategoryBinding(nil) a KMCategoryBinding(#RubTextEditor) a ...etc...
		firstIndex: 	1
		lastIndex: 	4



--- The full stack ---
Pile(Object)>>doesNotUnderstand: #exoInspect
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of Pile did not understand #exoInspect
3 October 2022 4:29:30.974827 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
StackToRegisterMappingCogit * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
v9.0.18 - Commit: 7249c170 - Date: 2022-09-02 14:31:12 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

Pile(Object)>>doesNotUnderstand: #exoInspect
	Receiver: une Pile, de taille: 5 contenant: 1 objets : (33 nil nil nil nil )
	Arguments and temporary variables: 
		aMessage: 	exoInspect
		exception: 	Instance of Pile did not understand #exoInspect
		resumeValue: 	nil
	Receiver's instance variables: 
		contenu: 	#(33 nil nil nil nil)
		index: 	1
		capacite: 	5


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ p exoInspect
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ p exoInspect
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'p exoInspect.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#bc->BlockClosure #c1->[ x := x + 1 ] #c2->[ x := x +...etc...
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (147 to: 159) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'c1 := Counter create.
c2 := Counter create.

c...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#bc->BlockClosure #c1->[ x := x + 1 ] #c2->[ x := x +...etc...
		aString: 	'p exoInspect.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (147 to: 159) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'c1 := Counter create.
c2 := Counter create.

c...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aString: 	'p exoInspect.'
		aBlock: 	[ :result | 
		self printObject: result ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
		self printObject: result ]
		selection: 	'p exoInspect.'
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand>>execute
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Print it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodePrintItCommand
		iconProvider: 	nil
		iconName: 	#smallPrintIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(791653120)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(791653120)
		secondArg: 	a RubEditingArea(791653120)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(791653120)
		secondArg: 	a RubEditingArea(791653120)
		thirdArg: 	[keyDown '<Cmd-p>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(791653120)
		category: 	a KMCategory
		morph: 	a RubEditingArea(791653120)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				i...etc...
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#MacOSX->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCm...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListen...etc...
		index: 	11
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				if...etc...
	Receiver's instance variables: 
		tally: 	31
		array: 	an Array(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecut...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#MacOSX->a KMStorage #all->a KMStorage )


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(791653120)
		category: 	a KMCategory
		morph: 	a RubEditingArea(791653120)


[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		aTarget: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(a KMCategoryBinding(#RubTextEditor) a KMCategoryBinding(#MorphFo...etc...
		morph: 	a RubEditingArea(791653120)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(a KMCategoryBinding(nil) a KMCategoryBinding(#RubTextEditor) a KMCate...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
		...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a KMCategoryBinding(nil) a KMCategoryBinding(#RubTextEditor) a ...etc...
		firstIndex: 	1
		lastIndex: 	4



--- The full stack ---
Pile(Object)>>doesNotUnderstand: #exoInspect
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of Pile did not understand #exoInspect
3 October 2022 4:31:52.93009 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
StackToRegisterMappingCogit * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
v9.0.18 - Commit: 7249c170 - Date: 2022-09-02 14:31:12 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

Pile(Object)>>doesNotUnderstand: #exoInspect
	Receiver: une Pile, de taille: 5 contenant: 1 objets : (33 nil nil nil nil )
	Arguments and temporary variables: 
		aMessage: 	exoInspect
		exception: 	Instance of Pile did not understand #exoInspect
		resumeValue: 	nil
	Receiver's instance variables: 
		contenu: 	#(33 nil nil nil nil)
		index: 	1
		capacite: 	5


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ p exoInspect
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ p exoInspect
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'p exoInspect.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#bc->BlockClosure #c1->[ x := x + 1 ] #c2->[ x := x +...etc...
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (147 to: 159) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'c1 := Counter create.
c2 := Counter create.

c...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#bc->BlockClosure #c1->[ x := x + 1 ] #c2->[ x := x +...etc...
		aString: 	'p exoInspect.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (147 to: 159) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'c1 := Counter create.
c2 := Counter create.

c...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aString: 	'p exoInspect.'
		aBlock: 	[ :result | 
		self printObject: result ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
		self printObject: result ]
		selection: 	'p exoInspect.'
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand>>execute
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Print it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodePrintItCommand
		iconProvider: 	nil
		iconName: 	#smallPrintIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(791653120)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(791653120)
		secondArg: 	a RubEditingArea(791653120)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(791653120)
		secondArg: 	a RubEditingArea(791653120)
		thirdArg: 	[keyDown '<Cmd-p>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(791653120)
		category: 	a KMCategory
		morph: 	a RubEditingArea(791653120)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				i...etc...
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#MacOSX->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCm...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListen...etc...
		index: 	11
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				if...etc...
	Receiver's instance variables: 
		tally: 	31
		array: 	an Array(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecut...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#MacOSX->a KMStorage #all->a KMStorage )


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(791653120)
		category: 	a KMCategory
		morph: 	a RubEditingArea(791653120)


[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		aTarget: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(a KMCategoryBinding(#RubTextEditor) a KMCategoryBinding(#MorphFo...etc...
		morph: 	a RubEditingArea(791653120)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(a KMCategoryBinding(nil) a KMCategoryBinding(#RubTextEditor) a KMCate...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
		...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a KMCategoryBinding(nil) a KMCategoryBinding(#RubTextEditor) a ...etc...
		firstIndex: 	1
		lastIndex: 	4



--- The full stack ---
Pile(Object)>>doesNotUnderstand: #exoInspect
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of Pile did not understand #exoInspect
3 October 2022 4:31:52.954284 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
StackToRegisterMappingCogit * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
v9.0.18 - Commit: 7249c170 - Date: 2022-09-02 14:31:12 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

Pile(Object)>>doesNotUnderstand: #exoInspect
	Receiver: une Pile, de taille: 5 contenant: 1 objets : (33 nil nil nil nil )
	Arguments and temporary variables: 
		aMessage: 	exoInspect
		exception: 	Instance of Pile did not understand #exoInspect
		resumeValue: 	nil
	Receiver's instance variables: 
		contenu: 	#(33 nil nil nil nil)
		index: 	1
		capacite: 	5


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ p exoInspect
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ p exoInspect
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'p exoInspect.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#bc->BlockClosure #c1->[ x := x + 1 ] #c2->[ x := x +...etc...
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (147 to: 159) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'c1 := Counter create.
c2 := Counter create.

c...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#bc->BlockClosure #c1->[ x := x + 1 ] #c2->[ x := x +...etc...
		aString: 	'p exoInspect.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (147 to: 159) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'c1 := Counter create.
c2 := Counter create.

c...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aString: 	'p exoInspect.'
		aBlock: 	[ :result | 
		self printObject: result ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
		self printObject: result ]
		selection: 	'p exoInspect.'
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand>>execute
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Print it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodePrintItCommand
		iconProvider: 	nil
		iconName: 	#smallPrintIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(791653120)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(791653120)
		secondArg: 	a RubEditingArea(791653120)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(791653120)
		secondArg: 	a RubEditingArea(791653120)
		thirdArg: 	[keyDown '<Cmd-p>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(791653120)
		category: 	a KMCategory
		morph: 	a RubEditingArea(791653120)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				i...etc...
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#MacOSX->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCm...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListen...etc...
		index: 	11
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				if...etc...
	Receiver's instance variables: 
		tally: 	31
		array: 	an Array(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecut...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#MacOSX->a KMStorage #all->a KMStorage )


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(791653120)
		category: 	a KMCategory
		morph: 	a RubEditingArea(791653120)


[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		aTarget: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(a KMCategoryBinding(#RubTextEditor) a KMCategoryBinding(#MorphFo...etc...
		morph: 	a RubEditingArea(791653120)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(a KMCategoryBinding(nil) a KMCategoryBinding(#RubTextEditor) a KMCate...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
		...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a KMCategoryBinding(nil) a KMCategoryBinding(#RubTextEditor) a ...etc...
		firstIndex: 	1
		lastIndex: 	4



--- The full stack ---
Pile(Object)>>doesNotUnderstand: #exoInspect
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of Pile did not understand #exoInspect
3 October 2022 4:32:24.608309 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
StackToRegisterMappingCogit * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
v9.0.18 - Commit: 7249c170 - Date: 2022-09-02 14:31:12 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

Pile(Object)>>doesNotUnderstand: #exoInspect
	Receiver: une Pile, de taille: 5 contenant: 1 objets : (33 nil nil nil nil )
	Arguments and temporary variables: 
		aMessage: 	exoInspect
		exception: 	Instance of Pile did not understand #exoInspect
		resumeValue: 	nil
	Receiver's instance variables: 
		contenu: 	#(33 nil nil nil nil)
		index: 	1
		capacite: 	5


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ p exoInspect
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ p exoInspect
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'p exoInspect.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#bc->BlockClosure #c1->[ x := x + 1 ] #c2->[ x := x +...etc...
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (147 to: 159) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'c1 := Counter create.
c2 := Counter create.

c...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#bc->BlockClosure #c1->[ x := x + 1 ] #c2->[ x := x +...etc...
		aString: 	'p exoInspect.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (147 to: 159) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'c1 := Counter create.
c2 := Counter create.

c...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aString: 	'p exoInspect.'
		aBlock: 	[ :result | 
		self printObject: result ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
		self printObject: result ]
		selection: 	'p exoInspect.'
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand>>execute
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Print it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodePrintItCommand
		iconProvider: 	nil
		iconName: 	#smallPrintIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(791653120)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(791653120)
		secondArg: 	a RubEditingArea(791653120)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(791653120)
		secondArg: 	a RubEditingArea(791653120)
		thirdArg: 	[keyDown '<Cmd-p>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(791653120)
		category: 	a KMCategory
		morph: 	a RubEditingArea(791653120)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				i...etc...
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#MacOSX->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCm...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListen...etc...
		index: 	11
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				if...etc...
	Receiver's instance variables: 
		tally: 	31
		array: 	an Array(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecut...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#MacOSX->a KMStorage #all->a KMStorage )


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(791653120)
		category: 	a KMCategory
		morph: 	a RubEditingArea(791653120)


[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		aTarget: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(a KMCategoryBinding(#RubTextEditor) a KMCategoryBinding(#MorphFo...etc...
		morph: 	a RubEditingArea(791653120)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(a KMCategoryBinding(nil) a KMCategoryBinding(#RubTextEditor) a KMCate...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
		...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a KMCategoryBinding(nil) a KMCategoryBinding(#RubTextEditor) a ...etc...
		firstIndex: 	1
		lastIndex: 	4



--- The full stack ---
Pile(Object)>>doesNotUnderstand: #exoInspect
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of Pile did not understand #exoInspect
3 October 2022 4:32:24.631461 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
StackToRegisterMappingCogit * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
v9.0.18 - Commit: 7249c170 - Date: 2022-09-02 14:31:12 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

Pile(Object)>>doesNotUnderstand: #exoInspect
	Receiver: une Pile, de taille: 5 contenant: 1 objets : (33 nil nil nil nil )
	Arguments and temporary variables: 
		aMessage: 	exoInspect
		exception: 	Instance of Pile did not understand #exoInspect
		resumeValue: 	nil
	Receiver's instance variables: 
		contenu: 	#(33 nil nil nil nil)
		index: 	1
		capacite: 	5


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ p exoInspect
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ p exoInspect
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'p exoInspect.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#bc->BlockClosure #c1->[ x := x + 1 ] #c2->[ x := x +...etc...
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (147 to: 159) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'c1 := Counter create.
c2 := Counter create.

c...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#bc->BlockClosure #c1->[ x := x + 1 ] #c2->[ x := x +...etc...
		aString: 	'p exoInspect.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (147 to: 159) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'c1 := Counter create.
c2 := Counter create.

c...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aString: 	'p exoInspect.'
		aBlock: 	[ :result | 
		self printObject: result ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
		self printObject: result ]
		selection: 	'p exoInspect.'
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand>>execute
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Print it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodePrintItCommand
		iconProvider: 	nil
		iconName: 	#smallPrintIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(791653120)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(791653120)
		secondArg: 	a RubEditingArea(791653120)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(791653120)
		secondArg: 	a RubEditingArea(791653120)
		thirdArg: 	[keyDown '<Cmd-p>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(791653120)
		category: 	a KMCategory
		morph: 	a RubEditingArea(791653120)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				i...etc...
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#MacOSX->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCm...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListen...etc...
		index: 	11
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				if...etc...
	Receiver's instance variables: 
		tally: 	31
		array: 	an Array(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecut...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#MacOSX->a KMStorage #all->a KMStorage )


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(791653120)
		category: 	a KMCategory
		morph: 	a RubEditingArea(791653120)


[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		aTarget: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(a KMCategoryBinding(#RubTextEditor) a KMCategoryBinding(#MorphFo...etc...
		morph: 	a RubEditingArea(791653120)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(a KMCategoryBinding(nil) a KMCategoryBinding(#RubTextEditor) a KMCate...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
		...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a KMCategoryBinding(nil) a KMCategoryBinding(#RubTextEditor) a ...etc...
		firstIndex: 	1
		lastIndex: 	4



--- The full stack ---
Pile(Object)>>doesNotUnderstand: #exoInspect
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of Pile class did not understand #initialize:
10 October 2022 3:23:30.951532 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
StackToRegisterMappingCogit * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
v9.0.18 - Commit: 7249c170 - Date: 2022-09-02 14:31:12 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

Pile class(Object)>>doesNotUnderstand: #initialize:
	Receiver: Pile
	Arguments and temporary variables: 
		aMessage: 	initialize: 4
		exception: 	Instance of Pile class did not understand #initialize:
		resumeValue: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#grow->Pile>>#grow #initialize:->Pile>>#initiali...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#Pile
		classPool: 	a Dictionary(#tailleDefaut->nil )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#HAI914I


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Pile new
		  initialize: 4;
		  push: 33;
		  exoInspect
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Pile new
		  initialize: 4;
		  push: 33;
		  exoInspect
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'Pile new initialize: 4; push: 33; exoInspect.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 45) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'Pile new initialize: 4; push: 33; exoInspect.'...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'Pile new initialize: 4; push: 33; exoInspect.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 45) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'Pile new initialize: 4; push: 33; exoInspect.'...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aString: 	'Pile new initialize: 4; push: 33; exoInspect.'
		aBlock: 	[ :result | ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | ]
		selection: 	'Pile new initialize: 4; push: 33; exoInspect.'
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand>>execute
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodeDoItCommand
		iconProvider: 	nil
		iconName: 	#smallDoIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(417864704)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(417864704)
		secondArg: 	a RubEditingArea(417864704)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(417864704)
		secondArg: 	a RubEditingArea(417864704)
		thirdArg: 	[keyDown '<Cmd-d>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(417864704)
		category: 	a KMCategory
		morph: 	a RubEditingArea(417864704)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				i...etc...
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#MacOSX->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCm...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListen...etc...
		index: 	7
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				if...etc...
	Receiver's instance variables: 
		tally: 	31
		array: 	an Array(nil nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeEx...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#MacOSX->a KMStorage #all->a KMStorage )


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(417864704)
		category: 	a KMCategory
		morph: 	a RubEditingArea(417864704)


[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		aTarget: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(a KMCategoryBinding(#RubSmalltalkEditor) a KMCategoryBinding(#Mo...etc...
		morph: 	a RubEditingArea(417864704)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(a KMCategoryBinding(nil) a KMCategoryBinding(#RubSmalltalkEditor) a K...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
		...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a KMCategoryBinding(nil) a KMCategoryBinding(#RubSmalltalkEdito...etc...
		firstIndex: 	1
		lastIndex: 	4



--- The full stack ---
Pile class(Object)>>doesNotUnderstand: #initialize:
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of Pile class did not understand #initialize:
10 October 2022 3:23:30.993859 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
StackToRegisterMappingCogit * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
v9.0.18 - Commit: 7249c170 - Date: 2022-09-02 14:31:12 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

Pile class(Object)>>doesNotUnderstand: #initialize:
	Receiver: Pile
	Arguments and temporary variables: 
		aMessage: 	initialize: 4
		exception: 	Instance of Pile class did not understand #initialize:
		resumeValue: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#grow->Pile>>#grow #initialize:->Pile>>#initiali...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#Pile
		classPool: 	a Dictionary(#tailleDefaut->nil )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#HAI914I


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Pile new
		  initialize: 4;
		  push: 33;
		  exoInspect
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Pile new
		  initialize: 4;
		  push: 33;
		  exoInspect
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'Pile new initialize: 4; push: 33; exoInspect.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 45) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'Pile new initialize: 4; push: 33; exoInspect.'...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'Pile new initialize: 4; push: 33; exoInspect.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 45) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'Pile new initialize: 4; push: 33; exoInspect.'...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aString: 	'Pile new initialize: 4; push: 33; exoInspect.'
		aBlock: 	[ :result | ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | ]
		selection: 	'Pile new initialize: 4; push: 33; exoInspect.'
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand>>execute
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodeDoItCommand
		iconProvider: 	nil
		iconName: 	#smallDoIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(417864704)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(417864704)
		secondArg: 	a RubEditingArea(417864704)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(417864704)
		secondArg: 	a RubEditingArea(417864704)
		thirdArg: 	[keyDown '<Cmd-d>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(417864704)
		category: 	a KMCategory
		morph: 	a RubEditingArea(417864704)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				i...etc...
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#MacOSX->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCm...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListen...etc...
		index: 	7
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				if...etc...
	Receiver's instance variables: 
		tally: 	31
		array: 	an Array(nil nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeEx...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#MacOSX->a KMStorage #all->a KMStorage )


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(417864704)
		category: 	a KMCategory
		morph: 	a RubEditingArea(417864704)


[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		aTarget: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(a KMCategoryBinding(#RubSmalltalkEditor) a KMCategoryBinding(#Mo...etc...
		morph: 	a RubEditingArea(417864704)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(a KMCategoryBinding(nil) a KMCategoryBinding(#RubSmalltalkEditor) a K...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
		...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a KMCategoryBinding(nil) a KMCategoryBinding(#RubSmalltalkEdito...etc...
		firstIndex: 	1
		lastIndex: 	4



--- The full stack ---
Pile class(Object)>>doesNotUnderstand: #initialize:
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of Pile class did not understand #push:
10 October 2022 3:23:56.693154 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
StackToRegisterMappingCogit * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
v9.0.18 - Commit: 7249c170 - Date: 2022-09-02 14:31:12 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

Pile class(Object)>>doesNotUnderstand: #push:
	Receiver: Pile
	Arguments and temporary variables: 
		aMessage: 	push: 33
		exception: 	Instance of Pile class did not understand #push:
		resumeValue: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#grow->Pile>>#grow #initialize:->Pile>>#initiali...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#Pile
		classPool: 	a Dictionary(#tailleDefaut->nil )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#HAI914I


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Pile
		  new: 4;
		  push: 33;
		  exoInspect
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Pile
		  new: 4;
		  push: 33;
		  exoInspect
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'Pile new: 4; push: 33; exoInspect.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 34) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'Pile new: 4; push: 33; exoInspect.' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'Pile new: 4; push: 33; exoInspect.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 34) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'Pile new: 4; push: 33; exoInspect.' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aString: 	'Pile new: 4; push: 33; exoInspect.'
		aBlock: 	[ :result | ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | ]
		selection: 	'Pile new: 4; push: 33; exoInspect.'
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand>>execute
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodeDoItCommand
		iconProvider: 	nil
		iconName: 	#smallDoIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(417864704)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(417864704)
		secondArg: 	a RubEditingArea(417864704)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(417864704)
		secondArg: 	a RubEditingArea(417864704)
		thirdArg: 	[keyDown '<Cmd-d>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(417864704)
		category: 	a KMCategory
		morph: 	a RubEditingArea(417864704)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				i...etc...
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#MacOSX->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCm...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListen...etc...
		index: 	7
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				if...etc...
	Receiver's instance variables: 
		tally: 	31
		array: 	an Array(nil nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeEx...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#MacOSX->a KMStorage #all->a KMStorage )


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(417864704)
		category: 	a KMCategory
		morph: 	a RubEditingArea(417864704)


[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		aTarget: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(a KMCategoryBinding(#RubSmalltalkEditor) a KMCategoryBinding(#Mo...etc...
		morph: 	a RubEditingArea(417864704)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(a KMCategoryBinding(nil) a KMCategoryBinding(#RubSmalltalkEditor) a K...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
		...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a KMCategoryBinding(nil) a KMCategoryBinding(#RubSmalltalkEdito...etc...
		firstIndex: 	1
		lastIndex: 	4



--- The full stack ---
Pile class(Object)>>doesNotUnderstand: #push:
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of Pile class did not understand #push:
10 October 2022 3:23:56.715109 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
StackToRegisterMappingCogit * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
v9.0.18 - Commit: 7249c170 - Date: 2022-09-02 14:31:12 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

Pile class(Object)>>doesNotUnderstand: #push:
	Receiver: Pile
	Arguments and temporary variables: 
		aMessage: 	push: 33
		exception: 	Instance of Pile class did not understand #push:
		resumeValue: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#grow->Pile>>#grow #initialize:->Pile>>#initiali...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#Pile
		classPool: 	a Dictionary(#tailleDefaut->nil )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#HAI914I


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Pile
		  new: 4;
		  push: 33;
		  exoInspect
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Pile
		  new: 4;
		  push: 33;
		  exoInspect
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'Pile new: 4; push: 33; exoInspect.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 34) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'Pile new: 4; push: 33; exoInspect.' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'Pile new: 4; push: 33; exoInspect.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 34) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'Pile new: 4; push: 33; exoInspect.' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aString: 	'Pile new: 4; push: 33; exoInspect.'
		aBlock: 	[ :result | ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | ]
		selection: 	'Pile new: 4; push: 33; exoInspect.'
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand>>execute
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodeDoItCommand
		iconProvider: 	nil
		iconName: 	#smallDoIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(417864704)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(417864704)
		secondArg: 	a RubEditingArea(417864704)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(417864704)
		secondArg: 	a RubEditingArea(417864704)
		thirdArg: 	[keyDown '<Cmd-d>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(417864704)
		category: 	a KMCategory
		morph: 	a RubEditingArea(417864704)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				i...etc...
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#MacOSX->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCm...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListen...etc...
		index: 	7
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				if...etc...
	Receiver's instance variables: 
		tally: 	31
		array: 	an Array(nil nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeEx...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#MacOSX->a KMStorage #all->a KMStorage )


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(417864704)
		category: 	a KMCategory
		morph: 	a RubEditingArea(417864704)


[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-d>'])
		aTarget: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(a KMCategoryBinding(#RubSmalltalkEditor) a KMCategoryBinding(#Mo...etc...
		morph: 	a RubEditingArea(417864704)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(a KMCategoryBinding(nil) a KMCategoryBinding(#RubSmalltalkEditor) a K...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
		...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a KMCategoryBinding(nil) a KMCategoryBinding(#RubSmalltalkEdito...etc...
		firstIndex: 	1
		lastIndex: 	4



--- The full stack ---
Pile class(Object)>>doesNotUnderstand: #push:
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of Pile did not understand #asSymbol
10 October 2022 3:24:37.028112 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
StackToRegisterMappingCogit * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
v9.0.18 - Commit: 7249c170 - Date: 2022-09-02 14:31:12 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

Pile(Object)>>doesNotUnderstand: #asSymbol
	Receiver: une Pile, de taille: 4 contenant: 1 objets : (33 nil nil nil )
	Arguments and temporary variables: 
		aMessage: 	asSymbol
		exception: 	Instance of Pile did not understand #asSymbol
		resumeValue: 	nil
	Receiver's instance variables: 
		contenu: 	#(33 nil nil nil)
		index: 	1
		capacite: 	4


Pile class(ClassDescription)>>slotNamed:ifFound:ifNone:
	Receiver: Pile
	Arguments and temporary variables: 
		aName: 	une Pile, de taille: 4 contenant: 1 objets : (33 nil nil nil )
		foundBlock: 	[ :slot | slot read: self ]
		exceptionBlock: 	[ InstanceVariableNotFound signalFor: aString asString ]
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#grow->Pile>>#grow #initialize:->Pile>>#initiali...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#Pile
		classPool: 	a Dictionary(#tailleDefaut->nil )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#HAI914I


Pile(Object)>>instVarNamed:
	Receiver: une Pile, de taille: 4 contenant: 1 objets : (33 nil nil nil )
	Arguments and temporary variables: 
		aString: 	une Pile, de taille: 4 contenant: 1 objets : (33 nil nil nil )
	Receiver's instance variables: 
		contenu: 	#(33 nil nil nil)
		index: 	1
		capacite: 	4


Pile(Object)>>exoInspect
	Receiver: une Pile, de taille: 4 contenant: 1 objets : (33 nil nil nil )
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		contenu: 	#(33 nil nil nil)
		index: 	1
		capacite: 	4


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ p exoInspect
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ p exoInspect
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'p exoInspect.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#p->une Pile, de taille: 4 contenant: 1 objets : (33 ...etc...
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (31 to: 43) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'p := Pile new: 4.
p push: 33.
p exoInspect.' ]...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#p->une Pile, de taille: 4 contenant: 1 objets : (33 ...etc...
		aString: 	'p exoInspect.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (31 to: 43) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'p := Pile new: 4.
p push: 33.
p exoInspect.' ]...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aString: 	'p exoInspect.'
		aBlock: 	[ :result | 
		self printObject: result ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
		self printObject: result ]
		selection: 	'p exoInspect.'
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand>>execute
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Print it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodePrintItCommand
		iconProvider: 	nil
		iconName: 	#smallPrintIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(417864704)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(417864704)
		secondArg: 	a RubEditingArea(417864704)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(417864704)
		secondArg: 	a RubEditingArea(417864704)
		thirdArg: 	[keyDown '<Cmd-p>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(417864704)
		category: 	a KMCategory
		morph: 	a RubEditingArea(417864704)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				i...etc...
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#MacOSX->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCm...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListen...etc...
		index: 	9
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				if...etc...
	Receiver's instance variables: 
		tally: 	31
		array: 	an Array(nil nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeEx...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#MacOSX->a KMStorage #all->a KMStorage )



--- The full stack ---
Pile(Object)>>doesNotUnderstand: #asSymbol
Pile class(ClassDescription)>>slotNamed:ifFound:ifNone:
Pile(Object)>>instVarNamed:
Pile(Object)>>exoInspect
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of Pile did not understand #asSymbol
10 October 2022 3:24:37.054798 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
StackToRegisterMappingCogit * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
v9.0.18 - Commit: 7249c170 - Date: 2022-09-02 14:31:12 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

Pile(Object)>>doesNotUnderstand: #asSymbol
	Receiver: une Pile, de taille: 4 contenant: 1 objets : (33 nil nil nil )
	Arguments and temporary variables: 
		aMessage: 	asSymbol
		exception: 	Instance of Pile did not understand #asSymbol
		resumeValue: 	nil
	Receiver's instance variables: 
		contenu: 	#(33 nil nil nil)
		index: 	1
		capacite: 	4


Pile class(ClassDescription)>>slotNamed:ifFound:ifNone:
	Receiver: Pile
	Arguments and temporary variables: 
		aName: 	une Pile, de taille: 4 contenant: 1 objets : (33 nil nil nil )
		foundBlock: 	[ :slot | slot read: self ]
		exceptionBlock: 	[ InstanceVariableNotFound signalFor: aString asString ]
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#grow->Pile>>#grow #initialize:->Pile>>#initiali...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#Pile
		classPool: 	a Dictionary(#tailleDefaut->nil )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#HAI914I


Pile(Object)>>instVarNamed:
	Receiver: une Pile, de taille: 4 contenant: 1 objets : (33 nil nil nil )
	Arguments and temporary variables: 
		aString: 	une Pile, de taille: 4 contenant: 1 objets : (33 nil nil nil )
	Receiver's instance variables: 
		contenu: 	#(33 nil nil nil)
		index: 	1
		capacite: 	4


Pile(Object)>>exoInspect
	Receiver: une Pile, de taille: 4 contenant: 1 objets : (33 nil nil nil )
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		contenu: 	#(33 nil nil nil)
		index: 	1
		capacite: 	4


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ p exoInspect
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ p exoInspect
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'p exoInspect.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#p->une Pile, de taille: 4 contenant: 1 objets : (33 ...etc...
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (31 to: 43) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'p := Pile new: 4.
p push: 33.
p exoInspect.' ]...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#p->une Pile, de taille: 4 contenant: 1 objets : (33 ...etc...
		aString: 	'p exoInspect.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (31 to: 43) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'p := Pile new: 4.
p push: 33.
p exoInspect.' ]...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aString: 	'p exoInspect.'
		aBlock: 	[ :result | 
		self printObject: result ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
		self printObject: result ]
		selection: 	'p exoInspect.'
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand>>execute
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Print it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodePrintItCommand
		iconProvider: 	nil
		iconName: 	#smallPrintIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(417864704)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(417864704)
		secondArg: 	a RubEditingArea(417864704)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(417864704)
		secondArg: 	a RubEditingArea(417864704)
		thirdArg: 	[keyDown '<Cmd-p>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(417864704)
		category: 	a KMCategory
		morph: 	a RubEditingArea(417864704)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				i...etc...
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#MacOSX->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCm...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListen...etc...
		index: 	9
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				if...etc...
	Receiver's instance variables: 
		tally: 	31
		array: 	an Array(nil nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeEx...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#MacOSX->a KMStorage #all->a KMStorage )



--- The full stack ---
Pile(Object)>>doesNotUnderstand: #asSymbol
Pile class(ClassDescription)>>slotNamed:ifFound:ifNone:
Pile(Object)>>instVarNamed:
Pile(Object)>>exoInspect
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of ProtoObject did not understand #instVarNamed:
10 October 2022 3:25:02.870509 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
StackToRegisterMappingCogit * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
v9.0.18 - Commit: 7249c170 - Date: 2022-09-02 14:31:12 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

Pile(ProtoObject)>>doesNotUnderstand: #instVarNamed:
	Receiver: une Pile, de taille: 4 contenant: 1 objets : (33 nil nil nil )
	Arguments and temporary variables: 
		aMessage: 	instVarNamed: une Pile, de taille: 4 contenant: 1 objets : (33 nil ni...etc...
	Receiver's instance variables: 
		contenu: 	#(33 nil nil nil)
		index: 	1
		capacite: 	4


Pile(Object)>>exoInspect
	Receiver: une Pile, de taille: 4 contenant: 1 objets : (33 nil nil nil )
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		contenu: 	#(33 nil nil nil)
		index: 	1
		capacite: 	4


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ p exoInspect
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ p exoInspect
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'p exoInspect.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#p->une Pile, de taille: 4 contenant: 1 objets : (33 ...etc...
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (31 to: 43) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'p := Pile new: 4.
p push: 33.
p exoInspect.' ]...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#p->une Pile, de taille: 4 contenant: 1 objets : (33 ...etc...
		aString: 	'p exoInspect.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (31 to: 43) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'p := Pile new: 4.
p push: 33.
p exoInspect.' ]...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aString: 	'p exoInspect.'
		aBlock: 	[ :result | 
		self printObject: result ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
		self printObject: result ]
		selection: 	'p exoInspect.'
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand>>execute
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Print it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodePrintItCommand
		iconProvider: 	nil
		iconName: 	#smallPrintIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(417864704)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(417864704)
		secondArg: 	a RubEditingArea(417864704)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(417864704)
		secondArg: 	a RubEditingArea(417864704)
		thirdArg: 	[keyDown '<Cmd-p>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(417864704)
		category: 	a KMCategory
		morph: 	a RubEditingArea(417864704)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				i...etc...
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#MacOSX->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCm...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListen...etc...
		index: 	9
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				if...etc...
	Receiver's instance variables: 
		tally: 	31
		array: 	an Array(nil nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeEx...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#MacOSX->a KMStorage #all->a KMStorage )


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(417864704)
		category: 	a KMCategory
		morph: 	a RubEditingArea(417864704)


[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		aTarget: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(a KMCategoryBinding(#RubSmalltalkEditor) a KMCategoryBinding(#Mo...etc...
		morph: 	a RubEditingArea(417864704)
		directKeymaps: 	a KMCategory



--- The full stack ---
Pile(ProtoObject)>>doesNotUnderstand: #instVarNamed:
Pile(Object)>>exoInspect
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of ProtoObject did not understand #instVarNamed:
10 October 2022 3:25:02.892987 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
StackToRegisterMappingCogit * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
v9.0.18 - Commit: 7249c170 - Date: 2022-09-02 14:31:12 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

Pile(ProtoObject)>>doesNotUnderstand: #instVarNamed:
	Receiver: une Pile, de taille: 4 contenant: 1 objets : (33 nil nil nil )
	Arguments and temporary variables: 
		aMessage: 	instVarNamed: une Pile, de taille: 4 contenant: 1 objets : (33 nil ni...etc...
	Receiver's instance variables: 
		contenu: 	#(33 nil nil nil)
		index: 	1
		capacite: 	4


Pile(Object)>>exoInspect
	Receiver: une Pile, de taille: 4 contenant: 1 objets : (33 nil nil nil )
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		contenu: 	#(33 nil nil nil)
		index: 	1
		capacite: 	4


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ p exoInspect
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ p exoInspect
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'p exoInspect.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#p->une Pile, de taille: 4 contenant: 1 objets : (33 ...etc...
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (31 to: 43) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'p := Pile new: 4.
p push: 33.
p exoInspect.' ]...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#p->une Pile, de taille: 4 contenant: 1 objets : (33 ...etc...
		aString: 	'p exoInspect.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (31 to: 43) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'p := Pile new: 4.
p push: 33.
p exoInspect.' ]...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aString: 	'p exoInspect.'
		aBlock: 	[ :result | 
		self printObject: result ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
		self printObject: result ]
		selection: 	'p exoInspect.'
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand>>execute
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Print it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodePrintItCommand
		iconProvider: 	nil
		iconName: 	#smallPrintIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(417864704)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(417864704)
		secondArg: 	a RubEditingArea(417864704)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(417864704)
		secondArg: 	a RubEditingArea(417864704)
		thirdArg: 	[keyDown '<Cmd-p>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(417864704)
		category: 	a KMCategory
		morph: 	a RubEditingArea(417864704)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				i...etc...
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#MacOSX->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCm...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListen...etc...
		index: 	9
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				if...etc...
	Receiver's instance variables: 
		tally: 	31
		array: 	an Array(nil nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeEx...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#MacOSX->a KMStorage #all->a KMStorage )


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(417864704)
		category: 	a KMCategory
		morph: 	a RubEditingArea(417864704)


[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		aTarget: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(a KMCategoryBinding(#RubSmalltalkEditor) a KMCategoryBinding(#Mo...etc...
		morph: 	a RubEditingArea(417864704)
		directKeymaps: 	a KMCategory



--- The full stack ---
Pile(ProtoObject)>>doesNotUnderstand: #instVarNamed:
Pile(Object)>>exoInspect
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
InstanceVariableNotFound: className not found in une Pile, de taille: 4 contenant: 1 objets : (33 nil nil nil )
10 October 2022 3:26:23.490454 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
StackToRegisterMappingCogit * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
v9.0.18 - Commit: 7249c170 - Date: 2022-09-02 14:31:12 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

[ InstanceVariableNotFound signalFor: aString asString ] in Pile(Object)>>instVarNamed:
	Receiver: une Pile, de taille: 4 contenant: 1 objets : (33 nil nil nil )
	Arguments and temporary variables: 
		aString: 	#className
	Receiver's instance variables: 
		contenu: 	#(33 nil nil nil)
		index: 	1
		capacite: 	4


LayoutClassScope(LayoutAbstractScope)>>resolveSlot:ifFound:ifNone:
	Receiver: a LayoutClassScope(#contenu => InstanceVariableSlot #index => InstanceVariableSlot #capaci...etc...
	Arguments and temporary variables: 
		aName: 	#className
		foundBlock: 	[ :slot | slot read: self ]
		exceptionBlock: 	[ InstanceVariableNotFound signalFor: aString asString ]
	Receiver's instance variables: 
		parentScope: 	a LayoutClassScope()


FixedLayout(PointerLayout)>>resolveSlot:ifFound:ifNone:
	Receiver: a FixedLayout
	Arguments and temporary variables: 
		aName: 	#className
		foundBlock: 	[ :slot | slot read: self ]
		noneBlock: 	[ InstanceVariableNotFound signalFor: aString asString ]
	Receiver's instance variables: 
		host: 	Pile
		slotScope: 	a LayoutClassScope(#contenu => InstanceVariableSlot #index => Instan...etc...


Pile class(ClassDescription)>>slotNamed:ifFound:ifNone:
	Receiver: Pile
	Arguments and temporary variables: 
		aName: 	#className
		foundBlock: 	[ :slot | slot read: self ]
		exceptionBlock: 	[ InstanceVariableNotFound signalFor: aString asString ]
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#grow->Pile>>#grow #initialize:->Pile>>#initiali...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#Pile
		classPool: 	a Dictionary(#tailleDefaut->nil )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#HAI914I


Pile(Object)>>instVarNamed:
	Receiver: une Pile, de taille: 4 contenant: 1 objets : (33 nil nil nil )
	Arguments and temporary variables: 
		aString: 	#className
	Receiver's instance variables: 
		contenu: 	#(33 nil nil nil)
		index: 	1
		capacite: 	4


Pile(Object)>>exoInspect
	Receiver: une Pile, de taille: 4 contenant: 1 objets : (33 nil nil nil )
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		contenu: 	#(33 nil nil nil)
		index: 	1
		capacite: 	4


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ p exoInspect
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ p exoInspect
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'p exoInspect.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#p->une Pile, de taille: 4 contenant: 1 objets : (33 ...etc...
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (31 to: 43) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'p := Pile new: 4.
p push: 33.
p exoInspect.' ]...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#p->une Pile, de taille: 4 contenant: 1 objets : (33 ...etc...
		aString: 	'p exoInspect.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (31 to: 43) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'p := Pile new: 4.
p push: 33.
p exoInspect.' ]...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aString: 	'p exoInspect.'
		aBlock: 	[ :result | 
		self printObject: result ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
		self printObject: result ]
		selection: 	'p exoInspect.'
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand>>execute
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Print it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodePrintItCommand
		iconProvider: 	nil
		iconName: 	#smallPrintIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(417864704)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(417864704)
		secondArg: 	a RubEditingArea(417864704)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(417864704)
		secondArg: 	a RubEditingArea(417864704)
		thirdArg: 	[keyDown '<Cmd-p>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(417864704)
		category: 	a KMCategory
		morph: 	a RubEditingArea(417864704)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				i...etc...
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#MacOSX->a KMStorage #all->a KMStorage )



--- The full stack ---
[ InstanceVariableNotFound signalFor: aString asString ] in Pile(Object)>>instVarNamed:
LayoutClassScope(LayoutAbstractScope)>>resolveSlot:ifFound:ifNone:
FixedLayout(PointerLayout)>>resolveSlot:ifFound:ifNone:
Pile class(ClassDescription)>>slotNamed:ifFound:ifNone:
Pile(Object)>>instVarNamed:
Pile(Object)>>exoInspect
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
InstanceVariableNotFound: className not found in une Pile, de taille: 4 contenant: 1 objets : (33 nil nil nil )
10 October 2022 3:26:23.518541 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
StackToRegisterMappingCogit * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
v9.0.18 - Commit: 7249c170 - Date: 2022-09-02 14:31:12 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

[ InstanceVariableNotFound signalFor: aString asString ] in Pile(Object)>>instVarNamed:
	Receiver: une Pile, de taille: 4 contenant: 1 objets : (33 nil nil nil )
	Arguments and temporary variables: 
		aString: 	#className
	Receiver's instance variables: 
		contenu: 	#(33 nil nil nil)
		index: 	1
		capacite: 	4


LayoutClassScope(LayoutAbstractScope)>>resolveSlot:ifFound:ifNone:
	Receiver: a LayoutClassScope(#contenu => InstanceVariableSlot #index => InstanceVariableSlot #capaci...etc...
	Arguments and temporary variables: 
		aName: 	#className
		foundBlock: 	[ :slot | slot read: self ]
		exceptionBlock: 	[ InstanceVariableNotFound signalFor: aString asString ]
	Receiver's instance variables: 
		parentScope: 	a LayoutClassScope()


FixedLayout(PointerLayout)>>resolveSlot:ifFound:ifNone:
	Receiver: a FixedLayout
	Arguments and temporary variables: 
		aName: 	#className
		foundBlock: 	[ :slot | slot read: self ]
		noneBlock: 	[ InstanceVariableNotFound signalFor: aString asString ]
	Receiver's instance variables: 
		host: 	Pile
		slotScope: 	a LayoutClassScope(#contenu => InstanceVariableSlot #index => Instan...etc...


Pile class(ClassDescription)>>slotNamed:ifFound:ifNone:
	Receiver: Pile
	Arguments and temporary variables: 
		aName: 	#className
		foundBlock: 	[ :slot | slot read: self ]
		exceptionBlock: 	[ InstanceVariableNotFound signalFor: aString asString ]
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#grow->Pile>>#grow #initialize:->Pile>>#initiali...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#Pile
		classPool: 	a Dictionary(#tailleDefaut->nil )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#HAI914I


Pile(Object)>>instVarNamed:
	Receiver: une Pile, de taille: 4 contenant: 1 objets : (33 nil nil nil )
	Arguments and temporary variables: 
		aString: 	#className
	Receiver's instance variables: 
		contenu: 	#(33 nil nil nil)
		index: 	1
		capacite: 	4


Pile(Object)>>exoInspect
	Receiver: une Pile, de taille: 4 contenant: 1 objets : (33 nil nil nil )
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		contenu: 	#(33 nil nil nil)
		index: 	1
		capacite: 	4


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ p exoInspect
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ p exoInspect
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'p exoInspect.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#p->une Pile, de taille: 4 contenant: 1 objets : (33 ...etc...
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (31 to: 43) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'p := Pile new: 4.
p push: 33.
p exoInspect.' ]...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#p->une Pile, de taille: 4 contenant: 1 objets : (33 ...etc...
		aString: 	'p exoInspect.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (31 to: 43) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'p := Pile new: 4.
p push: 33.
p exoInspect.' ]...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aString: 	'p exoInspect.'
		aBlock: 	[ :result | 
		self printObject: result ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
		self printObject: result ]
		selection: 	'p exoInspect.'
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand>>execute
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Print it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodePrintItCommand
		iconProvider: 	nil
		iconName: 	#smallPrintIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(417864704)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(417864704)
		secondArg: 	a RubEditingArea(417864704)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(417864704)
		secondArg: 	a RubEditingArea(417864704)
		thirdArg: 	[keyDown '<Cmd-p>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(417864704)
		category: 	a KMCategory
		morph: 	a RubEditingArea(417864704)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				i...etc...
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#MacOSX->a KMStorage #all->a KMStorage )



--- The full stack ---
[ InstanceVariableNotFound signalFor: aString asString ] in Pile(Object)>>instVarNamed:
LayoutClassScope(LayoutAbstractScope)>>resolveSlot:ifFound:ifNone:
FixedLayout(PointerLayout)>>resolveSlot:ifFound:ifNone:
Pile class(ClassDescription)>>slotNamed:ifFound:ifNone:
Pile(Object)>>instVarNamed:
Pile(Object)>>exoInspect
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of ProtoObject did not understand #instVarNamed:
10 October 2022 3:26:46.297603 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
StackToRegisterMappingCogit * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
v9.0.18 - Commit: 7249c170 - Date: 2022-09-02 14:31:12 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

Pile(ProtoObject)>>doesNotUnderstand: #instVarNamed:
	Receiver: une Pile, de taille: 4 contenant: 1 objets : (33 nil nil nil )
	Arguments and temporary variables: 
		aMessage: 	instVarNamed: #className
	Receiver's instance variables: 
		contenu: 	#(33 nil nil nil)
		index: 	1
		capacite: 	4


Pile(Object)>>exoInspect
	Receiver: une Pile, de taille: 4 contenant: 1 objets : (33 nil nil nil )
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		contenu: 	#(33 nil nil nil)
		index: 	1
		capacite: 	4


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ p exoInspect
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ p exoInspect
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'p exoInspect.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#p->une Pile, de taille: 4 contenant: 1 objets : (33 ...etc...
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (31 to: 43) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'p := Pile new: 4.
p push: 33.
p exoInspect.' ]...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#p->une Pile, de taille: 4 contenant: 1 objets : (33 ...etc...
		aString: 	'p exoInspect.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (31 to: 43) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'p := Pile new: 4.
p push: 33.
p exoInspect.' ]...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aString: 	'p exoInspect.'
		aBlock: 	[ :result | 
		self printObject: result ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
		self printObject: result ]
		selection: 	'p exoInspect.'
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand>>execute
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Print it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodePrintItCommand
		iconProvider: 	nil
		iconName: 	#smallPrintIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(417864704)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(417864704)
		secondArg: 	a RubEditingArea(417864704)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(417864704)
		secondArg: 	a RubEditingArea(417864704)
		thirdArg: 	[keyDown '<Cmd-p>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(417864704)
		category: 	a KMCategory
		morph: 	a RubEditingArea(417864704)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				i...etc...
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#MacOSX->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCm...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListen...etc...
		index: 	9
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				if...etc...
	Receiver's instance variables: 
		tally: 	31
		array: 	an Array(nil nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeEx...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#MacOSX->a KMStorage #all->a KMStorage )


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(417864704)
		category: 	a KMCategory
		morph: 	a RubEditingArea(417864704)


[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		aTarget: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(a KMCategoryBinding(#RubSmalltalkEditor) a KMCategoryBinding(#Mo...etc...
		morph: 	a RubEditingArea(417864704)
		directKeymaps: 	a KMCategory



--- The full stack ---
Pile(ProtoObject)>>doesNotUnderstand: #instVarNamed:
Pile(Object)>>exoInspect
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of ProtoObject did not understand #instVarNamed:
10 October 2022 3:26:46.320059 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
StackToRegisterMappingCogit * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
v9.0.18 - Commit: 7249c170 - Date: 2022-09-02 14:31:12 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

Pile(ProtoObject)>>doesNotUnderstand: #instVarNamed:
	Receiver: une Pile, de taille: 4 contenant: 1 objets : (33 nil nil nil )
	Arguments and temporary variables: 
		aMessage: 	instVarNamed: #className
	Receiver's instance variables: 
		contenu: 	#(33 nil nil nil)
		index: 	1
		capacite: 	4


Pile(Object)>>exoInspect
	Receiver: une Pile, de taille: 4 contenant: 1 objets : (33 nil nil nil )
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		contenu: 	#(33 nil nil nil)
		index: 	1
		capacite: 	4


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ p exoInspect
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ p exoInspect
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'p exoInspect.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#p->une Pile, de taille: 4 contenant: 1 objets : (33 ...etc...
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (31 to: 43) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'p := Pile new: 4.
p push: 33.
p exoInspect.' ]...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#p->une Pile, de taille: 4 contenant: 1 objets : (33 ...etc...
		aString: 	'p exoInspect.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (31 to: 43) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'p := Pile new: 4.
p push: 33.
p exoInspect.' ]...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aString: 	'p exoInspect.'
		aBlock: 	[ :result | 
		self printObject: result ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
		self printObject: result ]
		selection: 	'p exoInspect.'
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand>>execute
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Print it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodePrintItCommand
		iconProvider: 	nil
		iconName: 	#smallPrintIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(417864704)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(417864704)
		secondArg: 	a RubEditingArea(417864704)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(417864704)
		secondArg: 	a RubEditingArea(417864704)
		thirdArg: 	[keyDown '<Cmd-p>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(417864704)
		category: 	a KMCategory
		morph: 	a RubEditingArea(417864704)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				i...etc...
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#MacOSX->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCm...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListen...etc...
		index: 	9
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				if...etc...
	Receiver's instance variables: 
		tally: 	31
		array: 	an Array(nil nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeEx...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#MacOSX->a KMStorage #all->a KMStorage )


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(417864704)
		category: 	a KMCategory
		morph: 	a RubEditingArea(417864704)


[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		aTarget: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(a KMCategoryBinding(#RubSmalltalkEditor) a KMCategoryBinding(#Mo...etc...
		morph: 	a RubEditingArea(417864704)
		directKeymaps: 	a KMCategory



--- The full stack ---
Pile(ProtoObject)>>doesNotUnderstand: #instVarNamed:
Pile(Object)>>exoInspect
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
InstanceVariableNotFound: Pile not found in une Pile, de taille: 4 contenant: 1 objets : (33 nil nil nil )
10 October 2022 3:30:49.02587 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
StackToRegisterMappingCogit * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
v9.0.18 - Commit: 7249c170 - Date: 2022-09-02 14:31:12 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

[ InstanceVariableNotFound signalFor: aString asString ] in Pile(Object)>>instVarNamed:
	Receiver: une Pile, de taille: 4 contenant: 1 objets : (33 nil nil nil )
	Arguments and temporary variables: 
		aString: 	'Pile'
	Receiver's instance variables: 
		contenu: 	#(33 nil nil nil)
		index: 	1
		capacite: 	4


LayoutClassScope(LayoutAbstractScope)>>resolveSlot:ifFound:ifNone:
	Receiver: a LayoutClassScope(#contenu => InstanceVariableSlot #index => InstanceVariableSlot #capaci...etc...
	Arguments and temporary variables: 
		aName: 	#Pile
		foundBlock: 	[ :slot | slot read: self ]
		exceptionBlock: 	[ InstanceVariableNotFound signalFor: aString asString ]
	Receiver's instance variables: 
		parentScope: 	a LayoutClassScope()


FixedLayout(PointerLayout)>>resolveSlot:ifFound:ifNone:
	Receiver: a FixedLayout
	Arguments and temporary variables: 
		aName: 	#Pile
		foundBlock: 	[ :slot | slot read: self ]
		noneBlock: 	[ InstanceVariableNotFound signalFor: aString asString ]
	Receiver's instance variables: 
		host: 	Pile
		slotScope: 	a LayoutClassScope(#contenu => InstanceVariableSlot #index => Instan...etc...


Pile class(ClassDescription)>>slotNamed:ifFound:ifNone:
	Receiver: Pile
	Arguments and temporary variables: 
		aName: 	'Pile'
		foundBlock: 	[ :slot | slot read: self ]
		exceptionBlock: 	[ InstanceVariableNotFound signalFor: aString asString ]
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#grow->Pile>>#grow #initialize:->Pile>>#initiali...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#Pile
		classPool: 	a Dictionary(#tailleDefaut->nil )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#HAI914I


Pile(Object)>>instVarNamed:
	Receiver: une Pile, de taille: 4 contenant: 1 objets : (33 nil nil nil )
	Arguments and temporary variables: 
		aString: 	'Pile'
	Receiver's instance variables: 
		contenu: 	#(33 nil nil nil)
		index: 	1
		capacite: 	4


Pile(Object)>>exoInspect
	Receiver: une Pile, de taille: 4 contenant: 1 objets : (33 nil nil nil )
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		contenu: 	#(33 nil nil nil)
		index: 	1
		capacite: 	4


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ p exoInspect
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ p exoInspect
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'p exoInspect.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#p->une Pile, de taille: 4 contenant: 1 objets : (33 ...etc...
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (31 to: 43) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'p := Pile new: 4.
p push: 33.
p exoInspect.' ]...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#p->une Pile, de taille: 4 contenant: 1 objets : (33 ...etc...
		aString: 	'p exoInspect.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (31 to: 43) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'p := Pile new: 4.
p push: 33.
p exoInspect.' ]...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aString: 	'p exoInspect.'
		aBlock: 	[ :result | 
		self printObject: result ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
		self printObject: result ]
		selection: 	'p exoInspect.'
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand>>execute
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Print it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodePrintItCommand
		iconProvider: 	nil
		iconName: 	#smallPrintIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(417864704)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(417864704)
		secondArg: 	a RubEditingArea(417864704)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(417864704)
		secondArg: 	a RubEditingArea(417864704)
		thirdArg: 	[keyDown '<Cmd-p>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(417864704)
		category: 	a KMCategory
		morph: 	a RubEditingArea(417864704)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				i...etc...
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#MacOSX->a KMStorage #all->a KMStorage )



--- The full stack ---
[ InstanceVariableNotFound signalFor: aString asString ] in Pile(Object)>>instVarNamed:
LayoutClassScope(LayoutAbstractScope)>>resolveSlot:ifFound:ifNone:
FixedLayout(PointerLayout)>>resolveSlot:ifFound:ifNone:
Pile class(ClassDescription)>>slotNamed:ifFound:ifNone:
Pile(Object)>>instVarNamed:
Pile(Object)>>exoInspect
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
InstanceVariableNotFound: Pile not found in une Pile, de taille: 4 contenant: 1 objets : (33 nil nil nil )
10 October 2022 3:30:49.04825 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
StackToRegisterMappingCogit * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
v9.0.18 - Commit: 7249c170 - Date: 2022-09-02 14:31:12 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

[ InstanceVariableNotFound signalFor: aString asString ] in Pile(Object)>>instVarNamed:
	Receiver: une Pile, de taille: 4 contenant: 1 objets : (33 nil nil nil )
	Arguments and temporary variables: 
		aString: 	'Pile'
	Receiver's instance variables: 
		contenu: 	#(33 nil nil nil)
		index: 	1
		capacite: 	4


LayoutClassScope(LayoutAbstractScope)>>resolveSlot:ifFound:ifNone:
	Receiver: a LayoutClassScope(#contenu => InstanceVariableSlot #index => InstanceVariableSlot #capaci...etc...
	Arguments and temporary variables: 
		aName: 	#Pile
		foundBlock: 	[ :slot | slot read: self ]
		exceptionBlock: 	[ InstanceVariableNotFound signalFor: aString asString ]
	Receiver's instance variables: 
		parentScope: 	a LayoutClassScope()


FixedLayout(PointerLayout)>>resolveSlot:ifFound:ifNone:
	Receiver: a FixedLayout
	Arguments and temporary variables: 
		aName: 	#Pile
		foundBlock: 	[ :slot | slot read: self ]
		noneBlock: 	[ InstanceVariableNotFound signalFor: aString asString ]
	Receiver's instance variables: 
		host: 	Pile
		slotScope: 	a LayoutClassScope(#contenu => InstanceVariableSlot #index => Instan...etc...


Pile class(ClassDescription)>>slotNamed:ifFound:ifNone:
	Receiver: Pile
	Arguments and temporary variables: 
		aName: 	'Pile'
		foundBlock: 	[ :slot | slot read: self ]
		exceptionBlock: 	[ InstanceVariableNotFound signalFor: aString asString ]
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#grow->Pile>>#grow #initialize:->Pile>>#initiali...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#Pile
		classPool: 	a Dictionary(#tailleDefaut->nil )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#HAI914I


Pile(Object)>>instVarNamed:
	Receiver: une Pile, de taille: 4 contenant: 1 objets : (33 nil nil nil )
	Arguments and temporary variables: 
		aString: 	'Pile'
	Receiver's instance variables: 
		contenu: 	#(33 nil nil nil)
		index: 	1
		capacite: 	4


Pile(Object)>>exoInspect
	Receiver: une Pile, de taille: 4 contenant: 1 objets : (33 nil nil nil )
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		contenu: 	#(33 nil nil nil)
		index: 	1
		capacite: 	4


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ p exoInspect
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ p exoInspect
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'p exoInspect.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#p->une Pile, de taille: 4 contenant: 1 objets : (33 ...etc...
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (31 to: 43) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'p := Pile new: 4.
p push: 33.
p exoInspect.' ]...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#p->une Pile, de taille: 4 contenant: 1 objets : (33 ...etc...
		aString: 	'p exoInspect.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (31 to: 43) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'p := Pile new: 4.
p push: 33.
p exoInspect.' ]...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aString: 	'p exoInspect.'
		aBlock: 	[ :result | 
		self printObject: result ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
		self printObject: result ]
		selection: 	'p exoInspect.'
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand>>execute
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Print it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodePrintItCommand
		iconProvider: 	nil
		iconName: 	#smallPrintIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(417864704)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(417864704)
		secondArg: 	a RubEditingArea(417864704)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(417864704)
		secondArg: 	a RubEditingArea(417864704)
		thirdArg: 	[keyDown '<Cmd-p>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(417864704)
		category: 	a KMCategory
		morph: 	a RubEditingArea(417864704)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				i...etc...
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#MacOSX->a KMStorage #all->a KMStorage )



--- The full stack ---
[ InstanceVariableNotFound signalFor: aString asString ] in Pile(Object)>>instVarNamed:
LayoutClassScope(LayoutAbstractScope)>>resolveSlot:ifFound:ifNone:
FixedLayout(PointerLayout)>>resolveSlot:ifFound:ifNone:
Pile class(ClassDescription)>>slotNamed:ifFound:ifNone:
Pile(Object)>>instVarNamed:
Pile(Object)>>exoInspect
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of Pile did not understand #instVarNames
10 October 2022 3:50:28.571523 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
StackToRegisterMappingCogit * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
v9.0.18 - Commit: 7249c170 - Date: 2022-09-02 14:31:12 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

Pile(Object)>>doesNotUnderstand: #instVarNames
	Receiver: une Pile, de taille: 4 contenant: 1 objets : (33 nil nil nil )
	Arguments and temporary variables: 
		aMessage: 	instVarNames
		exception: 	Instance of Pile did not understand #instVarNames
		resumeValue: 	nil
	Receiver's instance variables: 
		contenu: 	#(33 nil nil nil)
		index: 	1
		capacite: 	4


Pile(Object)>>exoInspect
	Receiver: une Pile, de taille: 4 contenant: 1 objets : (33 nil nil nil )
	Arguments and temporary variables: 
		instVar: 	nil
		listVar: 	nil
	Receiver's instance variables: 
		contenu: 	#(33 nil nil nil)
		index: 	1
		capacite: 	4


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ p exoInspect
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ p exoInspect
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'p exoInspect.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#p->une Pile, de taille: 4 contenant: 1 objets : (33 ...etc...
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (31 to: 43) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'p := Pile new: 4.
p push: 33.
p exoInspect.' ]...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#p->une Pile, de taille: 4 contenant: 1 objets : (33 ...etc...
		aString: 	'p exoInspect.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (31 to: 43) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'p := Pile new: 4.
p push: 33.
p exoInspect.' ]...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aString: 	'p exoInspect.'
		aBlock: 	[ :result | 
		self printObject: result ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
		self printObject: result ]
		selection: 	'p exoInspect.'
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand>>execute
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Print it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodePrintItCommand
		iconProvider: 	nil
		iconName: 	#smallPrintIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(417864704)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(417864704)
		secondArg: 	a RubEditingArea(417864704)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(417864704)
		secondArg: 	a RubEditingArea(417864704)
		thirdArg: 	[keyDown '<Cmd-p>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(417864704)
		category: 	a KMCategory
		morph: 	a RubEditingArea(417864704)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				i...etc...
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#MacOSX->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCm...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListen...etc...
		index: 	9
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				if...etc...
	Receiver's instance variables: 
		tally: 	31
		array: 	an Array(nil nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeEx...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#MacOSX->a KMStorage #all->a KMStorage )


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(417864704)
		category: 	a KMCategory
		morph: 	a RubEditingArea(417864704)


[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		aTarget: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(a KMCategoryBinding(#RubSmalltalkEditor) a KMCategoryBinding(#Mo...etc...
		morph: 	a RubEditingArea(417864704)
		directKeymaps: 	a KMCategory



--- The full stack ---
Pile(Object)>>doesNotUnderstand: #instVarNames
Pile(Object)>>exoInspect
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of Pile did not understand #instVarNames
10 October 2022 3:50:28.59757 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
StackToRegisterMappingCogit * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
v9.0.18 - Commit: 7249c170 - Date: 2022-09-02 14:31:12 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

Pile(Object)>>doesNotUnderstand: #instVarNames
	Receiver: une Pile, de taille: 4 contenant: 1 objets : (33 nil nil nil )
	Arguments and temporary variables: 
		aMessage: 	instVarNames
		exception: 	Instance of Pile did not understand #instVarNames
		resumeValue: 	nil
	Receiver's instance variables: 
		contenu: 	#(33 nil nil nil)
		index: 	1
		capacite: 	4


Pile(Object)>>exoInspect
	Receiver: une Pile, de taille: 4 contenant: 1 objets : (33 nil nil nil )
	Arguments and temporary variables: 
		instVar: 	nil
		listVar: 	nil
	Receiver's instance variables: 
		contenu: 	#(33 nil nil nil)
		index: 	1
		capacite: 	4


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ p exoInspect
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ p exoInspect
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'p exoInspect.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#p->une Pile, de taille: 4 contenant: 1 objets : (33 ...etc...
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (31 to: 43) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'p := Pile new: 4.
p push: 33.
p exoInspect.' ]...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#p->une Pile, de taille: 4 contenant: 1 objets : (33 ...etc...
		aString: 	'p exoInspect.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (31 to: 43) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'p := Pile new: 4.
p push: 33.
p exoInspect.' ]...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aString: 	'p exoInspect.'
		aBlock: 	[ :result | 
		self printObject: result ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
		self printObject: result ]
		selection: 	'p exoInspect.'
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand>>execute
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Print it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodePrintItCommand
		iconProvider: 	nil
		iconName: 	#smallPrintIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(417864704)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(417864704)
		secondArg: 	a RubEditingArea(417864704)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(417864704)
		secondArg: 	a RubEditingArea(417864704)
		thirdArg: 	[keyDown '<Cmd-p>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(417864704)
		category: 	a KMCategory
		morph: 	a RubEditingArea(417864704)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				i...etc...
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#MacOSX->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCm...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListen...etc...
		index: 	9
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				if...etc...
	Receiver's instance variables: 
		tally: 	31
		array: 	an Array(nil nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeEx...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#MacOSX->a KMStorage #all->a KMStorage )


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(417864704)
		category: 	a KMCategory
		morph: 	a RubEditingArea(417864704)


[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		aTarget: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(a KMCategoryBinding(#RubSmalltalkEditor) a KMCategoryBinding(#Mo...etc...
		morph: 	a RubEditingArea(417864704)
		directKeymaps: 	a KMCategory



--- The full stack ---
Pile(Object)>>doesNotUnderstand: #instVarNames
Pile(Object)>>exoInspect
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of Array did not understand #pop
10 October 2022 3:51:20.348812 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
StackToRegisterMappingCogit * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
v9.0.18 - Commit: 7249c170 - Date: 2022-09-02 14:31:12 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

Array(Object)>>doesNotUnderstand: #pop
	Receiver: #(#contenu #index #capacite)
	Arguments and temporary variables: 
		aMessage: 	pop
		exception: 	Instance of Array did not understand #pop
		resumeValue: 	nil
	Receiver's instance variables: 
#(#contenu #index #capacite)

Pile(Object)>>exoInspect
	Receiver: une Pile, de taille: 4 contenant: 1 objets : (33 nil nil nil )
	Arguments and temporary variables: 
		instVar: 	nil
		listVar: 	#(#contenu #index #capacite)
	Receiver's instance variables: 
		contenu: 	#(33 nil nil nil)
		index: 	1
		capacite: 	4


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ p exoInspect
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ p exoInspect
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'p exoInspect.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#p->une Pile, de taille: 4 contenant: 1 objets : (33 ...etc...
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (31 to: 43) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'p := Pile new: 4.
p push: 33.
p exoInspect.' ]...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#p->une Pile, de taille: 4 contenant: 1 objets : (33 ...etc...
		aString: 	'p exoInspect.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (31 to: 43) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'p := Pile new: 4.
p push: 33.
p exoInspect.' ]...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aString: 	'p exoInspect.'
		aBlock: 	[ :result | 
		self printObject: result ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
		self printObject: result ]
		selection: 	'p exoInspect.'
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand>>execute
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Print it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodePrintItCommand
		iconProvider: 	nil
		iconName: 	#smallPrintIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(417864704)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(417864704)
		secondArg: 	a RubEditingArea(417864704)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(417864704)
		secondArg: 	a RubEditingArea(417864704)
		thirdArg: 	[keyDown '<Cmd-p>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(417864704)
		category: 	a KMCategory
		morph: 	a RubEditingArea(417864704)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				i...etc...
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#MacOSX->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCm...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListen...etc...
		index: 	9
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				if...etc...
	Receiver's instance variables: 
		tally: 	31
		array: 	an Array(nil nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeEx...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#MacOSX->a KMStorage #all->a KMStorage )


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(417864704)
		category: 	a KMCategory
		morph: 	a RubEditingArea(417864704)


[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		aTarget: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(a KMCategoryBinding(#RubSmalltalkEditor) a KMCategoryBinding(#Mo...etc...
		morph: 	a RubEditingArea(417864704)
		directKeymaps: 	a KMCategory



--- The full stack ---
Array(Object)>>doesNotUnderstand: #pop
Pile(Object)>>exoInspect
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of Array did not understand #pop
10 October 2022 3:51:20.371373 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
StackToRegisterMappingCogit * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
v9.0.18 - Commit: 7249c170 - Date: 2022-09-02 14:31:12 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

Array(Object)>>doesNotUnderstand: #pop
	Receiver: #(#contenu #index #capacite)
	Arguments and temporary variables: 
		aMessage: 	pop
		exception: 	Instance of Array did not understand #pop
		resumeValue: 	nil
	Receiver's instance variables: 
#(#contenu #index #capacite)

Pile(Object)>>exoInspect
	Receiver: une Pile, de taille: 4 contenant: 1 objets : (33 nil nil nil )
	Arguments and temporary variables: 
		instVar: 	nil
		listVar: 	#(#contenu #index #capacite)
	Receiver's instance variables: 
		contenu: 	#(33 nil nil nil)
		index: 	1
		capacite: 	4


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ p exoInspect
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ p exoInspect
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'p exoInspect.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#p->une Pile, de taille: 4 contenant: 1 objets : (33 ...etc...
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (31 to: 43) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'p := Pile new: 4.
p push: 33.
p exoInspect.' ]...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#p->une Pile, de taille: 4 contenant: 1 objets : (33 ...etc...
		aString: 	'p exoInspect.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (31 to: 43) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'p := Pile new: 4.
p push: 33.
p exoInspect.' ]...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aString: 	'p exoInspect.'
		aBlock: 	[ :result | 
		self printObject: result ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
		self printObject: result ]
		selection: 	'p exoInspect.'
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand>>execute
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Print it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodePrintItCommand
		iconProvider: 	nil
		iconName: 	#smallPrintIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(417864704)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(417864704)
		secondArg: 	a RubEditingArea(417864704)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(417864704)
		secondArg: 	a RubEditingArea(417864704)
		thirdArg: 	[keyDown '<Cmd-p>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(417864704)
		category: 	a KMCategory
		morph: 	a RubEditingArea(417864704)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				i...etc...
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#MacOSX->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCm...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListen...etc...
		index: 	9
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				if...etc...
	Receiver's instance variables: 
		tally: 	31
		array: 	an Array(nil nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeEx...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#MacOSX->a KMStorage #all->a KMStorage )


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(417864704)
		category: 	a KMCategory
		morph: 	a RubEditingArea(417864704)


[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		aTarget: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(a KMCategoryBinding(#RubSmalltalkEditor) a KMCategoryBinding(#Mo...etc...
		morph: 	a RubEditingArea(417864704)
		directKeymaps: 	a KMCategory



--- The full stack ---
Array(Object)>>doesNotUnderstand: #pop
Pile(Object)>>exoInspect
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of FullBlockClosure did not understand #asSymbol
10 October 2022 3:54:31.624309 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
StackToRegisterMappingCogit * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
v9.0.18 - Commit: 7249c170 - Date: 2022-09-02 14:31:12 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

FullBlockClosure(Object)>>doesNotUnderstand: #asSymbol
	Receiver: [instVar := listVar pop ]
	Arguments and temporary variables: 
		aMessage: 	asSymbol
		exception: 	Instance of FullBlockClosure did not understand #asSymbol
		resumeValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[ ^ self instVarNamed: [instVar := listVar pop ]] in Pile(Object)...etc...
		startpc: 	a CompiledBlock: [instVar := listVar pop ]
		numArgs: 	0
		receiver: 	une Pile, de taille: 4 contenant: 1 objets : (33 nil nil nil )


Pile class(ClassDescription)>>slotNamed:ifFound:ifNone:
	Receiver: Pile
	Arguments and temporary variables: 
		aName: 	[instVar := listVar pop ]
		foundBlock: 	[ :slot | slot read: self ]
		exceptionBlock: 	[ InstanceVariableNotFound signalFor: aString asString ]
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#grow->Pile>>#grow #initialize:->Pile>>#initiali...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#Pile
		classPool: 	a Dictionary(#tailleDefaut->nil )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#HAI914I


Pile(Object)>>instVarNamed:
	Receiver: une Pile, de taille: 4 contenant: 1 objets : (33 nil nil nil )
	Arguments and temporary variables: 
		aString: 	[instVar := listVar pop ]
	Receiver's instance variables: 
		contenu: 	#(33 nil nil nil)
		index: 	1
		capacite: 	4


[ ^ self instVarNamed: [instVar := listVar pop ]] in Pile(Object)>>exoInspect
	Receiver: une Pile, de taille: 4 contenant: 1 objets : (33 nil nil nil )
	Arguments and temporary variables: 
		listVar: 	#(#contenu #index #capacite)
		instVar: 	nil
	Receiver's instance variables: 
		contenu: 	#(33 nil nil nil)
		index: 	1
		capacite: 	4


FullBlockClosure(BlockClosure)>>repeatUntil:
	Receiver: [ ^ self instVarNamed: [instVar := listVar pop ]]
	Arguments and temporary variables: 
		condition: 	[ listVar isNotEmpty  ]
	Receiver's instance variables: 
		outerContext: 	Pile(Object)>>exoInspect
		startpc: 	a CompiledBlock: [ ^ self instVarNamed: [instVar := listVar pop ]]
		numArgs: 	0
		receiver: 	une Pile, de taille: 4 contenant: 1 objets : (33 nil nil nil )


Pile(Object)>>exoInspect
	Receiver: une Pile, de taille: 4 contenant: 1 objets : (33 nil nil nil )
	Arguments and temporary variables: 
		instVar: 	nil
		listVar: 	#(#contenu #index #capacite)
	Receiver's instance variables: 
		contenu: 	#(33 nil nil nil)
		index: 	1
		capacite: 	4


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ p exoInspect
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ p exoInspect
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'p exoInspect.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#p->une Pile, de taille: 4 contenant: 1 objets : (33 ...etc...
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (31 to: 43) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'p := Pile new: 4.
p push: 33.
p exoInspect.' ]...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#p->une Pile, de taille: 4 contenant: 1 objets : (33 ...etc...
		aString: 	'p exoInspect.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (31 to: 43) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'p := Pile new: 4.
p push: 33.
p exoInspect.' ]...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aString: 	'p exoInspect.'
		aBlock: 	[ :result | 
		self printObject: result ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
		self printObject: result ]
		selection: 	'p exoInspect.'
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand>>execute
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Print it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodePrintItCommand
		iconProvider: 	nil
		iconName: 	#smallPrintIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(417864704)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(417864704)
		secondArg: 	a RubEditingArea(417864704)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(417864704)
		secondArg: 	a RubEditingArea(417864704)
		thirdArg: 	[keyDown '<Cmd-p>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(417864704)
		category: 	a KMCategory
		morph: 	a RubEditingArea(417864704)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				i...etc...
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#MacOSX->a KMStorage #all->a KMStorage )



--- The full stack ---
FullBlockClosure(Object)>>doesNotUnderstand: #asSymbol
Pile class(ClassDescription)>>slotNamed:ifFound:ifNone:
Pile(Object)>>instVarNamed:
[ ^ self instVarNamed: [instVar := listVar pop ]] in Pile(Object)>>exoInspect
FullBlockClosure(BlockClosure)>>repeatUntil:
Pile(Object)>>exoInspect
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of FullBlockClosure did not understand #asSymbol
10 October 2022 3:54:31.64857 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
StackToRegisterMappingCogit * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
v9.0.18 - Commit: 7249c170 - Date: 2022-09-02 14:31:12 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

FullBlockClosure(Object)>>doesNotUnderstand: #asSymbol
	Receiver: [instVar := listVar pop ]
	Arguments and temporary variables: 
		aMessage: 	asSymbol
		exception: 	Instance of FullBlockClosure did not understand #asSymbol
		resumeValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[ ^ self instVarNamed: [instVar := listVar pop ]] in Pile(Object)...etc...
		startpc: 	a CompiledBlock: [instVar := listVar pop ]
		numArgs: 	0
		receiver: 	une Pile, de taille: 4 contenant: 1 objets : (33 nil nil nil )


Pile class(ClassDescription)>>slotNamed:ifFound:ifNone:
	Receiver: Pile
	Arguments and temporary variables: 
		aName: 	[instVar := listVar pop ]
		foundBlock: 	[ :slot | slot read: self ]
		exceptionBlock: 	[ InstanceVariableNotFound signalFor: aString asString ]
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#grow->Pile>>#grow #initialize:->Pile>>#initiali...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#Pile
		classPool: 	a Dictionary(#tailleDefaut->nil )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#HAI914I


Pile(Object)>>instVarNamed:
	Receiver: une Pile, de taille: 4 contenant: 1 objets : (33 nil nil nil )
	Arguments and temporary variables: 
		aString: 	[instVar := listVar pop ]
	Receiver's instance variables: 
		contenu: 	#(33 nil nil nil)
		index: 	1
		capacite: 	4


[ ^ self instVarNamed: [instVar := listVar pop ]] in Pile(Object)>>exoInspect
	Receiver: une Pile, de taille: 4 contenant: 1 objets : (33 nil nil nil )
	Arguments and temporary variables: 
		listVar: 	#(#contenu #index #capacite)
		instVar: 	nil
	Receiver's instance variables: 
		contenu: 	#(33 nil nil nil)
		index: 	1
		capacite: 	4


FullBlockClosure(BlockClosure)>>repeatUntil:
	Receiver: [ ^ self instVarNamed: [instVar := listVar pop ]]
	Arguments and temporary variables: 
		condition: 	[ listVar isNotEmpty  ]
	Receiver's instance variables: 
		outerContext: 	Pile(Object)>>exoInspect
		startpc: 	a CompiledBlock: [ ^ self instVarNamed: [instVar := listVar pop ]]
		numArgs: 	0
		receiver: 	une Pile, de taille: 4 contenant: 1 objets : (33 nil nil nil )


Pile(Object)>>exoInspect
	Receiver: une Pile, de taille: 4 contenant: 1 objets : (33 nil nil nil )
	Arguments and temporary variables: 
		instVar: 	nil
		listVar: 	#(#contenu #index #capacite)
	Receiver's instance variables: 
		contenu: 	#(33 nil nil nil)
		index: 	1
		capacite: 	4


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ p exoInspect
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ p exoInspect
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'p exoInspect.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#p->une Pile, de taille: 4 contenant: 1 objets : (33 ...etc...
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (31 to: 43) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'p := Pile new: 4.
p push: 33.
p exoInspect.' ]...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#p->une Pile, de taille: 4 contenant: 1 objets : (33 ...etc...
		aString: 	'p exoInspect.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (31 to: 43) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'p := Pile new: 4.
p push: 33.
p exoInspect.' ]...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aString: 	'p exoInspect.'
		aBlock: 	[ :result | 
		self printObject: result ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
		self printObject: result ]
		selection: 	'p exoInspect.'
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand>>execute
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Print it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodePrintItCommand
		iconProvider: 	nil
		iconName: 	#smallPrintIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(417864704)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(417864704)
		secondArg: 	a RubEditingArea(417864704)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(417864704)
		secondArg: 	a RubEditingArea(417864704)
		thirdArg: 	[keyDown '<Cmd-p>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(417864704)
		category: 	a KMCategory
		morph: 	a RubEditingArea(417864704)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				i...etc...
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#MacOSX->a KMStorage #all->a KMStorage )



--- The full stack ---
FullBlockClosure(Object)>>doesNotUnderstand: #asSymbol
Pile class(ClassDescription)>>slotNamed:ifFound:ifNone:
Pile(Object)>>instVarNamed:
[ ^ self instVarNamed: [instVar := listVar pop ]] in Pile(Object)>>exoInspect
FullBlockClosure(BlockClosure)>>repeatUntil:
Pile(Object)>>exoInspect
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of FullBlockClosure did not understand #asSymbol
10 October 2022 3:58:48.17235 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
StackToRegisterMappingCogit * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
v9.0.18 - Commit: 7249c170 - Date: 2022-09-02 14:31:12 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

FullBlockClosure(Object)>>doesNotUnderstand: #asSymbol
	Receiver: [instVar := listVar pop ]
	Arguments and temporary variables: 
		aMessage: 	asSymbol
		exception: 	Instance of FullBlockClosure did not understand #asSymbol
		resumeValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[^ self instVarNamed: [instVar := listVar pop ]] in [ listResult ...etc...
		startpc: 	a CompiledBlock: [instVar := listVar pop ]
		numArgs: 	0
		receiver: 	une Pile, de taille: 4 contenant: 1 objets : (33 nil nil nil )


Pile class(ClassDescription)>>slotNamed:ifFound:ifNone:
	Receiver: Pile
	Arguments and temporary variables: 
		aName: 	[instVar := listVar pop ]
		foundBlock: 	[ :slot | slot read: self ]
		exceptionBlock: 	[ InstanceVariableNotFound signalFor: aString asString ]
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#grow->Pile>>#grow #initialize:->Pile>>#initiali...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#Pile
		classPool: 	a Dictionary(#tailleDefaut->nil )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#HAI914I


Pile(Object)>>instVarNamed:
	Receiver: une Pile, de taille: 4 contenant: 1 objets : (33 nil nil nil )
	Arguments and temporary variables: 
		aString: 	[instVar := listVar pop ]
	Receiver's instance variables: 
		contenu: 	#(33 nil nil nil)
		index: 	1
		capacite: 	4


[^ self instVarNamed: [instVar := listVar pop ]] in [ listResult add: [^ self instVarNamed: [instVar := listVar pop ]] value] in Pile(Object)>>exoInspect
	Receiver: une Pile, de taille: 4 contenant: 1 objets : (33 nil nil nil )
	Arguments and temporary variables: 
		listVar: 	#(#contenu #index #capacite)
		listResult: 	a LinkedList()
		instVar: 	nil
	Receiver's instance variables: 
		contenu: 	#(33 nil nil nil)
		index: 	1
		capacite: 	4


[ listResult add: [^ self instVarNamed: [instVar := listVar pop ]] value] in Pile(Object)>>exoInspect
	Receiver: une Pile, de taille: 4 contenant: 1 objets : (33 nil nil nil )
	Arguments and temporary variables: 
		listVar: 	#(#contenu #index #capacite)
		listResult: 	a LinkedList()
		instVar: 	nil
	Receiver's instance variables: 
		contenu: 	#(33 nil nil nil)
		index: 	1
		capacite: 	4


FullBlockClosure(BlockClosure)>>repeatUntil:
	Receiver: [ listResult add: [^ self instVarNamed: [instVar := listVar pop ]] value]
	Arguments and temporary variables: 
		condition: 	[ listVar isNotEmpty  ]
	Receiver's instance variables: 
		outerContext: 	Pile(Object)>>exoInspect
		startpc: 	a CompiledBlock: [ listResult add: [^ self instVarNamed: [instVar := l...etc...
		numArgs: 	0
		receiver: 	une Pile, de taille: 4 contenant: 1 objets : (33 nil nil nil )


Pile(Object)>>exoInspect
	Receiver: une Pile, de taille: 4 contenant: 1 objets : (33 nil nil nil )
	Arguments and temporary variables: 
		instVar: 	nil
		listVar: 	#(#contenu #index #capacite)
		listResult: 	a LinkedList()
	Receiver's instance variables: 
		contenu: 	#(33 nil nil nil)
		index: 	1
		capacite: 	4


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ p exoInspect
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ p exoInspect
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'p exoInspect.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#p->une Pile, de taille: 4 contenant: 1 objets : (33 ...etc...
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (31 to: 43) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'p := Pile new: 4.
p push: 33.
p exoInspect.' ]...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#p->une Pile, de taille: 4 contenant: 1 objets : (33 ...etc...
		aString: 	'p exoInspect.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (31 to: 43) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'p := Pile new: 4.
p push: 33.
p exoInspect.' ]...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aString: 	'p exoInspect.'
		aBlock: 	[ :result | 
		self printObject: result ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
		self printObject: result ]
		selection: 	'p exoInspect.'
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand>>execute
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Print it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodePrintItCommand
		iconProvider: 	nil
		iconName: 	#smallPrintIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(417864704)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(417864704)
		secondArg: 	a RubEditingArea(417864704)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(417864704)
		secondArg: 	a RubEditingArea(417864704)
		thirdArg: 	[keyDown '<Cmd-p>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(417864704)
		category: 	a KMCategory
		morph: 	a RubEditingArea(417864704)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil



--- The full stack ---
FullBlockClosure(Object)>>doesNotUnderstand: #asSymbol
Pile class(ClassDescription)>>slotNamed:ifFound:ifNone:
Pile(Object)>>instVarNamed:
[^ self instVarNamed: [instVar := listVar pop ]] in [ listResult add: [^ self instVarNamed: [instVar := listVar pop ]] value] in Pile(Object)>>exoInspect
[ listResult add: [^ self instVarNamed: [instVar := listVar pop ]] value] in Pile(Object)>>exoInspect
FullBlockClosure(BlockClosure)>>repeatUntil:
Pile(Object)>>exoInspect
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of FullBlockClosure did not understand #asSymbol
10 October 2022 3:58:48.195968 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
StackToRegisterMappingCogit * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
v9.0.18 - Commit: 7249c170 - Date: 2022-09-02 14:31:12 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

FullBlockClosure(Object)>>doesNotUnderstand: #asSymbol
	Receiver: [instVar := listVar pop ]
	Arguments and temporary variables: 
		aMessage: 	asSymbol
		exception: 	Instance of FullBlockClosure did not understand #asSymbol
		resumeValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[^ self instVarNamed: [instVar := listVar pop ]] in [ listResult ...etc...
		startpc: 	a CompiledBlock: [instVar := listVar pop ]
		numArgs: 	0
		receiver: 	une Pile, de taille: 4 contenant: 1 objets : (33 nil nil nil )


Pile class(ClassDescription)>>slotNamed:ifFound:ifNone:
	Receiver: Pile
	Arguments and temporary variables: 
		aName: 	[instVar := listVar pop ]
		foundBlock: 	[ :slot | slot read: self ]
		exceptionBlock: 	[ InstanceVariableNotFound signalFor: aString asString ]
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#grow->Pile>>#grow #initialize:->Pile>>#initiali...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#Pile
		classPool: 	a Dictionary(#tailleDefaut->nil )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#HAI914I


Pile(Object)>>instVarNamed:
	Receiver: une Pile, de taille: 4 contenant: 1 objets : (33 nil nil nil )
	Arguments and temporary variables: 
		aString: 	[instVar := listVar pop ]
	Receiver's instance variables: 
		contenu: 	#(33 nil nil nil)
		index: 	1
		capacite: 	4


[^ self instVarNamed: [instVar := listVar pop ]] in [ listResult add: [^ self instVarNamed: [instVar := listVar pop ]] value] in Pile(Object)>>exoInspect
	Receiver: une Pile, de taille: 4 contenant: 1 objets : (33 nil nil nil )
	Arguments and temporary variables: 
		listVar: 	#(#contenu #index #capacite)
		listResult: 	a LinkedList()
		instVar: 	nil
	Receiver's instance variables: 
		contenu: 	#(33 nil nil nil)
		index: 	1
		capacite: 	4


[ listResult add: [^ self instVarNamed: [instVar := listVar pop ]] value] in Pile(Object)>>exoInspect
	Receiver: une Pile, de taille: 4 contenant: 1 objets : (33 nil nil nil )
	Arguments and temporary variables: 
		listVar: 	#(#contenu #index #capacite)
		listResult: 	a LinkedList()
		instVar: 	nil
	Receiver's instance variables: 
		contenu: 	#(33 nil nil nil)
		index: 	1
		capacite: 	4


FullBlockClosure(BlockClosure)>>repeatUntil:
	Receiver: [ listResult add: [^ self instVarNamed: [instVar := listVar pop ]] value]
	Arguments and temporary variables: 
		condition: 	[ listVar isNotEmpty  ]
	Receiver's instance variables: 
		outerContext: 	Pile(Object)>>exoInspect
		startpc: 	a CompiledBlock: [ listResult add: [^ self instVarNamed: [instVar := l...etc...
		numArgs: 	0
		receiver: 	une Pile, de taille: 4 contenant: 1 objets : (33 nil nil nil )


Pile(Object)>>exoInspect
	Receiver: une Pile, de taille: 4 contenant: 1 objets : (33 nil nil nil )
	Arguments and temporary variables: 
		instVar: 	nil
		listVar: 	#(#contenu #index #capacite)
		listResult: 	a LinkedList()
	Receiver's instance variables: 
		contenu: 	#(33 nil nil nil)
		index: 	1
		capacite: 	4


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ p exoInspect
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ p exoInspect
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'p exoInspect.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#p->une Pile, de taille: 4 contenant: 1 objets : (33 ...etc...
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (31 to: 43) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'p := Pile new: 4.
p push: 33.
p exoInspect.' ]...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#p->une Pile, de taille: 4 contenant: 1 objets : (33 ...etc...
		aString: 	'p exoInspect.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (31 to: 43) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'p := Pile new: 4.
p push: 33.
p exoInspect.' ]...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aString: 	'p exoInspect.'
		aBlock: 	[ :result | 
		self printObject: result ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
		self printObject: result ]
		selection: 	'p exoInspect.'
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand>>execute
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Print it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodePrintItCommand
		iconProvider: 	nil
		iconName: 	#smallPrintIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(417864704)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(417864704)
		secondArg: 	a RubEditingArea(417864704)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(417864704)
		secondArg: 	a RubEditingArea(417864704)
		thirdArg: 	[keyDown '<Cmd-p>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(417864704)
		category: 	a KMCategory
		morph: 	a RubEditingArea(417864704)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil



--- The full stack ---
FullBlockClosure(Object)>>doesNotUnderstand: #asSymbol
Pile class(ClassDescription)>>slotNamed:ifFound:ifNone:
Pile(Object)>>instVarNamed:
[^ self instVarNamed: [instVar := listVar pop ]] in [ listResult add: [^ self instVarNamed: [instVar := listVar pop ]] value] in Pile(Object)>>exoInspect
[ listResult add: [^ self instVarNamed: [instVar := listVar pop ]] value] in Pile(Object)>>exoInspect
FullBlockClosure(BlockClosure)>>repeatUntil:
Pile(Object)>>exoInspect
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of FullBlockClosure did not understand #asSymbol
10 October 2022 4:04:08.264772 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
StackToRegisterMappingCogit * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
v9.0.18 - Commit: 7249c170 - Date: 2022-09-02 14:31:12 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

FullBlockClosure(Object)>>doesNotUnderstand: #asSymbol
	Receiver: [instVar := listVar pop ]
	Arguments and temporary variables: 
		aMessage: 	asSymbol
		exception: 	Instance of FullBlockClosure did not understand #asSymbol
		resumeValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[^ self instVarNamed: [instVar := listVar pop ]] in [ listResult ...etc...
		startpc: 	a CompiledBlock: [instVar := listVar pop ]
		numArgs: 	0
		receiver: 	une Pile, de taille: 4 contenant: 1 objets : (33 nil nil nil )


Pile class(ClassDescription)>>slotNamed:ifFound:ifNone:
	Receiver: Pile
	Arguments and temporary variables: 
		aName: 	[instVar := listVar pop ]
		foundBlock: 	[ :slot | slot read: self ]
		exceptionBlock: 	[ InstanceVariableNotFound signalFor: aString asString ]
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#grow->Pile>>#grow #initialize:->Pile>>#initiali...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#Pile
		classPool: 	a Dictionary(#tailleDefaut->nil )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#HAI914I


Pile(Object)>>instVarNamed:
	Receiver: une Pile, de taille: 4 contenant: 1 objets : (33 nil nil nil )
	Arguments and temporary variables: 
		aString: 	[instVar := listVar pop ]
	Receiver's instance variables: 
		contenu: 	#(33 nil nil nil)
		index: 	1
		capacite: 	4


[^ self instVarNamed: [instVar := listVar pop ]] in [ listResult add: [^ self instVarNamed: [instVar := listVar pop ]] value.] in Pile(Object)>>exoInspect
	Receiver: une Pile, de taille: 4 contenant: 1 objets : (33 nil nil nil )
	Arguments and temporary variables: 
		listVar: 	#(#contenu #index #capacite)
		listResult: 	a LinkedList()
		instVar: 	nil
	Receiver's instance variables: 
		contenu: 	#(33 nil nil nil)
		index: 	1
		capacite: 	4


[ listResult add: [^ self instVarNamed: [instVar := listVar pop ]] value.] in Pile(Object)>>exoInspect
	Receiver: une Pile, de taille: 4 contenant: 1 objets : (33 nil nil nil )
	Arguments and temporary variables: 
		listVar: 	#(#contenu #index #capacite)
		listResult: 	a LinkedList()
		instVar: 	nil
	Receiver's instance variables: 
		contenu: 	#(33 nil nil nil)
		index: 	1
		capacite: 	4


FullBlockClosure(BlockClosure)>>repeatUntil:
	Receiver: [ listResult add: [^ self instVarNamed: [instVar := listVar pop ]] value.]
	Arguments and temporary variables: 
		condition: 	[ listVar isNotEmpty  ]
	Receiver's instance variables: 
		outerContext: 	Pile(Object)>>exoInspect
		startpc: 	a CompiledBlock: [ listResult add: [^ self instVarNamed: [instVar := l...etc...
		numArgs: 	0
		receiver: 	une Pile, de taille: 4 contenant: 1 objets : (33 nil nil nil )


Pile(Object)>>exoInspect
	Receiver: une Pile, de taille: 4 contenant: 1 objets : (33 nil nil nil )
	Arguments and temporary variables: 
		instVar: 	nil
		listVar: 	#(#contenu #index #capacite)
		listResult: 	a LinkedList()
	Receiver's instance variables: 
		contenu: 	#(33 nil nil nil)
		index: 	1
		capacite: 	4


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ p exoInspect
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ p exoInspect
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'p exoInspect.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#p->une Pile, de taille: 4 contenant: 1 objets : (33 ...etc...
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (31 to: 43) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'p := Pile new: 4.
p push: 33.
p exoInspect.' ]...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#p->une Pile, de taille: 4 contenant: 1 objets : (33 ...etc...
		aString: 	'p exoInspect.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (31 to: 43) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'p := Pile new: 4.
p push: 33.
p exoInspect.' ]...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aString: 	'p exoInspect.'
		aBlock: 	[ :result | 
		self printObject: result ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
		self printObject: result ]
		selection: 	'p exoInspect.'
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand>>execute
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Print it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodePrintItCommand
		iconProvider: 	nil
		iconName: 	#smallPrintIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(417864704)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(417864704)
		secondArg: 	a RubEditingArea(417864704)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(417864704)
		secondArg: 	a RubEditingArea(417864704)
		thirdArg: 	[keyDown '<Cmd-p>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(417864704)
		category: 	a KMCategory
		morph: 	a RubEditingArea(417864704)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil



--- The full stack ---
FullBlockClosure(Object)>>doesNotUnderstand: #asSymbol
Pile class(ClassDescription)>>slotNamed:ifFound:ifNone:
Pile(Object)>>instVarNamed:
[^ self instVarNamed: [instVar := listVar pop ]] in [ listResult add: [^ self instVarNamed: [instVar := listVar pop ]] value.] in Pile(Object)>>exoInspect
[ listResult add: [^ self instVarNamed: [instVar := listVar pop ]] value.] in Pile(Object)>>exoInspect
FullBlockClosure(BlockClosure)>>repeatUntil:
Pile(Object)>>exoInspect
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of FullBlockClosure did not understand #asSymbol
10 October 2022 4:04:08.283411 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
StackToRegisterMappingCogit * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
v9.0.18 - Commit: 7249c170 - Date: 2022-09-02 14:31:12 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

FullBlockClosure(Object)>>doesNotUnderstand: #asSymbol
	Receiver: [instVar := listVar pop ]
	Arguments and temporary variables: 
		aMessage: 	asSymbol
		exception: 	Instance of FullBlockClosure did not understand #asSymbol
		resumeValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[^ self instVarNamed: [instVar := listVar pop ]] in [ listResult ...etc...
		startpc: 	a CompiledBlock: [instVar := listVar pop ]
		numArgs: 	0
		receiver: 	une Pile, de taille: 4 contenant: 1 objets : (33 nil nil nil )


Pile class(ClassDescription)>>slotNamed:ifFound:ifNone:
	Receiver: Pile
	Arguments and temporary variables: 
		aName: 	[instVar := listVar pop ]
		foundBlock: 	[ :slot | slot read: self ]
		exceptionBlock: 	[ InstanceVariableNotFound signalFor: aString asString ]
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#grow->Pile>>#grow #initialize:->Pile>>#initiali...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#Pile
		classPool: 	a Dictionary(#tailleDefaut->nil )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#HAI914I


Pile(Object)>>instVarNamed:
	Receiver: une Pile, de taille: 4 contenant: 1 objets : (33 nil nil nil )
	Arguments and temporary variables: 
		aString: 	[instVar := listVar pop ]
	Receiver's instance variables: 
		contenu: 	#(33 nil nil nil)
		index: 	1
		capacite: 	4


[^ self instVarNamed: [instVar := listVar pop ]] in [ listResult add: [^ self instVarNamed: [instVar := listVar pop ]] value.] in Pile(Object)>>exoInspect
	Receiver: une Pile, de taille: 4 contenant: 1 objets : (33 nil nil nil )
	Arguments and temporary variables: 
		listVar: 	#(#contenu #index #capacite)
		listResult: 	a LinkedList()
		instVar: 	nil
	Receiver's instance variables: 
		contenu: 	#(33 nil nil nil)
		index: 	1
		capacite: 	4


[ listResult add: [^ self instVarNamed: [instVar := listVar pop ]] value.] in Pile(Object)>>exoInspect
	Receiver: une Pile, de taille: 4 contenant: 1 objets : (33 nil nil nil )
	Arguments and temporary variables: 
		listVar: 	#(#contenu #index #capacite)
		listResult: 	a LinkedList()
		instVar: 	nil
	Receiver's instance variables: 
		contenu: 	#(33 nil nil nil)
		index: 	1
		capacite: 	4


FullBlockClosure(BlockClosure)>>repeatUntil:
	Receiver: [ listResult add: [^ self instVarNamed: [instVar := listVar pop ]] value.]
	Arguments and temporary variables: 
		condition: 	[ listVar isNotEmpty  ]
	Receiver's instance variables: 
		outerContext: 	Pile(Object)>>exoInspect
		startpc: 	a CompiledBlock: [ listResult add: [^ self instVarNamed: [instVar := l...etc...
		numArgs: 	0
		receiver: 	une Pile, de taille: 4 contenant: 1 objets : (33 nil nil nil )


Pile(Object)>>exoInspect
	Receiver: une Pile, de taille: 4 contenant: 1 objets : (33 nil nil nil )
	Arguments and temporary variables: 
		instVar: 	nil
		listVar: 	#(#contenu #index #capacite)
		listResult: 	a LinkedList()
	Receiver's instance variables: 
		contenu: 	#(33 nil nil nil)
		index: 	1
		capacite: 	4


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ p exoInspect
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ p exoInspect
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'p exoInspect.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#p->une Pile, de taille: 4 contenant: 1 objets : (33 ...etc...
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (31 to: 43) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'p := Pile new: 4.
p push: 33.
p exoInspect.' ]...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#p->une Pile, de taille: 4 contenant: 1 objets : (33 ...etc...
		aString: 	'p exoInspect.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (31 to: 43) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'p := Pile new: 4.
p push: 33.
p exoInspect.' ]...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aString: 	'p exoInspect.'
		aBlock: 	[ :result | 
		self printObject: result ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
		self printObject: result ]
		selection: 	'p exoInspect.'
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand>>execute
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Print it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodePrintItCommand
		iconProvider: 	nil
		iconName: 	#smallPrintIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(417864704)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(417864704)
		secondArg: 	a RubEditingArea(417864704)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(417864704)
		secondArg: 	a RubEditingArea(417864704)
		thirdArg: 	[keyDown '<Cmd-p>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(417864704)
		category: 	a KMCategory
		morph: 	a RubEditingArea(417864704)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil



--- The full stack ---
FullBlockClosure(Object)>>doesNotUnderstand: #asSymbol
Pile class(ClassDescription)>>slotNamed:ifFound:ifNone:
Pile(Object)>>instVarNamed:
[^ self instVarNamed: [instVar := listVar pop ]] in [ listResult add: [^ self instVarNamed: [instVar := listVar pop ]] value.] in Pile(Object)>>exoInspect
[ listResult add: [^ self instVarNamed: [instVar := listVar pop ]] value.] in Pile(Object)>>exoInspect
FullBlockClosure(BlockClosure)>>repeatUntil:
Pile(Object)>>exoInspect
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of FullBlockClosure did not understand #asSymbol
10 October 2022 4:05:41.339391 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
StackToRegisterMappingCogit * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
v9.0.18 - Commit: 7249c170 - Date: 2022-09-02 14:31:12 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

FullBlockClosure(Object)>>doesNotUnderstand: #asSymbol
	Receiver: [instVar := listVar firstIndent ]
	Arguments and temporary variables: 
		aMessage: 	asSymbol
		exception: 	Instance of FullBlockClosure did not understand #asSymbol
		resumeValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[^ self instVarNamed: [instVar := listVar firstIndent ]] in [ lis...etc...
		startpc: 	a CompiledBlock: [instVar := listVar firstIndent ]
		numArgs: 	0
		receiver: 	une Pile, de taille: 4 contenant: 1 objets : (33 nil nil nil )


Pile class(ClassDescription)>>slotNamed:ifFound:ifNone:
	Receiver: Pile
	Arguments and temporary variables: 
		aName: 	[instVar := listVar firstIndent ]
		foundBlock: 	[ :slot | slot read: self ]
		exceptionBlock: 	[ InstanceVariableNotFound signalFor: aString asString ]
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#grow->Pile>>#grow #initialize:->Pile>>#initiali...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#Pile
		classPool: 	a Dictionary(#tailleDefaut->nil )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#HAI914I


Pile(Object)>>instVarNamed:
	Receiver: une Pile, de taille: 4 contenant: 1 objets : (33 nil nil nil )
	Arguments and temporary variables: 
		aString: 	[instVar := listVar firstIndent ]
	Receiver's instance variables: 
		contenu: 	#(33 nil nil nil)
		index: 	1
		capacite: 	4


[^ self instVarNamed: [instVar := listVar firstIndent ]] in [ listResult add: [^ self instVarNamed: [instVar := listVar firstIndent ]] value.] in Pile(Object)>>exoInspect
	Receiver: une Pile, de taille: 4 contenant: 1 objets : (33 nil nil nil )
	Arguments and temporary variables: 
		listVar: 	#(#contenu #index #capacite)
		listResult: 	a LinkedList()
		instVar: 	nil
	Receiver's instance variables: 
		contenu: 	#(33 nil nil nil)
		index: 	1
		capacite: 	4


[ listResult add: [^ self instVarNamed: [instVar := listVar firstIndent ]] value.] in Pile(Object)>>exoInspect
	Receiver: une Pile, de taille: 4 contenant: 1 objets : (33 nil nil nil )
	Arguments and temporary variables: 
		listVar: 	#(#contenu #index #capacite)
		listResult: 	a LinkedList()
		instVar: 	nil
	Receiver's instance variables: 
		contenu: 	#(33 nil nil nil)
		index: 	1
		capacite: 	4


FullBlockClosure(BlockClosure)>>repeatUntil:
	Receiver: [ listResult add: [^ self instVarNamed: [instVar := listVar firstIndent ]] value.]
	Arguments and temporary variables: 
		condition: 	[ listVar isNotEmpty  ]
	Receiver's instance variables: 
		outerContext: 	Pile(Object)>>exoInspect
		startpc: 	a CompiledBlock: [ listResult add: [^ self instVarNamed: [instVar := l...etc...
		numArgs: 	0
		receiver: 	une Pile, de taille: 4 contenant: 1 objets : (33 nil nil nil )


Pile(Object)>>exoInspect
	Receiver: une Pile, de taille: 4 contenant: 1 objets : (33 nil nil nil )
	Arguments and temporary variables: 
		instVar: 	nil
		listVar: 	#(#contenu #index #capacite)
		listResult: 	a LinkedList()
	Receiver's instance variables: 
		contenu: 	#(33 nil nil nil)
		index: 	1
		capacite: 	4


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ p exoInspect
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ p exoInspect
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'p exoInspect.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#p->une Pile, de taille: 4 contenant: 1 objets : (33 ...etc...
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (31 to: 43) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'p := Pile new: 4.
p push: 33.
p exoInspect.' ]...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#p->une Pile, de taille: 4 contenant: 1 objets : (33 ...etc...
		aString: 	'p exoInspect.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (31 to: 43) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'p := Pile new: 4.
p push: 33.
p exoInspect.' ]...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aString: 	'p exoInspect.'
		aBlock: 	[ :result | 
		self printObject: result ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
		self printObject: result ]
		selection: 	'p exoInspect.'
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand>>execute
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Print it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodePrintItCommand
		iconProvider: 	nil
		iconName: 	#smallPrintIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(417864704)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(417864704)
		secondArg: 	a RubEditingArea(417864704)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(417864704)
		secondArg: 	a RubEditingArea(417864704)
		thirdArg: 	[keyDown '<Cmd-p>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(417864704)
		category: 	a KMCategory
		morph: 	a RubEditingArea(417864704)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil



--- The full stack ---
FullBlockClosure(Object)>>doesNotUnderstand: #asSymbol
Pile class(ClassDescription)>>slotNamed:ifFound:ifNone:
Pile(Object)>>instVarNamed:
[^ self instVarNamed: [instVar := listVar firstIndent ]] in [ listResult add: [^ self instVarNamed: [instVar := listVar firstIndent ]] value.] in Pile(Object)>>exoInspect
[ listResult add: [^ self instVarNamed: [instVar := listVar firstIndent ]] value.] in Pile(Object)>>exoInspect
FullBlockClosure(BlockClosure)>>repeatUntil:
Pile(Object)>>exoInspect
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of FullBlockClosure did not understand #asSymbol
10 October 2022 4:05:41.359033 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
StackToRegisterMappingCogit * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
v9.0.18 - Commit: 7249c170 - Date: 2022-09-02 14:31:12 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

FullBlockClosure(Object)>>doesNotUnderstand: #asSymbol
	Receiver: [instVar := listVar firstIndent ]
	Arguments and temporary variables: 
		aMessage: 	asSymbol
		exception: 	Instance of FullBlockClosure did not understand #asSymbol
		resumeValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[^ self instVarNamed: [instVar := listVar firstIndent ]] in [ lis...etc...
		startpc: 	a CompiledBlock: [instVar := listVar firstIndent ]
		numArgs: 	0
		receiver: 	une Pile, de taille: 4 contenant: 1 objets : (33 nil nil nil )


Pile class(ClassDescription)>>slotNamed:ifFound:ifNone:
	Receiver: Pile
	Arguments and temporary variables: 
		aName: 	[instVar := listVar firstIndent ]
		foundBlock: 	[ :slot | slot read: self ]
		exceptionBlock: 	[ InstanceVariableNotFound signalFor: aString asString ]
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#grow->Pile>>#grow #initialize:->Pile>>#initiali...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#Pile
		classPool: 	a Dictionary(#tailleDefaut->nil )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#HAI914I


Pile(Object)>>instVarNamed:
	Receiver: une Pile, de taille: 4 contenant: 1 objets : (33 nil nil nil )
	Arguments and temporary variables: 
		aString: 	[instVar := listVar firstIndent ]
	Receiver's instance variables: 
		contenu: 	#(33 nil nil nil)
		index: 	1
		capacite: 	4


[^ self instVarNamed: [instVar := listVar firstIndent ]] in [ listResult add: [^ self instVarNamed: [instVar := listVar firstIndent ]] value.] in Pile(Object)>>exoInspect
	Receiver: une Pile, de taille: 4 contenant: 1 objets : (33 nil nil nil )
	Arguments and temporary variables: 
		listVar: 	#(#contenu #index #capacite)
		listResult: 	a LinkedList()
		instVar: 	nil
	Receiver's instance variables: 
		contenu: 	#(33 nil nil nil)
		index: 	1
		capacite: 	4


[ listResult add: [^ self instVarNamed: [instVar := listVar firstIndent ]] value.] in Pile(Object)>>exoInspect
	Receiver: une Pile, de taille: 4 contenant: 1 objets : (33 nil nil nil )
	Arguments and temporary variables: 
		listVar: 	#(#contenu #index #capacite)
		listResult: 	a LinkedList()
		instVar: 	nil
	Receiver's instance variables: 
		contenu: 	#(33 nil nil nil)
		index: 	1
		capacite: 	4


FullBlockClosure(BlockClosure)>>repeatUntil:
	Receiver: [ listResult add: [^ self instVarNamed: [instVar := listVar firstIndent ]] value.]
	Arguments and temporary variables: 
		condition: 	[ listVar isNotEmpty  ]
	Receiver's instance variables: 
		outerContext: 	Pile(Object)>>exoInspect
		startpc: 	a CompiledBlock: [ listResult add: [^ self instVarNamed: [instVar := l...etc...
		numArgs: 	0
		receiver: 	une Pile, de taille: 4 contenant: 1 objets : (33 nil nil nil )


Pile(Object)>>exoInspect
	Receiver: une Pile, de taille: 4 contenant: 1 objets : (33 nil nil nil )
	Arguments and temporary variables: 
		instVar: 	nil
		listVar: 	#(#contenu #index #capacite)
		listResult: 	a LinkedList()
	Receiver's instance variables: 
		contenu: 	#(33 nil nil nil)
		index: 	1
		capacite: 	4


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ p exoInspect
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ p exoInspect
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'p exoInspect.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#p->une Pile, de taille: 4 contenant: 1 objets : (33 ...etc...
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (31 to: 43) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'p := Pile new: 4.
p push: 33.
p exoInspect.' ]...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#p->une Pile, de taille: 4 contenant: 1 objets : (33 ...etc...
		aString: 	'p exoInspect.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (31 to: 43) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'p := Pile new: 4.
p push: 33.
p exoInspect.' ]...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aString: 	'p exoInspect.'
		aBlock: 	[ :result | 
		self printObject: result ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
		self printObject: result ]
		selection: 	'p exoInspect.'
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand>>execute
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Print it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodePrintItCommand
		iconProvider: 	nil
		iconName: 	#smallPrintIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(417864704)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(417864704)
		secondArg: 	a RubEditingArea(417864704)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(417864704)
		secondArg: 	a RubEditingArea(417864704)
		thirdArg: 	[keyDown '<Cmd-p>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(417864704)
		category: 	a KMCategory
		morph: 	a RubEditingArea(417864704)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil



--- The full stack ---
FullBlockClosure(Object)>>doesNotUnderstand: #asSymbol
Pile class(ClassDescription)>>slotNamed:ifFound:ifNone:
Pile(Object)>>instVarNamed:
[^ self instVarNamed: [instVar := listVar firstIndent ]] in [ listResult add: [^ self instVarNamed: [instVar := listVar firstIndent ]] value.] in Pile(Object)>>exoInspect
[ listResult add: [^ self instVarNamed: [instVar := listVar firstIndent ]] value.] in Pile(Object)>>exoInspect
FullBlockClosure(BlockClosure)>>repeatUntil:
Pile(Object)>>exoInspect
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
InstanceVariableNotFound: contenu not found in Pile
10 October 2022 4:17:52.292479 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
StackToRegisterMappingCogit * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
v9.0.18 - Commit: 7249c170 - Date: 2022-09-02 14:31:12 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

[ InstanceVariableNotFound signalFor: aString asString ] in Pile class(Object)>>instVarNamed:
	Receiver: Pile
	Arguments and temporary variables: 
		aString: 	#contenu
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#grow->Pile>>#grow #initialize:->Pile>>#initiali...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#Pile
		classPool: 	a Dictionary(#tailleDefaut->nil )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#HAI914I


LayoutClassScope(LayoutAbstractScope)>>resolveSlot:ifFound:ifNone:
	Receiver: a LayoutClassScope(#superclass => InstanceVariableSlot #methodDict => InstanceVariableSlot...etc...
	Arguments and temporary variables: 
		aName: 	#contenu
		foundBlock: 	[ :slot | slot read: self ]
		exceptionBlock: 	[ InstanceVariableNotFound signalFor: aString asString ]
	Receiver's instance variables: 
		parentScope: 	a LayoutClassScope(#superclass => InstanceVariableSlot #methodDict...etc...


FixedLayout(PointerLayout)>>resolveSlot:ifFound:ifNone:
	Receiver: a FixedLayout
	Arguments and temporary variables: 
		aName: 	#contenu
		foundBlock: 	[ :slot | slot read: self ]
		noneBlock: 	[ InstanceVariableNotFound signalFor: aString asString ]
	Receiver's instance variables: 
		host: 	Pile class
		slotScope: 	a LayoutClassScope(#superclass => InstanceVariableSlot #methodDict =...etc...


Metaclass(ClassDescription)>>slotNamed:ifFound:ifNone:
	Receiver: Pile class
	Arguments and temporary variables: 
		aName: 	#contenu
		foundBlock: 	[ :slot | slot read: self ]
		exceptionBlock: 	[ InstanceVariableNotFound signalFor: aString asString ]
	Receiver's instance variables: 
		superclass: 	Object class
		methodDict: 	a MethodDictionary(#example->Pile class>>#example #initialize->Pile...etc...
		format: 	65547
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		thisClass: 	Pile


Pile class(Object)>>instVarNamed:
	Receiver: Pile
	Arguments and temporary variables: 
		aString: 	#contenu
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#grow->Pile>>#grow #initialize:->Pile>>#initiali...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#Pile
		classPool: 	a Dictionary(#tailleDefaut->nil )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#HAI914I


[ ^ self class instVarNamed: instVar ] in [ :instVar | listInst add: [ ^ self class instVarNamed: instVar ] value. ] in Pile(Object)>>exoInspect
	Receiver: une Pile, de taille: 4 contenant: 1 objets : (33 nil nil nil )
	Arguments and temporary variables: 
		listVar: 	#(#contenu #index #capacite)
		listInst: 	a LinkedList()
		listResult: 	a LinkedList()
		instVar: 	#contenu
	Receiver's instance variables: 
		contenu: 	#(33 nil nil nil)
		index: 	1
		capacite: 	4


[ :instVar | listInst add: [ ^ self class instVarNamed: instVar ] value. ] in Pile(Object)>>exoInspect
	Receiver: une Pile, de taille: 4 contenant: 1 objets : (33 nil nil nil )
	Arguments and temporary variables: 
		listVar: 	#(#contenu #index #capacite)
		listInst: 	a LinkedList()
		listResult: 	a LinkedList()
		instVar: 	#contenu
	Receiver's instance variables: 
		contenu: 	#(33 nil nil nil)
		index: 	1
		capacite: 	4


Array(SequenceableCollection)>>do:
	Receiver: #(#contenu #index #capacite)
	Arguments and temporary variables: 
		aBlock: 	[ :instVar | listInst add: [ ^ self class instVarNamed: instVar ] value...etc...
		index: 	1
	Receiver's instance variables: 
#(#contenu #index #capacite)

Pile(Object)>>exoInspect
	Receiver: une Pile, de taille: 4 contenant: 1 objets : (33 nil nil nil )
	Arguments and temporary variables: 
		listVar: 	#(#contenu #index #capacite)
		listInst: 	a LinkedList()
		listResult: 	a LinkedList()
	Receiver's instance variables: 
		contenu: 	#(33 nil nil nil)
		index: 	1
		capacite: 	4


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ p exoInspect
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ p exoInspect
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'p exoInspect.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#p->une Pile, de taille: 4 contenant: 1 objets : (33 ...etc...
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (31 to: 43) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'p := Pile new: 4.
p push: 33.
p exoInspect.' ]...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#p->une Pile, de taille: 4 contenant: 1 objets : (33 ...etc...
		aString: 	'p exoInspect.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (31 to: 43) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'p := Pile new: 4.
p push: 33.
p exoInspect.' ]...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aString: 	'p exoInspect.'
		aBlock: 	[ :result | 
		self printObject: result ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
		self printObject: result ]
		selection: 	'p exoInspect.'
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand>>execute
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Print it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodePrintItCommand
		iconProvider: 	nil
		iconName: 	#smallPrintIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(417864704)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(417864704)
		secondArg: 	a RubEditingArea(417864704)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(417864704)
		secondArg: 	a RubEditingArea(417864704)
		thirdArg: 	[keyDown '<Cmd-p>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(417864704)
		category: 	a KMCategory
		morph: 	a RubEditingArea(417864704)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)


--- The full stack ---
[ InstanceVariableNotFound signalFor: aString asString ] in Pile class(Object)>>instVarNamed:
LayoutClassScope(LayoutAbstractScope)>>resolveSlot:ifFound:ifNone:
FixedLayout(PointerLayout)>>resolveSlot:ifFound:ifNone:
Metaclass(ClassDescription)>>slotNamed:ifFound:ifNone:
Pile class(Object)>>instVarNamed:
[ ^ self class instVarNamed: instVar ] in [ :instVar | listInst add: [ ^ self class instVarNamed: instVar ] value. ] in Pile(Object)>>exoInspect
[ :instVar | listInst add: [ ^ self class instVarNamed: instVar ] value. ] in Pile(Object)>>exoInspect
Array(SequenceableCollection)>>do:
Pile(Object)>>exoInspect
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
InstanceVariableNotFound: contenu not found in Pile
10 October 2022 4:17:52.315247 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
StackToRegisterMappingCogit * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
v9.0.18 - Commit: 7249c170 - Date: 2022-09-02 14:31:12 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

[ InstanceVariableNotFound signalFor: aString asString ] in Pile class(Object)>>instVarNamed:
	Receiver: Pile
	Arguments and temporary variables: 
		aString: 	#contenu
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#grow->Pile>>#grow #initialize:->Pile>>#initiali...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#Pile
		classPool: 	a Dictionary(#tailleDefaut->nil )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#HAI914I


LayoutClassScope(LayoutAbstractScope)>>resolveSlot:ifFound:ifNone:
	Receiver: a LayoutClassScope(#superclass => InstanceVariableSlot #methodDict => InstanceVariableSlot...etc...
	Arguments and temporary variables: 
		aName: 	#contenu
		foundBlock: 	[ :slot | slot read: self ]
		exceptionBlock: 	[ InstanceVariableNotFound signalFor: aString asString ]
	Receiver's instance variables: 
		parentScope: 	a LayoutClassScope(#superclass => InstanceVariableSlot #methodDict...etc...


FixedLayout(PointerLayout)>>resolveSlot:ifFound:ifNone:
	Receiver: a FixedLayout
	Arguments and temporary variables: 
		aName: 	#contenu
		foundBlock: 	[ :slot | slot read: self ]
		noneBlock: 	[ InstanceVariableNotFound signalFor: aString asString ]
	Receiver's instance variables: 
		host: 	Pile class
		slotScope: 	a LayoutClassScope(#superclass => InstanceVariableSlot #methodDict =...etc...


Metaclass(ClassDescription)>>slotNamed:ifFound:ifNone:
	Receiver: Pile class
	Arguments and temporary variables: 
		aName: 	#contenu
		foundBlock: 	[ :slot | slot read: self ]
		exceptionBlock: 	[ InstanceVariableNotFound signalFor: aString asString ]
	Receiver's instance variables: 
		superclass: 	Object class
		methodDict: 	a MethodDictionary(#example->Pile class>>#example #initialize->Pile...etc...
		format: 	65547
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		thisClass: 	Pile


Pile class(Object)>>instVarNamed:
	Receiver: Pile
	Arguments and temporary variables: 
		aString: 	#contenu
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#grow->Pile>>#grow #initialize:->Pile>>#initiali...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#Pile
		classPool: 	a Dictionary(#tailleDefaut->nil )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#HAI914I


[ ^ self class instVarNamed: instVar ] in [ :instVar | listInst add: [ ^ self class instVarNamed: instVar ] value. ] in Pile(Object)>>exoInspect
	Receiver: une Pile, de taille: 4 contenant: 1 objets : (33 nil nil nil )
	Arguments and temporary variables: 
		listVar: 	#(#contenu #index #capacite)
		listInst: 	a LinkedList()
		listResult: 	a LinkedList()
		instVar: 	#contenu
	Receiver's instance variables: 
		contenu: 	#(33 nil nil nil)
		index: 	1
		capacite: 	4


[ :instVar | listInst add: [ ^ self class instVarNamed: instVar ] value. ] in Pile(Object)>>exoInspect
	Receiver: une Pile, de taille: 4 contenant: 1 objets : (33 nil nil nil )
	Arguments and temporary variables: 
		listVar: 	#(#contenu #index #capacite)
		listInst: 	a LinkedList()
		listResult: 	a LinkedList()
		instVar: 	#contenu
	Receiver's instance variables: 
		contenu: 	#(33 nil nil nil)
		index: 	1
		capacite: 	4


Array(SequenceableCollection)>>do:
	Receiver: #(#contenu #index #capacite)
	Arguments and temporary variables: 
		aBlock: 	[ :instVar | listInst add: [ ^ self class instVarNamed: instVar ] value...etc...
		index: 	1
	Receiver's instance variables: 
#(#contenu #index #capacite)

Pile(Object)>>exoInspect
	Receiver: une Pile, de taille: 4 contenant: 1 objets : (33 nil nil nil )
	Arguments and temporary variables: 
		listVar: 	#(#contenu #index #capacite)
		listInst: 	a LinkedList()
		listResult: 	a LinkedList()
	Receiver's instance variables: 
		contenu: 	#(33 nil nil nil)
		index: 	1
		capacite: 	4


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ p exoInspect
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ p exoInspect
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'p exoInspect.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#p->une Pile, de taille: 4 contenant: 1 objets : (33 ...etc...
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (31 to: 43) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'p := Pile new: 4.
p push: 33.
p exoInspect.' ]...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#p->une Pile, de taille: 4 contenant: 1 objets : (33 ...etc...
		aString: 	'p exoInspect.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (31 to: 43) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'p := Pile new: 4.
p push: 33.
p exoInspect.' ]...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aString: 	'p exoInspect.'
		aBlock: 	[ :result | 
		self printObject: result ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
		self printObject: result ]
		selection: 	'p exoInspect.'
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand>>execute
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Print it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodePrintItCommand
		iconProvider: 	nil
		iconName: 	#smallPrintIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(417864704)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(417864704)
		secondArg: 	a RubEditingArea(417864704)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(417864704)
		secondArg: 	a RubEditingArea(417864704)
		thirdArg: 	[keyDown '<Cmd-p>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(417864704)
		category: 	a KMCategory
		morph: 	a RubEditingArea(417864704)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)


--- The full stack ---
[ InstanceVariableNotFound signalFor: aString asString ] in Pile class(Object)>>instVarNamed:
LayoutClassScope(LayoutAbstractScope)>>resolveSlot:ifFound:ifNone:
FixedLayout(PointerLayout)>>resolveSlot:ifFound:ifNone:
Metaclass(ClassDescription)>>slotNamed:ifFound:ifNone:
Pile class(Object)>>instVarNamed:
[ ^ self class instVarNamed: instVar ] in [ :instVar | listInst add: [ ^ self class instVarNamed: instVar ] value. ] in Pile(Object)>>exoInspect
[ :instVar | listInst add: [ ^ self class instVarNamed: instVar ] value. ] in Pile(Object)>>exoInspect
Array(SequenceableCollection)>>do:
Pile(Object)>>exoInspect
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Error: Improper store into indexable object
10 October 2022 4:22:18.841422 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
StackToRegisterMappingCogit * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
v9.0.18 - Commit: 7249c170 - Date: 2022-09-02 14:31:12 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

ByteString(Object)>>error:
	Receiver: 'contenu: {    '
	Arguments and temporary variables: 
		aString: 	'Improper store into indexable object'
	Receiver's instance variables: 
'contenu: {    '

ByteString(Object)>>errorImproperStore
	Receiver: 'contenu: {    '
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
'contenu: {    '

ByteString>>at:put:
	Receiver: 'contenu: {    '
	Arguments and temporary variables: 
		index: 	11
		aCharacter: 	33
	Receiver's instance variables: 
'contenu: {    '

ByteString(SequenceableCollection)>>replaceFrom:to:with:startingAt:
	Receiver: 'contenu: {    '
	Arguments and temporary variables: 
		start: 	11
		stop: 	14
		replacement: 	#(33 nil nil nil)
		repStart: 	1
		index: 	11
		repOff: 	-10
	Receiver's instance variables: 
'contenu: {    '

ByteString(String)>>replaceFrom:to:with:startingAt:
	Receiver: 'contenu: {    '
	Arguments and temporary variables: 
		start: 	11
		stop: 	14
		replacement: 	#(33 nil nil nil)
		repStart: 	1
	Receiver's instance variables: 
'contenu: {    '

ByteString>>replaceFrom:to:with:startingAt:
	Receiver: 'contenu: {    '
	Arguments and temporary variables: 
		start: 	11
		stop: 	14
		replacement: 	#(33 nil nil nil)
		repStart: 	1
	Receiver's instance variables: 
'contenu: {    '

ByteString(SequenceableCollection)>>copyReplaceFrom:to:with:
	Receiver: 'contenu: {'
	Arguments and temporary variables: 
		start: 	11
		stop: 	10
		replacementCollection: 	#(33 nil nil nil)
		newSequenceableCollection: 	'contenu: {    '
		newSize: 	14
		endReplacement: 	14
	Receiver's instance variables: 
'contenu: {'

ByteString(SequenceableCollection)>>,
	Receiver: 'contenu: {'
	Arguments and temporary variables: 
		otherCollection: 	#(33 nil nil nil)
	Receiver's instance variables: 
'contenu: {'

[ :instVar | result, instVar, ': {', [ self instVarNamed: instVar ] value, '} ' ] in Pile(Object)>>exoInspect
	Receiver: une Pile, de taille: 4 contenant: 1 objets : (33 nil nil nil )
	Arguments and temporary variables: 
		listVar: 	#(#contenu #index #capacite)
		listInst: 	a LinkedList()
		result: 	''
		instVar: 	#contenu
	Receiver's instance variables: 
		contenu: 	#(33 nil nil nil)
		index: 	1
		capacite: 	4


Array(SequenceableCollection)>>do:
	Receiver: #(#contenu #index #capacite)
	Arguments and temporary variables: 
		aBlock: 	[ :instVar | result, instVar, ': {', [ self instVarNamed: instVar ] val...etc...
		index: 	1
	Receiver's instance variables: 
#(#contenu #index #capacite)

Pile(Object)>>exoInspect
	Receiver: une Pile, de taille: 4 contenant: 1 objets : (33 nil nil nil )
	Arguments and temporary variables: 
		listVar: 	#(#contenu #index #capacite)
		listInst: 	a LinkedList()
		result: 	''
	Receiver's instance variables: 
		contenu: 	#(33 nil nil nil)
		index: 	1
		capacite: 	4


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ p exoInspect
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ p exoInspect
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'p exoInspect.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#p->une Pile, de taille: 4 contenant: 1 objets : (33 ...etc...
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (31 to: 43) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'p := Pile new: 4.
p push: 33.
p exoInspect.' ]...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#p->une Pile, de taille: 4 contenant: 1 objets : (33 ...etc...
		aString: 	'p exoInspect.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (31 to: 43) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'p := Pile new: 4.
p push: 33.
p exoInspect.' ]...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aString: 	'p exoInspect.'
		aBlock: 	[ :result | 
		self printObject: result ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
		self printObject: result ]
		selection: 	'p exoInspect.'
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand>>execute
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Print it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodePrintItCommand
		iconProvider: 	nil
		iconName: 	#smallPrintIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(417864704)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(417864704)
		secondArg: 	a RubEditingArea(417864704)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(417864704)
		secondArg: 	a RubEditingArea(417864704)
		thirdArg: 	[keyDown '<Cmd-p>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(417864704)
		category: 	a KMCategory
		morph: 	a RubEditingArea(417864704)



--- The full stack ---
ByteString(Object)>>error:
ByteString(Object)>>errorImproperStore
ByteString>>at:put:
ByteString(SequenceableCollection)>>replaceFrom:to:with:startingAt:
ByteString(String)>>replaceFrom:to:with:startingAt:
ByteString>>replaceFrom:to:with:startingAt:
ByteString(SequenceableCollection)>>copyReplaceFrom:to:with:
ByteString(SequenceableCollection)>>,
[ :instVar | result, instVar, ': {', [ self instVarNamed: instVar ] value, '} ' ] in Pile(Object)>>exoInspect
Array(SequenceableCollection)>>do:
Pile(Object)>>exoInspect
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Error: Improper store into indexable object
10 October 2022 4:22:18.873818 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
StackToRegisterMappingCogit * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
v9.0.18 - Commit: 7249c170 - Date: 2022-09-02 14:31:12 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

ByteString(Object)>>error:
	Receiver: 'contenu: {    '
	Arguments and temporary variables: 
		aString: 	'Improper store into indexable object'
	Receiver's instance variables: 
'contenu: {    '

ByteString(Object)>>errorImproperStore
	Receiver: 'contenu: {    '
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
'contenu: {    '

ByteString>>at:put:
	Receiver: 'contenu: {    '
	Arguments and temporary variables: 
		index: 	11
		aCharacter: 	33
	Receiver's instance variables: 
'contenu: {    '

ByteString(SequenceableCollection)>>replaceFrom:to:with:startingAt:
	Receiver: 'contenu: {    '
	Arguments and temporary variables: 
		start: 	11
		stop: 	14
		replacement: 	#(33 nil nil nil)
		repStart: 	1
		index: 	11
		repOff: 	-10
	Receiver's instance variables: 
'contenu: {    '

ByteString(String)>>replaceFrom:to:with:startingAt:
	Receiver: 'contenu: {    '
	Arguments and temporary variables: 
		start: 	11
		stop: 	14
		replacement: 	#(33 nil nil nil)
		repStart: 	1
	Receiver's instance variables: 
'contenu: {    '

ByteString>>replaceFrom:to:with:startingAt:
	Receiver: 'contenu: {    '
	Arguments and temporary variables: 
		start: 	11
		stop: 	14
		replacement: 	#(33 nil nil nil)
		repStart: 	1
	Receiver's instance variables: 
'contenu: {    '

ByteString(SequenceableCollection)>>copyReplaceFrom:to:with:
	Receiver: 'contenu: {'
	Arguments and temporary variables: 
		start: 	11
		stop: 	10
		replacementCollection: 	#(33 nil nil nil)
		newSequenceableCollection: 	'contenu: {    '
		newSize: 	14
		endReplacement: 	14
	Receiver's instance variables: 
'contenu: {'

ByteString(SequenceableCollection)>>,
	Receiver: 'contenu: {'
	Arguments and temporary variables: 
		otherCollection: 	#(33 nil nil nil)
	Receiver's instance variables: 
'contenu: {'

[ :instVar | result, instVar, ': {', [ self instVarNamed: instVar ] value, '} ' ] in Pile(Object)>>exoInspect
	Receiver: une Pile, de taille: 4 contenant: 1 objets : (33 nil nil nil )
	Arguments and temporary variables: 
		listVar: 	#(#contenu #index #capacite)
		listInst: 	a LinkedList()
		result: 	''
		instVar: 	#contenu
	Receiver's instance variables: 
		contenu: 	#(33 nil nil nil)
		index: 	1
		capacite: 	4


Array(SequenceableCollection)>>do:
	Receiver: #(#contenu #index #capacite)
	Arguments and temporary variables: 
		aBlock: 	[ :instVar | result, instVar, ': {', [ self instVarNamed: instVar ] val...etc...
		index: 	1
	Receiver's instance variables: 
#(#contenu #index #capacite)

Pile(Object)>>exoInspect
	Receiver: une Pile, de taille: 4 contenant: 1 objets : (33 nil nil nil )
	Arguments and temporary variables: 
		listVar: 	#(#contenu #index #capacite)
		listInst: 	a LinkedList()
		result: 	''
	Receiver's instance variables: 
		contenu: 	#(33 nil nil nil)
		index: 	1
		capacite: 	4


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ p exoInspect
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ p exoInspect
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'p exoInspect.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#p->une Pile, de taille: 4 contenant: 1 objets : (33 ...etc...
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (31 to: 43) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'p := Pile new: 4.
p push: 33.
p exoInspect.' ]...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#p->une Pile, de taille: 4 contenant: 1 objets : (33 ...etc...
		aString: 	'p exoInspect.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (31 to: 43) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'p := Pile new: 4.
p push: 33.
p exoInspect.' ]...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aString: 	'p exoInspect.'
		aBlock: 	[ :result | 
		self printObject: result ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
		self printObject: result ]
		selection: 	'p exoInspect.'
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand>>execute
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Print it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodePrintItCommand
		iconProvider: 	nil
		iconName: 	#smallPrintIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(417864704)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(417864704)
		secondArg: 	a RubEditingArea(417864704)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(417864704)
		secondArg: 	a RubEditingArea(417864704)
		thirdArg: 	[keyDown '<Cmd-p>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Cmd-p>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(417864704)
		category: 	a KMCategory
		morph: 	a RubEditingArea(417864704)



--- The full stack ---
ByteString(Object)>>error:
ByteString(Object)>>errorImproperStore
ByteString>>at:put:
ByteString(SequenceableCollection)>>replaceFrom:to:with:startingAt:
ByteString(String)>>replaceFrom:to:with:startingAt:
ByteString>>replaceFrom:to:with:startingAt:
ByteString(SequenceableCollection)>>copyReplaceFrom:to:with:
ByteString(SequenceableCollection)>>,
[ :instVar | result, instVar, ': {', [ self instVarNamed: instVar ] value, '} ' ] in Pile(Object)>>exoInspect
Array(SequenceableCollection)>>do:
Pile(Object)>>exoInspect
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of Pile class did not understand #initialize:
10 October 2022 4:27:52.616264 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
StackToRegisterMappingCogit * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
v9.0.18 - Commit: 7249c170 - Date: 2022-09-02 14:31:12 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

Pile class(Object)>>doesNotUnderstand: #initialize:
	Receiver: Pile
	Arguments and temporary variables: 
		aMessage: 	initialize: 3
		exception: 	Instance of Pile class did not understand #initialize:
		resumeValue: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#grow->Pile>>#grow #initialize:->Pile>>#initiali...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#Pile
		classPool: 	a Dictionary(#tailleDefaut->nil )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#HAI914I


TestPile>>setUp
	Receiver: TestPile>>#testEmpty
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#testEmpty
		expectedFails: 	nil
		standard: 	nil
		pleine: 	nil
		vide: 	nil


[self setUp.
	self performTest] in TestPile(TestCase)>>runCase
	Receiver: TestPile>>#testEmpty
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#testEmpty
		expectedFails: 	nil
		standard: 	nil
		pleine: 	nil
		vide: 	nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self setUp.
	self performTest]
	Arguments and temporary variables: 
		aBlock: 	[
		self tearDown.
		self cleanUpInstanceVariables]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestPile(TestCase)>>runCase
		startpc: 	a CompiledBlock: [self setUp.
	self performTest]
		numArgs: 	0
		receiver: 	TestPile>>#testEmpty


TestPile(TestCase)>>runCase
	Receiver: TestPile>>#testEmpty
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#testEmpty
		expectedFails: 	nil
		standard: 	nil
		pleine: 	nil
		vide: 	nil


[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TestPile>>#testEmpty
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TestPile>>#testEmpty
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [aTestCase runCase]
	Arguments and temporary variables: 
		aBlock: 	[
			"Terminated test is not considered as completed (user just closed ...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[
		[aTestCase runCase] ensure: [
			"Terminated test is not cons...etc...
		startpc: 	a CompiledBlock: [aTestCase runCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TestPile>>#testEmpty
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TestPile>>#testEmpty
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user...etc...
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :err | 
			self handleException: err 
	]
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseUnderWatchdog:
		startpc: 	a CompiledBlock: [
		[aTestCase runCase] ensure: [
			"Terminated test...etc...
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TestPile>>#testEmpty
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TestPile>>#testEmpty
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TestPile>>#testEmpty
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TestPile>>#testEmpty
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self runTestCaseUnderWatchdog: aTestCase]
	Arguments and temporary variables: 
		aBlock: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal that te...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	a CompiledBlock: [self runTestCaseUnderWatchdog: aTestCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TestPile>>#testEmpty
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TestPile>>#testEmpty
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TestPile>>#testEmpty
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ]
	Arguments and temporary variables: 
		aBlock: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	a CompiledBlock: [ self value: anExecutionEnvironment.
	anExecutionEnv...etc...
		numArgs: 	0
		receiver: 	CurrentExecutionEnvironment


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[
		testEnv runTestCase: aTestCase]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TestPile>>#testEmpty
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TestPile>>#testEmpty
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TestPile>>#testEmpty
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestPile(TestCase)>>runCaseManaged
	Receiver: TestPile>>#testEmpty
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#testEmpty
		expectedFails: 	nil
		standard: 	nil
		pleine: 	nil
		vide: 	nil


[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	TestPile>>#testEmpty
	Receiver's instance variables: 
		timeStamp: 	2022-10-10T16:27:52.581155+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection(TestPile>>#testEmpty)
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTest...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[:ex | ex sunitAnnounce: aTestCase toResult: self. ex pass]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	a CompiledBlock: [
	aTestCase announce: TestCaseStarted withResult: se...etc...
		numArgs: 	0
		receiver: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error,...etc...


TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	TestPile>>#testEmpty
	Receiver's instance variables: 
		timeStamp: 	2022-10-10T16:27:52.581155+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection(TestPile>>#testEmpty)
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in TestPile(TestCase)>>debug
	Receiver: TestPile>>#testEmpty
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#testEmpty
		expectedFails: 	#()
		standard: 	nil
		pleine: 	nil
		vide: 	nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
			result u...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestPile(TestCase)>>debug
		startpc: 	a CompiledBlock: [ result runCaseForDebug: self ]
		numArgs: 	0
		receiver: 	TestPile>>#testEmpty


TestPile(TestCase)>>debug
	Receiver: TestPile>>#testEmpty
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#testEmpty
		expectedFails: 	#()
		standard: 	nil
		pleine: 	nil
		vide: 	nil


TestPile class(TestCase class)>>debug:
	Receiver: TestPile
	Arguments and temporary variables: 
		aSymbol: 	#testEmpty
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#setUp->TestPile>>#setUp #testEmpty->TestPile>>#...etc...
		format: 	65541
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#TestPile
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#HAI914I
		history: 	a Dictionary(#errors->a Set(#testPush #testFull #testEmpty #testPop #t...etc...


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#testEmpty
		testClass: 	TestPile
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testEmpty))
		runTestCases: 	{TestPile}


[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testEmpty)
		testSelector: 	#testEmpty
		each: 	TestPile
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testEmpty))
		runTestCases: 	{TestPile}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(TestPile)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
		self runTest: testSelector of: each ]
		index: 	2
		each: 	TestPile
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. TestPile. nil. nil. nil}


ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testEmpty)
		testSelector: 	#testEmpty
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testEmpty))
		runTestCases: 	{TestPile}


[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(testEmpty)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testEmpty))
		runTestCases: 	{TestPile}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(testEmpty))
	Arguments and temporary variables: 
		aBlock: 	[:each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(testEmpty))

ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testEmpty))
		runTestCases: 	{TestPile}


ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
	Receiver: a ClyFullBrowserMethodContext
	Arguments and temporary variables: 
		aCommand: 	a ClyRunTestsFromMethodsCommand
		aCommandActivator: 	a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Receiver's instance variables: 
		tool: 	a ClyFullBrowserMorph(850096128)
		selectedItems: 	an Array(a ClyDataSourceItem(testEmpty))
		metaLevelScope: 	ClyInstanceSideScope


[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
	Receiver: a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		command: 	a ClyRunTestsFromMethodsCommand
		context: 	a ClyFullBrowserMethodContext
		activationStrategy: 	a ClyTableIconCommandActivation


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCo...etc...
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :exc | self processCommandFailure: exc ]
	Receiver's instance variables: 
		outerContext: 	CmdCommandActivator>>executeCommand
		startpc: 	a CompiledBlock: [self prepareCommandForExecution.
	context executeCom...etc...
		numArgs: 	0
		receiver: 	a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)


CmdCommandActivator>>executeCommand
	Receiver: a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		command: 	a ClyRunTestsFromMethodsCommand
		context: 	a ClyFullBrowserMethodContext
		activationStrategy: 	a ClyTableIconCommandActivation



--- The full stack ---
Pile class(Object)>>doesNotUnderstand: #initialize:
TestPile>>setUp
[self setUp.
	self performTest] in TestPile(TestCase)>>runCase
FullBlockClosure(BlockClosure)>>ensure:
TestPile(TestCase)>>runCase
[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>ensure:
[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>on:do:
TestExecutionEnvironment>>runTestCaseUnderWatchdog:
[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
FullBlockClosure(BlockClosure)>>ensure:
TestExecutionEnvironment>>runTestCase:
[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
FullBlockClosure(BlockClosure)>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
TestPile(TestCase)>>runCaseManaged
[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
FullBlockClosure(BlockClosure)>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in TestPile(TestCase)>>debug
FullBlockClosure(BlockClosure)>>ensure:
TestPile(TestCase)>>debug
TestPile class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
IdentitySet(Set)>>do:
ClyRunTestsFromMethodsCommand>>runTestItem:
[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
ClyRunTestsFromMethodsCommand>>execute
ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
FullBlockClosure(BlockClosure)>>on:do:
CmdCommandActivator>>executeCommand
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[target perform: actionSelector withArguments: arguments] in IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
IconicButtonMorph(SimpleButtonMorph)>>mouseUp:
IconicButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
IconicButtonMorph(Morph)>>handleEvent:
IconicButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of Pile class did not understand #initialize:
10 October 2022 4:27:52.636744 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
StackToRegisterMappingCogit * VMMaker-tonel.1 uuid: d036c19b-14a4-0d00-8c28-96e1091e3459 Sep  2 2022
v9.0.18 - Commit: 7249c170 - Date: 2022-09-02 14:31:12 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

Pile class(Object)>>doesNotUnderstand: #initialize:
	Receiver: Pile
	Arguments and temporary variables: 
		aMessage: 	initialize: 3
		exception: 	Instance of Pile class did not understand #initialize:
		resumeValue: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#grow->Pile>>#grow #initialize:->Pile>>#initiali...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#Pile
		classPool: 	a Dictionary(#tailleDefaut->nil )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#HAI914I


TestPile>>setUp
	Receiver: TestPile>>#testEmpty
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#testEmpty
		expectedFails: 	#()
		standard: 	nil
		pleine: 	nil
		vide: 	nil


[self setUp.
	self performTest] in TestPile(TestCase)>>runCase
	Receiver: TestPile>>#testEmpty
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#testEmpty
		expectedFails: 	#()
		standard: 	nil
		pleine: 	nil
		vide: 	nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self setUp.
	self performTest]
	Arguments and temporary variables: 
		aBlock: 	[
		self tearDown.
		self cleanUpInstanceVariables]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestPile(TestCase)>>runCase
		startpc: 	a CompiledBlock: [self setUp.
	self performTest]
		numArgs: 	0
		receiver: 	TestPile>>#testEmpty


TestPile(TestCase)>>runCase
	Receiver: TestPile>>#testEmpty
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#testEmpty
		expectedFails: 	#()
		standard: 	nil
		pleine: 	nil
		vide: 	nil


[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TestPile>>#testEmpty
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TestPile>>#testEmpty
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [aTestCase runCase]
	Arguments and temporary variables: 
		aBlock: 	[
			"Terminated test is not considered as completed (user just closed ...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[
		[aTestCase runCase] ensure: [
			"Terminated test is not cons...etc...
		startpc: 	a CompiledBlock: [aTestCase runCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TestPile>>#testEmpty
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TestPile>>#testEmpty
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user...etc...
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :err | 
			self handleException: err 
	]
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseUnderWatchdog:
		startpc: 	a CompiledBlock: [
		[aTestCase runCase] ensure: [
			"Terminated test...etc...
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TestPile>>#testEmpty
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TestPile>>#testEmpty
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TestPile>>#testEmpty
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TestPile>>#testEmpty
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self runTestCaseUnderWatchdog: aTestCase]
	Arguments and temporary variables: 
		aBlock: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal that te...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	a CompiledBlock: [self runTestCaseUnderWatchdog: aTestCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TestPile>>#testEmpty
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TestPile>>#testEmpty
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TestPile>>#testEmpty
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ]
	Arguments and temporary variables: 
		aBlock: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	a CompiledBlock: [ self value: anExecutionEnvironment.
	anExecutionEnv...etc...
		numArgs: 	0
		receiver: 	CurrentExecutionEnvironment


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[
		testEnv runTestCase: aTestCase]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TestPile>>#testEmpty
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TestPile>>#testEmpty
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TestPile>>#testEmpty
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestPile(TestCase)>>runCaseManaged
	Receiver: TestPile>>#testEmpty
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#testEmpty
		expectedFails: 	#()
		standard: 	nil
		pleine: 	nil
		vide: 	nil


[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	TestPile>>#testEmpty
	Receiver's instance variables: 
		timeStamp: 	2022-10-10T16:27:52.581155+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection(TestPile>>#testEmpty)
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTest...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[:ex | ex sunitAnnounce: aTestCase toResult: self. ex pass]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	a CompiledBlock: [
	aTestCase announce: TestCaseStarted withResult: se...etc...
		numArgs: 	0
		receiver: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error,...etc...


TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	TestPile>>#testEmpty
	Receiver's instance variables: 
		timeStamp: 	2022-10-10T16:27:52.581155+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection(TestPile>>#testEmpty)
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in TestPile(TestCase)>>debug
	Receiver: TestPile>>#testEmpty
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#testEmpty
		expectedFails: 	#()
		standard: 	nil
		pleine: 	nil
		vide: 	nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
			result u...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestPile(TestCase)>>debug
		startpc: 	a CompiledBlock: [ result runCaseForDebug: self ]
		numArgs: 	0
		receiver: 	TestPile>>#testEmpty


TestPile(TestCase)>>debug
	Receiver: TestPile>>#testEmpty
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#testEmpty
		expectedFails: 	#()
		standard: 	nil
		pleine: 	nil
		vide: 	nil


TestPile class(TestCase class)>>debug:
	Receiver: TestPile
	Arguments and temporary variables: 
		aSymbol: 	#testEmpty
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#setUp->TestPile>>#setUp #testEmpty->TestPile>>#...etc...
		format: 	65541
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#TestPile
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#HAI914I
		history: 	a Dictionary(#errors->a Set(#testPush #testFull #testEmpty #testPop #t...etc...


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#testEmpty
		testClass: 	TestPile
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testEmpty))
		runTestCases: 	{TestPile}


[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testEmpty)
		testSelector: 	#testEmpty
		each: 	TestPile
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testEmpty))
		runTestCases: 	{TestPile}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(TestPile)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
		self runTest: testSelector of: each ]
		index: 	2
		each: 	TestPile
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. TestPile. nil. nil. nil}


ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testEmpty)
		testSelector: 	#testEmpty
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testEmpty))
		runTestCases: 	{TestPile}


[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(testEmpty)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testEmpty))
		runTestCases: 	{TestPile}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(testEmpty))
	Arguments and temporary variables: 
		aBlock: 	[:each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(testEmpty))

ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testEmpty))
		runTestCases: 	{TestPile}


ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
	Receiver: a ClyFullBrowserMethodContext
	Arguments and temporary variables: 
		aCommand: 	a ClyRunTestsFromMethodsCommand
		aCommandActivator: 	a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Receiver's instance variables: 
		tool: 	a ClyFullBrowserMorph(850096128)
		selectedItems: 	an Array(a ClyDataSourceItem(testEmpty))
		metaLevelScope: 	ClyInstanceSideScope


[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
	Receiver: a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		command: 	a ClyRunTestsFromMethodsCommand
		context: 	a ClyFullBrowserMethodContext
		activationStrategy: 	a ClyTableIconCommandActivation


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCo...etc...
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :exc | self processCommandFailure: exc ]
	Receiver's instance variables: 
		outerContext: 	CmdCommandActivator>>executeCommand
		startpc: 	a CompiledBlock: [self prepareCommandForExecution.
	context executeCom...etc...
		numArgs: 	0
		receiver: 	a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)


CmdCommandActivator>>executeCommand
	Receiver: a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		command: 	a ClyRunTestsFromMethodsCommand
		context: 	a ClyFullBrowserMethodContext
		activationStrategy: 	a ClyTableIconCommandActivation



--- The full stack ---
Pile class(Object)>>doesNotUnderstand: #initialize:
TestPile>>setUp
[self setUp.
	self performTest] in TestPile(TestCase)>>runCase
FullBlockClosure(BlockClosure)>>ensure:
TestPile(TestCase)>>runCase
[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>ensure:
[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>on:do:
TestExecutionEnvironment>>runTestCaseUnderWatchdog:
[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
FullBlockClosure(BlockClosure)>>ensure:
TestExecutionEnvironment>>runTestCase:
[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
FullBlockClosure(BlockClosure)>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
TestPile(TestCase)>>runCaseManaged
[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
FullBlockClosure(BlockClosure)>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in TestPile(TestCase)>>debug
FullBlockClosure(BlockClosure)>>ensure:
TestPile(TestCase)>>debug
TestPile class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
IdentitySet(Set)>>do:
ClyRunTestsFromMethodsCommand>>runTestItem:
[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
ClyRunTestsFromMethodsCommand>>execute
ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
FullBlockClosure(BlockClosure)>>on:do:
CmdCommandActivator>>executeCommand
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[target perform: actionSelector withArguments: arguments] in IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
IconicButtonMorph(SimpleButtonMorph)>>mouseUp:
IconicButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
IconicButtonMorph(Morph)>>handleEvent:
IconicButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

